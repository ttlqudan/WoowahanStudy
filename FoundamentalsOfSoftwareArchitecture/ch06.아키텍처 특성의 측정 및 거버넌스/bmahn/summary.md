## ch6. 아키텍처 특성의 측정 및 거버넌스
* 운영적 측정
    * 특정 요청에 대한 평균 응답시간을 측정할 때, 최대 응답시간도 함께 측정해야 특이점까지 잡아낼 수 있다
    * 성능 목표를 정할 때 아무 수치로 잡기보단, 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립 후 정하는 게 좋다. -> 통계 분석 결과로 얻은 나름의 정의 기반 (환경별)
* 구조적 측정
    * 코드의 복잡도는 순환복잡도(CC)라는 메트릭으로 측정할 수 있다
    * CC(순환복잡도) = E(간선) - N(노드) + 2P(연결된 컴포넌트 수)
* 프로세스 측정
    * 민첩성은 시험성, 배포성 등으로 나눌 수 있다
        * 시험성 : 코드 커버리지 등으로 측정 가능
        * 배포성 : 실패 대비 성공률, 배포 소요시간, 배포 시 발생한 이슈/버그 등으로 측정 가능

* 거버넌스
  * 아키텍트가 아키텍쳐 특성을 확정 후 우선순위를 정하면 개발자들이 이 우선순위를 잘 지킬거라 어떻게 확신할까?
  * 아키텍쳐 거버넌스 : 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄함
  * 아키텍쳐 거버넌스의 여러 부분을 자동화하기 위해 피트니스 함수를 사용함

* 피트니스 함수
  * 피트니스 함수 : 결과가 목표에 얼마나 근접했는지 나타내는 목표 함수
  * 아키텍쳐 피트니스 함수 : 어떤 아키텍쳐 특성의 객관적인 무결성을 평가하는 모든 메커니즘
  * 사용하는 방법에 따라 메트릭, 모니터, 단위테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있음
  * 모듈성의 다양한 측면을 테스트하는 피트니스 함수 예
    1. '순환 의존성' 피트니스 함수
       * 순환 의존성이 생기면 모듈성이 떨어진다
       * JDepend라는 메트릭 도구로 순환참조가 존재하면 테스트가 실패하도록 할 수 있다
    2. '메인 시퀀스로부터의 거리' 피트니스 함수
       * JDepend로 수용 가능한 임계치를 설정하고 클래스가 이 범위를 벗어나면 테스트가 실패하도록 할 수 있다
       * ArchUnit으로 개발자들이 레이어드 아키텍쳐를 잘 지키는지 확인할 수 있다


## 토론 거리