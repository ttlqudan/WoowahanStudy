# 5. 복제
다음 목표 달성을 위해 복제가 필요하다.
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생하더라도 지속적으로 동작할 수 있게 해 고가용성을 확보한다.
- 읽기 질의를 제공하는 장비의 수를 확장해 일기 처리량을 늘린다.

복제를 달성하는 방법들과 트레이드 오프에 대해 이해해보자
<br>
<br>

# 복제 모델
<br>

## 리더와 팔로워
모든 쓰기 요청을 리더가 받고, 리더의 내용을 팔로워에 반영한다. 읽기 연산은 팔로워를 통해 수행하여 부하를 줄인다.

### 동기식 복제 VS 비동기식 복제
동기식
* 동기식 복제는 팔로워의 복제 완료를 대기한다.
* 팔로워나 네트워크에 문제가 생기면 쓰기 전체에 영향을 주기 때문에 현실적으로 사용하지 못한다.

비동기식
* 비동기식 복제는 팔로워의 복제 완료를 대가하지 않는다.
* 복제 지연이 발생할 수 있다.
* 복제 지연이 발생한 채로 리더가 변경 되면 데이터 유실이 발생할 수 있다.

둘을 섞은 반동기식도 존재한다.
<br>
<br>

### 새로운 노드의 추가
새로운 노드가 추가될 때, 팔로워는 리더의 데이터를 올바르게 가지고 있음을 보장해야 한다. (복제 지연 제외)
그리고 이 과정에서 쓰기/읽기 연산은 지속적으로 제공 되어야 한다.
이를 위한 절차는 다음과 같다.
1. 리더의 데이터 Snapshot을 일정 시점에 가져온다.
2. Snapshot을 새로운 노드로 복제한다.
3. 팔로워는 리더에 연결해 Snapshot 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 Snapshot 이후의 데이터 변경의 미처리분을 모두 처리했을 때, 따라잡았다고 말한다. 이후부터 리더에 발생 하는 데이터 변화를 처리할 수 있다.

<br>
<br>

### 노드의 중단 처리
시스템의 모든 노드는 장애나 계획된 유지보수에 의해 중단될 수 있다.
고가용성을 위한 노드 중단 방식을 알아본다.

#### 팔로워 장애: 따라잡기 복구
1. 각 팔로워는 리더의 변경 로그를 로컬 디스크에 보관한다.
2. 장애 발생 이전 마지막 처리한 트랜잭션을 알아내고, 그 이후에 발생한 변경들을 리더에게 요구한다.
3. 리더에게 변경 내역들을 받아 적용하여 따라잡게 되고, 이어서 리더의 변경을 지속적으로 처리한다.


#### 리더 장애: 장애 복구
리더의 장애 복구는 크게 3가지 요소가 필요하다.
* 팔로워중 하나를 리더로 승격한다.
* 클라이언트는 새로운 리더로 쓰기를 요청할 수 있도록 재설정한다.
* 팔로워들은 새로운 리더로부터 변경을 소비한다.

리더의 장애 복구는 보통 다음과 같은 단계로 구성된다.
1. 리더가 장애인지 확인한다. 대부분의 시스템이 단순한 타임아웃 방식을 이용한다.
3. 새로운 리더를 선택한다. 네트워크 참여 노드들의 선출로 선택 하거나, 제어 노드에 의해 임명될 수 있다.
4. 새로운 리더 사용을 위해 시스템을 설정한다. 클라이언트는 새로운 리더에게 요청을 보낼 수 있어야 한다. 또한 이전 노드가 다시 돌아오면 자신이 리더라고 생각할 수 있으므로, 시스템은 새로운 리더를 인식할 수 있게끔 해야한다.

리더의 복구는 잘못될 수 있는 요소들이 많이 있다.
* 비동기식 복제의 데이터 유실
* 쓰기 폐기 방식 선택 시, 외부 데이터 시스템과 데이터 불일치 문제
* 스플릿 브레인
* 리더의 장애를 감지하는 적절한 Timeout 수치

<br>
<br>

### 복제 로그 구현
#### 구문 기반 복제

#### 쓰기 전 로그 배송

#### 논리적(로우 기반) 로그 복제

#### 트리거 기반 복제


<br>
<br>

## 복제 지연 문제


