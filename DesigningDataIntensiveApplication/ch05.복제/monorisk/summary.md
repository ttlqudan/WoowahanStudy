# 5. 복제
다음 목표 달성을 위해 복제가 필요하다.
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생하더라도 지속적으로 동작할 수 있게 해 고가용성을 확보한다.
- 읽기 질의를 제공하는 장비의 수를 확장해 일기 처리량을 늘린다.

복제를 달성하는 방법들과 트레이드 오프에 대해 이해해보자
<br>
<br>

# 복제 모델
<br>

## 리더와 팔로워
모든 쓰기 요청을 리더가 받고, 리더의 내용을 팔로워에 반영한다. 읽기 연산은 팔로워를 통해 수행하여 부하를 줄인다.

### 동기식 복제 VS 비동기식 복제
동기식
* 동기식 복제는 팔로워의 복제 완료를 대기한다.
* 팔로워나 네트워크에 문제가 생기면 쓰기 전체에 영향을 주기 때문에 현실적으로 사용하지 못한다.

비동기식
* 비동기식 복제는 팔로워의 복제 완료를 대가하지 않는다.
* 복제 지연이 발생할 수 있다.
* 복제 지연이 발생한 채로 리더가 변경 되면 데이터 유실이 발생할 수 있다.

둘을 섞은 반동기식도 존재한다.
<br>
<br>

### 새로운 노드의 추가
새로운 노드가 추가될 때, 팔로워는 리더의 데이터를 올바르게 가지고 있음을 보장해야 한다. (복제 지연 제외)
그리고 이 과정에서 쓰기/읽기 연산은 지속적으로 제공 되어야 한다.
이를 위한 절차는 다음과 같다.
1. 리더의 데이터 Snapshot을 일정 시점에 가져온다.
2. Snapshot을 새로운 노드로 복제한다.
3. 팔로워는 리더에 연결해 Snapshot 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 Snapshot 이후의 데이터 변경의 미처리분을 모두 처리했을 때, 따라잡았다고 말한다. 이후부터 리더에 발생 하는 데이터 변화를 처리할 수 있다.

<br>
<br>

### 노드의 중단 처리
시스템의 모든 노드는 장애나 계획된 유지보수에 의해 중단될 수 있다.
고가용성을 위한 노드 중단 방식을 알아본다.

#### 팔로워 장애: 따라잡기 복구
1. 각 팔로워는 리더의 변경 로그를 로컬 디스크에 보관한다.
2. 장애 발생 이전 마지막 처리한 트랜잭션을 알아내고, 그 이후에 발생한 변경들을 리더에게 요구한다.
3. 리더에게 변경 내역들을 받아 적용하여 따라잡게 되고, 이어서 리더의 변경을 지속적으로 처리한다.


#### 리더 장애: 장애 복구
리더의 장애 복구는 크게 3가지 요소가 필요하다.
* 팔로워중 하나를 리더로 승격한다.
* 클라이언트는 새로운 리더로 쓰기를 요청할 수 있도록 재설정한다.
* 팔로워들은 새로운 리더로부터 변경을 소비한다.

리더의 장애 복구는 보통 다음과 같은 단계로 구성된다.
1. 리더가 장애인지 확인한다. 대부분의 시스템이 단순한 타임아웃 방식을 이용한다.
3. 새로운 리더를 선택한다. 네트워크 참여 노드들의 선출로 선택 하거나, 제어 노드에 의해 임명될 수 있다.
4. 새로운 리더 사용을 위해 시스템을 설정한다. 클라이언트는 새로운 리더에게 요청을 보낼 수 있어야 한다. 또한 이전 노드가 다시 돌아오면 자신이 리더라고 생각할 수 있으므로, 시스템은 새로운 리더를 인식할 수 있게끔 해야한다.

리더의 복구는 잘못될 수 있는 요소들이 많이 있다.
* 비동기식 복제의 데이터 유실
* 쓰기 폐기 방식 선택 시, 외부 데이터 시스템과 데이터 불일치 문제
* 스플릿 브레인
* 리더의 장애를 감지하는 적절한 Timeout 수치

<br>
<br>

### 복제 로그 구현
#### 구문 기반 복제
리더가 수행한 구문(Statement)을 팔로워에게 전달하여 수행. 합리적일 것 같으나 다음과 같은 문제가 있음.
* NOW(), RAND() 같은 비결정적 함수를 호출하는 모든 구문은 노드마다 다른 값을 만들 가능성이 있다.
* 자동증가 컬럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 팔로워는 리더와 정확히 동일한 순서로 수행 되어야 한다.
* 부수 효과를 가진 구문(ex: 트리거, 스토어드 프로시저, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 팔로워에서 다른 결과가 나올 수 있다.

리더가 구문을 기록할 때, 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있다.

#### 쓰기 전 로그(WAL) 배송
리더가 WAL을 팔로워에게 전달한다.
팔로워가 이 로그를 처리하면 리더와 동일한 복제본이 생성 되나, 복제가 저장소 엔진과 밀접하게 엮인다.
복제 프로토콜이 여러 버전을 허용하지 않는다면, 리더와 팔로워의 버전을 다르게 실행할 수 없을 수도 있다.

#### 논리적(로우 기반) 로그 복제
복제 로그를 저장소 엔진과 분리하기 위해, 물리적 형식과는 다른 로그 형식을 사용할 수 있다.
논리적 로그(logical log)라고 한다.

관계형 데이터베이스용 논리적 로그는 대게 로우 단위 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.
여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다.
* 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
* 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다. 보통 이것은 기본키지만 테이블에 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
* 갱시된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값(적어도 변경된 모든 칼럼의 새로운 값)을 포함한다.

이런 데이터는 외부 애플리케이션이 파싱하기 쉽다. 이런 특징을 이용하여 데이터 웨어하우스 같은 외부시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다.

#### 트리거 기반 복제
위의 상황들 보다 좀 더 유연하게 복제를 수행해야 하는 경우도 있다.
예를 들어 데이터의 서브셋만 복제하거나, 데이터베이스를 다른 종류의 데이터베이스로 복제하거나 충돌을 해소 로직이 필요한 경우이다.
이를 위해 트리거를 제공하여 사용자의 애플리케이션 코드를 등록할 수 있도록 하는 방법도 있다.
일반적으로 이 방식은 다른 복제 방식보다 오버헤드가 있으나, 유연함으로 인해 유용한 경우가 많다.

<br>
<br>

## 복제 지연 문제


<br>
<br>

## 다중 리더 복제

<br>
<br>

## 리더 없는 복제

<br>
<br>

