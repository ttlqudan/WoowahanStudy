# 5. 복제
다음 목표 달성을 위해 복제가 필요하다.
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생하더라도 지속적으로 동작할 수 있게 해 고가용성을 확보한다.
- 읽기 질의를 제공하는 장비의 수를 확장해 일기 처리량을 늘린다.

복제를 달성하는 방법들과 트레이드 오프에 대해 이해해보자
<br>
<br>

# 복제 모델
<br>

## 리더와 팔로워
모든 쓰기 요청을 리더가 받고, 리더의 내용을 팔로워에 반영한다. 읽기 연산은 팔로워를 통해 수행하여 부하를 줄인다.

### 동기식 복제 VS 비동기식 복제
동기식
* 동기식 복제는 팔로워의 복제 완료를 대기한다.
* 팔로워나 네트워크에 문제가 생기면 쓰기 전체에 영향을 주기 때문에 현실적으로 사용하지 못한다.

비동기식
* 비동기식 복제는 팔로워의 복제 완료를 대가하지 않는다.
* 복제 지연이 발생할 수 있다.
* 복제 지연이 발생한 채로 리더가 변경 되면 데이터 유실이 발생할 수 있다.

둘을 섞은 반동기식도 존재한다.
<br>
<br>

### 새로운 노드의 추가
새로운 노드가 추가될 때, 팔로워는 리더의 데이터를 올바르게 가지고 있음을 보장해야 한다. (복제 지연 제외)
그리고 이 과정에서 쓰기/읽기 연산은 지속적으로 제공 되어야 한다.
이를 위한 절차는 다음과 같다.
1. 리더의 데이터 Snapshot을 일정 시점에 가져온다.
2. Snapshot을 새로운 노드로 복제한다.
3. 팔로워는 리더에 연결해 Snapshot 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 Snapshot 이후의 데이터 변경의 미처리분을 모두 처리했을 때, 따라잡았다고 말한다. 이후부터 리더에 발생 하는 데이터 변화를 처리할 수 있다.

<br>
<br>

### 노드의 중단 처리
시스템의 모든 노드는 장애나 계획된 유지보수에 의해 중단될 수 있다.
고가용성을 위한 노드 중단 방식을 알아본다.

#### 팔로워 장애: 따라잡기 복구
1. 각 팔로워는 리더의 변경 로그를 로컬 디스크에 보관한다.
2. 장애 발생 이전 마지막 처리한 트랜잭션을 알아내고, 그 이후에 발생한 변경들을 리더에게 요구한다.
3. 리더에게 변경 내역들을 받아 적용하여 따라잡게 되고, 이어서 리더의 변경을 지속적으로 처리한다.


#### 리더 장애: 장애 복구
리더의 장애 복구는 크게 3가지 요소가 필요하다.
* 팔로워중 하나를 리더로 승격한다.
* 클라이언트는 새로운 리더로 쓰기를 요청할 수 있도록 재설정한다.
* 팔로워들은 새로운 리더로부터 변경을 소비한다.

리더의 장애 복구는 보통 다음과 같은 단계로 구성된다.
1. 리더가 장애인지 확인한다. 대부분의 시스템이 단순한 타임아웃 방식을 이용한다.
3. 새로운 리더를 선택한다. 네트워크 참여 노드들의 선출로 선택 하거나, 제어 노드에 의해 임명될 수 있다.
4. 새로운 리더 사용을 위해 시스템을 설정한다. 클라이언트는 새로운 리더에게 요청을 보낼 수 있어야 한다. 또한 이전 노드가 다시 돌아오면 자신이 리더라고 생각할 수 있으므로, 시스템은 새로운 리더를 인식할 수 있게끔 해야한다.

리더의 복구는 잘못될 수 있는 요소들이 많이 있다.
* 비동기식 복제의 데이터 유실
* 쓰기 폐기 방식 선택 시, 외부 데이터 시스템과 데이터 불일치 문제
* 스플릿 브레인
* 리더의 장애를 감지하는 적절한 Timeout 수치

<br>
<br>

### 복제 로그 구현
#### 구문 기반 복제
리더가 수행한 구문(Statement)을 팔로워에게 전달하여 수행. 합리적일 것 같으나 다음과 같은 문제가 있음.
* NOW(), RAND() 같은 비결정적 함수를 호출하는 모든 구문은 노드마다 다른 값을 만들 가능성이 있다.
* 자동증가 컬럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 팔로워는 리더와 정확히 동일한 순서로 수행 되어야 한다.
* 부수 효과를 가진 구문(ex: 트리거, 스토어드 프로시저, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 팔로워에서 다른 결과가 나올 수 있다.

리더가 구문을 기록할 때, 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있다.

#### 쓰기 전 로그(WAL) 배송
리더가 WAL을 팔로워에게 전달한다.
팔로워가 이 로그를 처리하면 리더와 동일한 복제본이 생성 되나, 복제가 저장소 엔진과 밀접하게 엮인다.
복제 프로토콜이 여러 버전을 허용하지 않는다면, 리더와 팔로워의 버전을 다르게 실행할 수 없을 수도 있다.

#### 논리적(로우 기반) 로그 복제
복제 로그를 저장소 엔진과 분리하기 위해, 물리적 형식과는 다른 로그 형식을 사용할 수 있다.
논리적 로그(logical log)라고 한다.

관계형 데이터베이스용 논리적 로그는 대게 로우 단위 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.
여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다.
* 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
* 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다. 보통 이것은 기본키지만 테이블에 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
* 갱시된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값(적어도 변경된 모든 칼럼의 새로운 값)을 포함한다.

이런 데이터는 외부 애플리케이션이 파싱하기 쉽다. 이런 특징을 이용하여 데이터 웨어하우스 같은 외부시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다.

#### 트리거 기반 복제
위의 상황들 보다 좀 더 유연하게 복제를 수행해야 하는 경우도 있다.
예를 들어 데이터의 서브셋만 복제하거나, 데이터베이스를 다른 종류의 데이터베이스로 복제하거나 충돌을 해소 로직이 필요한 경우이다.
이를 위해 트리거를 제공하여 사용자의 애플리케이션 코드를 등록할 수 있도록 하는 방법도 있다.
일반적으로 이 방식은 다른 복제 방식보다 오버헤드가 있으나, 유연함으로 인해 유용한 경우가 많다.

<br>
<br>

## 복제 지연 문제
비동기 팔로워는 일시적으로 리더와 불일치 할 수 있다. 이때 팔로워에게 읽기 연산을 수행하면 리더와 다른 결과를 얻게 된다.
데이터베이스에 쓰기를 멈추고 잠시 동안 기다리면 팔로워는 결국 리더를 따라잡게 되고, 이런 효과를 최종적 일관성이라고 한다.
최종적이라는 용어는 모호하다. 일반적으로 팔로워가 얼마나 뒤쳐질 수 있는가에 대한 제한은 없다.
통상적으로는 아주 짧은 시간이나, 시스템이 가용량 근처에서 동작하거나 장애가 생기면 수초에서 수분으로 늘어날 수 있다.

### 자신이 쓴 내용 읽기
리더 기반의 복제 방식에서 쓰기 후 읽기 일관성을 위한 다양한 기법들이 있다.
* 사용자가 수정한 내용을 읽을 때 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다. 이를 위해서는 무엇이 수정 되었는지 알 방법이 필요하다.
* 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면, 대부분의 읽기는 리더에서 읽기 때문에 효율적이지 않다. 이 경우는 마지막 갱신 후 1분 까지는 리더에서 읽기를 수행하는 등의 정책이 필요하다. 또한 팔로워에서는 복제 지연을 모니터링 하여 리더보다 1분 이상 늦은 모든 팔로워는 질의를 금지할 수 있다.
* 클라이언트는 가장 최근 쓰기의 타임스탬프를 알 수 있다. 팔로워가 해당 타임스탬프에 도달하지 못했다면 다른 팔로워에서 읽기를 수행하거나 질의를 대기할 수 있다.
* 팔로워가 여러 데이터센터에 분산 됐다면 복잡도가 증가한다. 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅 되어야 한다.

여러 디바이스간 쓰기 후 읽기 일관성을 제공할 수 있어야 하는데, 이것은 더 복잡한 문제를 동반한다.
* 클라이언트 관점의 마지막 타임스탬프를 이용하는 방식은 디바이스간 클라이언트의 타임스탬프를 공유할 수 없어 불가능하다. 이 메타데이터를 중앙집중식으로 관리하는 방식이 필요하다.
* 팔로워가 여러 데이터센터에 분산 되어 있다면 디바이스간 네트워크 라우팅이 다를 수 있다.리더에서 읽어야 할 필요가 있는 접근법이라면 여러 디바이스에서 동일한 데이터센터로 라우팅할 수 있어야 한다.


### 단조 읽기(Monotonic Read)
비동기식 팔로워는 사용자가 시간이 거꾸로 흐르는 현상을 만날 수 있다.
팔로워간 복제 시점이 다르기 때문에 발생한다.

단조 읽기는 이런 현상이 발생하지 않음을 보장한다.
단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장이다.
데이터를 읽을 때 이전 값을 볼 수는 있으나, 여러번 읽어도 시간이 돌아가는 현상은 나타지 않는다.

단조 읽기를 위한 방법은 각 사용자가 항상 동일한 팔로워에서 질의하도록 하는 것이다. 임의 선택보다는 ID의 해시를 기반으로 팔로워를 선택한다.
선택된 팔로워에 장애가 발생하면 다른 팔로워를 선택할 수 있어야 한다.


### 일관된 순서로 읽기(Consistent Prefix Read)
파티셔닝된 데이터베이스에서 발생할 수 있는 문제로서, 분리된 파티션간 복제 지연이 다를 경우 트랜잭션의 발생 순서와 다른 순서로 읽히는 문제가 있다.

한 가지 해결책은 인과성이 있는 쓰기가 동일한 파티션에서 발생할 수 있게 하는 것이나, 일부 애플리케이션은 적절하지 않다.

<br>
<br>

## 다중 리더 복제

<br>
<br>

## 리더 없는 복제

<br>
<br>

