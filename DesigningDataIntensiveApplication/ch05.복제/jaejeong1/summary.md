# 파트2. 데이터 시스템의 기초

# 5장. 복제
- 데이터 복제가 필요한 이유
- 복제의 모든 어려움은 복제된 데이터의 변경 처리
- 복제 설정 옵션에 따른 트레이드 오프


- 데이터 복제가 필요한 이유
  - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다
  - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
  - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다

- 복제의 어려움
  - 복제된 데이터의 변경 처리

- 노드 간 변경을 복제하기 위한 세 가지 알고리즘
  - 단일 리더(single leader)
  - 다중 리더(multi leader)
  - 리더 없는(leaderless)

- 복제 시 고려해야할 트레이드오프
  - 동기식 vs 비동기식
  - 잘못된 복제본 처리 방식

## 리더와 팔로워
- 복제 서버
  - 데이터베이스의 복사본을 저장하는 각 노드
  - 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 것인지?
- DB의 모든 쓰기는 모든 복제 서버에서 처리돼야함
  - 그렇지 않으면 복제 서버는 더이상 동일한 데이터를 유지할 수 없음
  - 해결책
    - 리더 기반 복제(leader-based replication) 또는 마스터 슬레이브 복제
    - 복제 서버 중 하나를 리더로 지정
    - 클라이언트가 DB 쓰기 시 클라이언트를 요청을 리더로 보내야함
    - 리더는 먼저 로컬 저장소에 새로운 데이터를 기록함
    - 다른 복제 서버는 팔로워라고 함
    - 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송
    - 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 DB의 로컬 복사본을 갱신함
    - 클라이언트가 읽기를 할때는 리더 또는 임의 팔로워에게 질의할 수 있지만 쓰기는 리더에게만 허용된다
- 리더 기반 복제는 DB뿐만 아니라, 분산 메시지 브로커에도 사용됨

## 동기식 vs 비동기식 복제
- 동기식
  - 리더는 팔로워가 쓰기를 수신했는지 확인해줄때까지 기다림
  - 확인이 끝나면 사용자에게 성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여줌
- 비동기식
  - 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않음
- 복제는 보통 매우 빠르나, 특정 상황에 따라 팔로워가 수분 이상 리더와 떨어질 수도 있음
  - 특정 상황
    - 장애 복구 중
    - 시스템이 최대 가용량 부근에서 동작 중
    - 노드 간 네트워크 문제
- 동기식 장점
  - 팔로워가 리더와 일관성있게 최신 데이터 복사본을 가지는 것을 보장
  - 갑자기 리더가 동작하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신할 수 있음
- 동기식 단점
  - 팔로워가 응답하지 않는다면 쓰기가 처리되지 않음(block 됨)
  - 따라서 모든 팔로워가 동기식인 상황은 비현실적
  - 한 노드의 장애가 전체 시스템을 멈추게 하기 때문
- 그래서 보통 팔로워 하나는 동기식으로 하고, 나머지는 비동기식으로 적용한다
- 동기식 팔로워가 사용 불가해지면 비동기식 팔로워 중 하나가 동기식이 된다
- 이것은 적어도 두 노드(리더, 동기 팔로워)에 최신 데이터가 있음을 보장하고, 반동기식(semi-synchronous)라 함
- 비동기식 장점
  - 모든 팔로워가 장애라도, 리더가 쓰기 처리르 계속할 수 있음
- 많은 팔로워가 있거나 지리적으로 분산됐다면 비동기식 복제를 널리 사용함
- **체인복제와 마이크로소프트 Azure 저장소**

## 새로운 팔로워 설정
- 때로 복제 서버 수를 늘리거나 장애 노드를 대체하기 위해 새 팔로워를 설정해야 한다
- 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?
- 클라이언트는 지속적으로 DB에 쓰고, 데이터는 항상 유동적이기에 복제 결과가 유효하지 않을 수 있다
- DB를 잠궈서 쓰기를 불가능하게 하면 일관성은 유지되지만 가용성 목표에 부적합하다
- 중단시간 없이 팔로워 설정을 수행하는 법
  - 리더 DB 스냅샷을 일정 시점에 가져온다
  - 스냅샷을 새 팔로워 노드에 복사한다
  - 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청한다
  - 팔로워가 스냅샷 이후 데이터 변경 미처리분을 모두 처리했을 때 따라잡았다고 하고, 이제 리더에 발생하는 데이터 변화를 이어 처리할 수 있다

## 노드 중단 처리
- 리더 기반 복제에서 고가용성은 어떻게 달성할까?
- 팔로워 장애: 따라잡기 복구
  - 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관함
  - 장애가 발생하면 로그에서 장애 발생 전 처리한 마지막 트랜잭션을 알아내 이후 발생한 데이터 변경을 모두 요청해 처리한다
- 리더 장애: 장애 복구
  - 팔로워 중 하나를 새 리더로 승격하고 클라이언트는 새 리더로 쓰기를 전송하기 위해 재설정이 필요함
  - 다른 팔로워는 새 리더로부터 데이터 변경을 소비해야 함. 이 과정을 장애 복구(failover)라 함
  - 자동 장애 복구
    - 대부분 단순히 타임아웃을 사용해 리더의 장애 여부를 판단한다
    - 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버를 새 리더로 선택한다
    - 새 리더 사용을 위해 시스템을 재설정한다
- 장애 복구 과정 중 잘못된 사례
  - 비동기식 복제를 사용할 경우 새 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다
  - 외부 저장소 시스템이 DB 내용에 맞춰 조정될 경우 유효하지 않은 팔로워가 리더로 승격될 수 있다
  - 스플릿 브레인(두 노드가 모두 자신이 리더라 믿음)
  - 타임 아웃이 너무 짧으면 불필요한 장애복구가 발생할 수 있음

## 복제 로그 구현
- 리더 기반 복제는 내부적으로 어떻게 동작할까?
- 구문 기반 복제
  - 리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송함
  - DB는 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행함
  - 에지 케이스
    - NOW(현재 시각)나 RAND(임의 숫자) 같은 비결정적 함수를 호출하는 모든 구문을 복제 서버마다 다른 값을 생성할 가능성 존재
    - AUTO INCREMENT 사용 시 각 복제 서버에서 정확히 같은 순서로 실행되지 않으면 결과가 달라질 수 있어 동시에 여러 트랜잭션 수행을 어렵게 한다
  - 해결책
    - 리더가 구문 기록 시 모든 비결정적 함수 호출에 대해 고정 값을 반환하도록 대체
- 쓰기 전 로그 배송
  - 모든 쓰기는 로그에 기록함
  - 이 로그는 팔로워에게 전송되고, 팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 복제본이 만들어짐
  - 단점
    - 로그 데이터로 인해 DB 저장소 엔진에 강하게 의존하게 되어 리더와 팔로워의 DB SW 버전을 다르게 실행할 수 없다
    - 무중단 DB SW 업그레이드를 어렵게 하는 요소
- 논리적(로우 기반) 로그 복제
  - 로우 단위로 DB 테이블에 쓰기를 기술한 레코드 열
  - 로그를 저장소 엔진과 분리했기 때문에 하위 호환성 유지가 쉽고, 리더와 팔로워 간 DB SW 버전이나 DB 종류를 다르게 가져갈 수도 있다
  - 외부 애플리케이션이 파싱하기 쉬운 형태이기에, CDC(Change Data Capture) 구축 용이

## 트리거 기반 복제
- 데이터의 서브셋만 복제하거나, DB 종류를 변경해 복제하거나 충돌 해소 로직이 필요하면 애플리케이션 레벨에서 처리해야함
- DB 로그를 읽어 처리하거나, 트리거 또는 스토어드 프로시저를 사용함
- DB 데이터가 변경되면 애플리케이션 코드를 트리거해 별도 로깅하고, 이를 외부에서 읽어 데이터 변경을 복제할 수 있다
  - 예시 : 오라클 데이터버스 등
- 다른 복제방식보다 많은 오버헤드 발생. 버그나 제약이 더 많음
- 유연성은 다른 복제방식보다 좋음

# 복제 지연 문제
- 복제는 확장성과 지연 시간을 위해서도 필요하다
- 읽기가 주인 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 효율적으로 처리할 수 있음
- 다만 이 방식은 비동기식 복제에서만 동작하고 동기식으로 하면 단일 노드 장애나 네트워크 중단으로 전체 시스템 쓰기가 불가능해질 수도 있음
- 비동기 팔로워에서 팔로워가 뒤처지면 지난 데이터를 볼 수도 있지만 이는 일시적인 상태이고, 최종적으로 동기화되게 된다(최종적 일관성)
- 최종적 일관성이 있어도 지연이 매우 크면 이는 실제 문제가 되기 때문에 해결 필요

## 자신이 쓴 내용 읽기
- 문제
  - 사용자가 쓰기를 수행한 직후 데이터를 보면 새 데이터는 아직 복제 서버에 반영되지 않을 수 있음
- 해결책
  - 쓰기 후 일관성
    - 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해선 보장하지 않음
- 구현 방법
  - 사용자가 수정한 내용은 리더에서, 다른 사용자의 경우는 팔로워에서 읽는다
- 그 외
  - 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 유사한 문제가 발생할 수 있는데, 이 경우 디바이스 간 쓰기 후 읽기 일관성이 제공되야함
  - 갱신 시점을 중앙집중식으로 관리하고, 리더에서 읽기 위해 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야함

## 단조 읽기
- 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있음
- 각기 다른 복제에서 여러 읽기를 수행할 때 발생 가능
- 단조 읽기(monotonic read)로 이런 이상 현상이 발생하지 않음을 보장
- 각 사용자의 읽기를 항상 동일한 복제 서버에서 수행하도록 해 달성

## 일관된 순서로 읽기
- 메시지 순서가 원본과 다르게 읽혀질 수 있다
- 일관된 순서로 읽기(Consistent Prefix Read) 보장이 필요
- 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장
- 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제
- 분산 DB에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기가 항상 같은 순서로 동작하기 어렵다
- 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 해 해결할 수 있다
  - 실제로 어떻게 구현할까?

## 복제 지연을 위한 해결책
- 최종적 일관성 시스템을 선택할때 복제 지연 시간에 따라 사용자 경험을 고려해야함
- 사용자 경험이 좋지 않다면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템을 설계해야함
- 비동기식으로 동작하지만 동기식인척하자..!

# 다중 리더 복제
- 리더 기반 복제는 리더에 연결할 수 없다면 DB 쓰기가 불가한 단점이 있다
- 쓰기를 허용하는 노드를 하나 이상 두는 방식을 다중 리더 설정이라 부르고, 각 리더는 동시에 다른 리더의 팔로워 역할도 한다
- 사용 사례
  - 다중 데이터센터 운영
  - 오프라인 작업을 하는 클라이언트
  - 협업 편집
- 다중 리더 복제 단점
  - 동일한 데이터를 동시에 변경할 수 있어 쓰기 충돌을 해소해야함
  - AUTO INCREMENT, 트리거, 무결성 제약 조심
## 쓰기 충돌
- 제일 간단한 전략은 충돌을 피하는 것
- 예시
  - 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기 쓰기를 하게끔 보장할 수 있음
  - 데이터센터가 고장나면 다른 데이터센터로 라우팅해야하기 때문에 이런 상황은 대비해야됨

## 일관된 상태 수렴
- 다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 명확하지 않다
- 따라서 수렴(convergent) 방식으로 충돌을 해소해 모든 복제 서버를 최종적으로는 동일하다고 보장해줘야한다
- 예시
  - 각 쓰기에 고유 Id를 부여하고, 가장 높은 ID를 가진 쓰기를 고르고 나머진 버린다(데이터 유실 위험 존재)
  - 각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버 쓰기를 낮은 숫자 서버보다 우선 적용한다(데이터 유실 위험 존재)
  - 값을 병합
  - 데이터 구조에 충돌을 기록해 모든 정보를 보존하고 나중에 애플리케이션에서 충돌을 해소한다 (대부분 이 방법 사용)

## 다중 리더 복제 토폴로지
- 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로
- MySQL은 원형 토폴로지만 제공
- 원형 토폴로지 단점
  - 한 노드에 장애가 발생하면 해당 노드가 복구될 때 까지 통신을 할 수 없다
- 전체 연결 토폴로지 단점
  - 일부 네트워크 연결이 네트워크 혼잡으로 다른 연결보다 빠르다면 일부 복제 메시지가 다른 메시지를 추월할 수 있다
- 이벤트를 올바르게 정렬하기 위해 버전 벡터(version vector) 기법을 사용할 수 있음
- 하지만 아직, 많은 시스템에서 충돌 감지 기법을 제대로 구현되지 않았고, 사용 시 이런 문제를 인지하고 사용해야한다

# 리더 없는 복제
- 일부 DB 시스템은 리더 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용함

## 노드가 다운됐을 때 데이터베이스에 쓰기
- 복제 서버 중 하나가 장애가 발생했을 때 리더 없는 복제에서는 장애 복구를 하지 않아도 쓰기 처리를 계속할 수 있다
- 각 복제 서버로 쓰기 요청을 병렬로 전송하고, 복제 서버 중 하나가 쓰기를 놓친 사실을 무시한다
- 이때, 나중에 해당 노드에서 데이터를 읽으면 오래된(outdated) 값을 얻을 수 있기 때문에 읽기 요청을 병렬로 여러 노드에 전송한다
- 버전 숫자를 사용해 어떤 값이 최신 내용인지 판단한다

## 읽기 복구와 안티 엔트로피
- 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 어떻게 따라잡을까?
- 읽기 복구
  - 클라이언트가 여러 노드에서 병렬 읽기를 수행하면 오래된 응답을 감지하고 처리할 수 있다
  - 값을 읽을 때만 처리 가능하기 때문에 값을 자주 읽는 상황에 적합하다
- 안티 엔트로피 처리
  - 추가적으로 일부 데이터스토어는 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 따라잡는다
  - 특정 순서로 쓰기를 복사하기 때문에 상당한 지연이 있을 수 있다

## 읽기와 쓰기를 위한 정족수
- 여러 복제 서버 중 하나만 쓰기를 허용하면 어떻게 해야할까? 어느 범위까지 허용해야 할까?
- 정족수 읽기/쓰기
  - n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 확정되고, 모든 읽기는 최소한 r개의 노드에 질의해야 최신 값을 얻을 수 있음을 보장
  - 유요한 읽기/쓰기를 위해 필요한 최소 투표수
  - 설정 예시
    - 보통 n을 홀수로 하고 (n+1) / 2로 r과 w를 정한다
    - 또는 쓰기가 적고 읽기가 많으면 w = n, r = 1로 설정하면 좋다
    - 이렇게 하면 읽기는 더 빨라지지만 노드 하나가 고장나면 모든 데이터베이스 쓰기가 실패한다
  - 정족수 조건이 w+r > n이면 사용 불가능한 노드를 용인한다
    - w < n이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다
    - r < n이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다
  - w과 r이 작을수록 오래된 값을 읽을 확률이 높다
  - 견고한 보장은 트랜잭션이나 합의가 필요하다

## 최신성 모니터링
- 리더의 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량을 측정할 수 있다
- 리더 없는 복제 시스템에서는 쓰기 적용 순서를 고정할 수 없어 모니터링이 좀 더 어렵다
- 운용성을 위해 "최종적" 일관성을 정량화할 수 있어야 한다

## 느슨한 정족수와 암시된 핸드오프
- 대규모 클러스터에서 클라이언트는 네트워크 장애 상황 에서 일부 DB 노드(정족수 구성에 들어가지 않는)에 연결될 가능성이 있고, 이때 트레이드오프에 직면한다
  - 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 더 좋을지?
  - 아니면 일단 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할지?
- 후자를 느슨한 정족수라 부른다
- 네트워크 장애가 복구되면 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송하고, 이를 암시된 핸드오프라 부른다
- 이는 쓰기 가용성을 높이는데 특히 유용하다
- 암시된 핸드오프가 완료될 떄 까지는 읽기가 저장된 최신 데이터를 본다는 보장은 없다

## 동시 쓰기 감지
- 동시 쓰기가 허용된 경우 데이터 손실 방지를 위해 애플리케이션 단에서 충돌을 다뤄 처리해야한다

## 최종 쓰기 승리(동시 쓰기 버리기)
- 각 복제본이 가진 예전 값을 버리고 가장 최신 값으로 덮어쓰는 방법
- 최종 쓰기 승리(LWW)는 최종적 수렴 달성이 목표지만 지속성을 희생한다

## 이전 발생 관계와 동시성
- 작업 B가 작업 A에 대해 알거나 A에 의존하거나 등 A를 기반한다면 작업 A는 작업 B의 이전 발생(happens-before)이다
- 동시성
  - 각 작업이 서로 알지 못하면 두 작업은 동시에 수행됐다 말한다
  - 네트워크가 느려지거나 특정 시점에 중단되면 이 때문에 한 작업이 다른 작업에 대해 알 수 없기 때문에 두 작업 간 시간 간격이 있어도 동시에 수행한 것으로 본다

## 이전 발생 관계 파악하기
- 두 작업이 동시에 발생했는지 또는 하나가 이전에 발생했는지 여부를 결정하는 알고리즘
- 동작 순서
  - 서버가 모든 키에 대한 버전 번호를 유지, 키를 기록할 때마다 버전 번호를 증가시킨다. 기록한 값을 새로운 버전 번호를 가지고 저장된다.
  - 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환한다. 클라이언트는 쓰기 전에 키를 읽어야 한다
  - 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고, 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다
  - 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다. 하지만 이보다 높은 버전 번호의 모든 값을 유지해야한다.
- 쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다
- 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다

## 동시에 쓴 값 병합
- 이 알고리즘은 어떤 데이터도 자동으로 삭제되지 않음을 보장하지만 불행히도 클라이언트가 추가적으로 작업을 수행해야 한다
- 여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야한다. 이런 동시 값을 형제(sibling) 값이라 부른다
- 간단하게 버전 번호나 타임스탬프 기반으로 하나를 선택해 처리해도 되지만 이는 데이터 손실이 발생할 수 있다
- 대신 합집합을 취하고 병합 시 제거된 버전 번호를 삭제 표시를 해 제거 여부를 나타내어 방지한다

## 버전 벡터
- 다중 복제본이 있지만 리더가 없는 경우에는 키당 버전 번호뿐만 아니라 복제본당 버전 번호도 사용해야 한다
- 모든 복제본의 버전 번호 모음을 버전 벡터(version vector)라고 부른다.
- 버전 벡터는 값을 읽을 때 데이터베이스 복제본에서 클라이언트로 보낸다.
- 이후 값이 기록될 때 데이터베이스로 다시 전송해야 한다
- 이 버전 벡터를 사용하면 데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있다
- 또한 버전 벡터는 하나의 복제본을 읽은 다음 이어 다른 복제본에 다시 쓰는 작업이 안전함을 보장한다
- 이렇게 하면 형제가 생성돼도 형제가 올바르게 병합되는 한 데이터 손실은 없다

* 키워드
    - 최종적 일관성
    - 체인 복제