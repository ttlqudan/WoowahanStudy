# 5장. 복제

- 복제란? 
  - **네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다.**
  - 필용한 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
    - 시스템의 일부 장애가 발생해도 지속적으로 도작할 수 있게해 가용성을 높인다.
    - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

- 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.
- 노드간 변경을 복제하기 위한 세가지 알고리즘
  - 단일 리더 (single-leader)
  - 다중 리더 (multi-leader)
  - 리더 없는 복제 (leaderless)

### 리더와 팔로워
- 리더 기반의 복제
  - leader/master/primary 를 지정하고 쓰기를 이쪽으로 요청
  - follower/read-replica/slave/secondary/host-standby 
    - 복제로그, 변경 스트림의 일부로 동기화
    - 읽기질의는 복제서버로 처리
- 동기식 vs 비동기식 복제
  - 동기식 복제
    - 장점 : 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
    - 단점 : 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다. (모든 쓰기를 차단하고 복제서버의 응답을 대기해야만 한다.)
  - 반동기식 복제
    - 팔로워 하나는 동기식으로 하고 그밖에는 비동기식으로.
    - 동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다.
    - 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장
  - 비동기식 복제
    - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점
    - 내구성을 약화시키기 때문에 나쁜 트레이드오프
    - 많은 팔로워가 있거나 지리적으로 분산됐을 경우 사용
- 새로운 팔로워 설정
  - 중단시간 없이 수행 가능
  - 특정 스냅샷 기준으로 미처리분을 요청, 따라 잡은 뒤 데이터 변화를 이어 처리 가능
- 노드 중단 처리 (고가용성 달성)
  - 팔로워 장애 : 따라잡기 복구
    - 데이터 변경로그를 로컬에 보관
    - 끊긴 시점 이후로 처리된 마지막 트랜잭션을 알아내서 따라잡은뒤 정상화
  - 리더 장애 : 장애 복구
    - 장애 복구(failover)
      1. 리더가 장애인지 판단 (by 타임아웃)
      2. 새로운 리더를 선택 (대다수 복제 서버에 선택되거나 이전에 선출된 제어 노드에 의해 리더로 임명)
      3. 새로운 리더 사용을 위해 재설정 (리더 변경에 따른 합의)
    - 위험성
      - 이전 리더의 쓰기를 일부 누락 가능
      - 쓰기 폐기시 타 외부 시스템과의 협력간 문제 발생
      - 스플릿 브레인(split brain) : 서로가 리더라고 우기는 상황
      - 타임아웃 기준이 애매하여 잘못된 장애 판단으로 불필요한 장애 복구 발생
- 복제로그 구현
  - 구문 기반 복제
    - 모든 쓰기 요청(구문(statement))을 팔로워에게 전송
    - 복제가 깨질수 있는 위험 : 서버마다 다른 환경(now, rand 등), 자동증가 컬럼에 의존하는 경우, 트리거/프로시저 사용이 서버마다 다를 경우
      - 비 결정적 함수 호출을 고정 값을 반환하게끔 대체 가능
      - 여러 엣지 케이스때문에 일반적으로는 다른 복제 방법을 선호
  - 쓰기 전 로그 배송
    - 일반적으로 모든 쓰기는 로그에 기록된다. (WAL : writer-ahead log)
    - 쓰기 전 로그를 활용하여 리더에서 있는것과 동일하게 구성 가능
    - 로그는 저장소 엔진과 밀접하게 엮임. 데이터베이스 형식을 다른 버전으로 변경시의 어려움
  - 논리적(로우 기반) 로그 복제
    - 저장소 엔진의 데이터 표현과 구별하기 위해 논리적 로그를 사용
    - 데이터베이스 변경에도 호환성 유지
    - 외부 어플리케이션에서 파싱이 쉬움, CDC (change data capture)시 활용
  - 트리거 기반 복제
    - 수동으로 원하는 상황/범위에 따라 복제 가능
    - 버그나 제한사항이 많이 발생 하지만 유연하다는 장점

### 복제 지연 문제
- 읽기 확장(read-scaling) 아키텍처로 쓰기요청보다 읽기요청이 많은 웹 상의 공통 패턴에서 부하 분산의 효과가 있다.
- 비동기식 복제에만 동작. 명백히 불일치가 발생하지만 이 경우 지연이 발생.
- 발생 사례 1 : 자신이 쓴 내용 읽기
  - 쓰기 요청이 발생했지만 복제서버에 아직 반영이 안된 상황
  - 해결방안
    - 사용자가 수정한 내용을 읽을땐 리더에서 읽는다.
    - 리더에서의 모든 읽기는 갱신 이후 얼마동안 금지
    - 클라이언트에서 타임스탬프를 활용하여 지연되었는지 체크 (이러한 멘타데이터는 중앙집중식으로 관리 필요)
    - 데이터센터 분산시 리더가 포함된 데이터센터로 라우팅 (네트워크가 달라 라우팅 보장이 어려움)
- 발생 사례 2 : 단조 읽기
  - 팔로워간의 복제 지연으로 시간이 거꾸로 흐르는 현상 발생
  - 사용자의 요청의 라우팅을 한곳으로만 처리
- 발생 사례 3 : 일관된 순서로 읽기
  - 파티셔닝(샤딩)된 데이터베이스에서 발생하는 특징
  - 인과성이 있는 쓰기와 읽기를 하나의 파티션으로 라우팅 (효율적이진 않다.)
- 복제 지연을 위한 해결책
  - 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는것이 문제 해결 방안
  - 트랜잭션 : 어플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법
  - 트랜잭션이 성능과 가용성 측면에서 너무 비싸고 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장(추후 자세하게 다룸)

### 다중 리더 복제
- 다중 리더 : 쓰기를 허용하는 노드를 하나 이상 둠. 각 리더는 동시에 다른 리더의 팔로워 역할을 수행
- 다중 리더 복제의 사용 사례
  - 다중 데이터센터 운영
    - 데이터센터간의 지연은 발생할 수 있지만 사용자에게는 숨겨져 사용자가 인지하는 성능은 더 좋아질 수 있음
    - 데이터센터의 중단에 따른 내성을 보장
    - 내부 네트워크의 안정성 확보로 네트워크 중단에도 쓰기 처리는 진행 가능
    - 동일한 데이터를 다른 두개의 데이터 센터에 동시 변경시 쓰기 충돌은 반드시 해소 필요
  - 오프라인 작업을 하는 클라이언트
    - 쓰기요청이 중단되는 오프라인 작업시 복구 되었을때 각 리더간의 동기화 처리
    - 각 디바이스가 다중 리더가 되는 형태
  - 협업 편집
    - 여러사람이 다중 리더가 되는 형태
    - 동시에 편집을 가능하게 하지만 다중 리더 복제에서 발생하는 모든 문제를 야기
- 쓰기 충돌 다루기
  - 동기 대 비동기 충돌 감지
    - 두 쓰기는 모두 성공하지만 충돌은 비동기로만 감지해서 너무 늦은 충돌해소 발생
    - 동기식으로 쓰기가 성공한 사실을 사용자에게 말하기 전에 모든 복제 서버가 쓰기를 복제하기를 기다리는 방식, 각 복제서버가 독립적으로 쓰기를 허용하는 다중 리더 복제의 주요 장점을 잃음
  - 충돌 회피
    - 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록
    - 위 기준을 지속하지 못하는 상황이 발생하는 경우 결국 충돌회피 실패. 다른 리더에서 동시 기록 가능성 대처 필요
  - 일관된 상태 수렴
    - 각 리더마다 다른 최종 값을 갖는건 용인되지 않음
    - 수렴 충돌 해소
      - 각 쓰기에 고유 ID를 부여, 가장 높은 ID가 승자
      - 각 복제서버에 고유 ID를 부여
      - 어떻게든 병합 (e.g. 데이터 사전순 정렬)
      - 충돌을 기록, 추후 충돌을 해소하는 애플리케이 코드를 작성
  - 사용자 정의 충돌 해소 로직
    - 쓰기 수행중일때 충돌 감지시 바로 충돌 해소
    - 읽기 수행중일때 충돌 감지시 모든 충돌 쓰기를 저장하여 어플리케이션에 반환 > 해소
- 다중 리더 복제 토폴리지
  - 원형/별/전체연결
  - 무한 복제 루프를 방지하기 위해 각 노드에는 고유 식별자가 있고 복제로그에서 각 쓰기는 거치는 모든 노드의 식별자가 태깅된다.
  - 원형/별 토폴리지는 단일장애점 문제가 발생. 전체 연결 토폴리지의 내결함성이 훨씬 더 좋다.
  - 전체연결 토폴리지는 복제 메시지가 다른 메시지를 추월하는 문제, 이벤트를 정렬하기 위해 "버전 벡터"라는 기법을 사용
  - 다중 리거복제 시스템에서는 이런 문제를 인지하고 철저하게 테스트가 필요

### 리더 없는 복제
- 노드가 다운됐을 때 데이터베이스에 쓰기
  - 노드가 다운되고 다시 온라인 상태가 되었을때 오래된 값을 얻는 경우를 방지하기 위해 클라이언트는 읽기 요청을 병렬로 여러 노드에 전송한다.
  - 읽기 복구 : 읽었을때 버전이 다른 경우 해당 복제 서버에 새로운 값을 다시 기록
  - 안티 엔트로피 처리 : 백그라운드 프로세스로 누락 데이터를 찾아 처리
- 읽기와 쓰기를 위한 정족수
  - n : 복제서버 개수
  - w : 성공한 노드의 수
  - r : 읽기 요청을 호출하는 최소한의 노드 수
  - w + r > n 일 경우 최신값을 얻을것으로 기대
  - 다만 내결함성이 없음
- 리더없는 복제의 시스템일 경우 최신성 모니터링이 더욱 중요
- 동시 쓰기 감지 + 최종 쓰기 승리(동시 쓰기 버리기)
- 동시에 발생했는가 에 대한 기준 : 의존성이 있는가 (각 작업간의 인과성)
- 버전벡터 : 모든 복제본의 버전 번호 모음, 동시작업 처리

### 정리
- 고가용성, 연결이 끊긴 작업 처리, 지연시간 감소, 확장성 을 위해 복제를 사용
- 복제시 문제
  - 단일 리더 복제
  - 다중 리더 복제
  - 리더 없는 복제
- 복제지연으로 발생하는 문제
  - 쓰기 후 읽기 일관성
  - 단조 읽기
  - 일관된 순서로 읽기  