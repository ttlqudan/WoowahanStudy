# Part 2. 분산 데이터

## 분산된 DB를 요구하는 이유

1. 확장성 : R/W 부하가 커지면 여러 장비로 분산 가능

2. 내결함성/고가용성 : 장비 하나가 죽어도 다른 장비에서 작업 지속 가능

3. 지연시간 : 글로벌하게 유저가 있다면, 유저와 가장 가까운 지역에 서버에서 응답 가능

## 고부하로 확장

- 고부하 확장이 필요하면 더 강력한 스펙의 장비 구매해서 대응 (수직 확장 또는 용량 확장)

- 공유 메모리 아키텍처 : 많은 CPU, RAM, DISK를 하나의 운영체제에서 운영 가능
  - 문제점
    - 비용이 Linear하게 증가함.
    - 병목 현상으로 스펙을 2배 늘린다고, 2배의 부하를 처리할 수 있는 것이 보장되지 않음.
- 비공유 아키텍처 (수평 확장 또는 규모 확장) -> **2부의 초점**
  - DB 소프트웨어를 실행하는 각 장비 또는 가상 장비를 노드라 부름.
  - CPU, RAM, DISK를 독립적으로 사용.
- 여러 노드에 데이터를 분산하는 방법
  - 복제: 같은 데이터의 복제를 여러 노드에 유지
  - 파티셔닝: 큰 DB를 작은 서브셋 데이터로 쪼개서 각 파티션을 여러 노드에 배치 (샤딩이라고도 함)

# Chapter 5. 복제

- 복제를 수행함으로써 데이터를 사용자와 가깝게 유지해 Latency를 낮춤.
- 서버에 장애가 있어도, 작업 지속 가능 (가용성 높임)
- 읽기 질의 처리하는 장비의 수를 늘려 읽기 처리량 향상

- 복제의 어려움 : 데이터에 변경이 있을 때, 어떻게 처리해 줄 것인가?
  - 단일 리더 (Single-Leader)
  - 다중 리더 (Multi-Leader)
  - 리더 없음 (Leaderless)

## 5.1 리더와 팔로워

- DB 복사본을 저장하는 각 노드를 복제 (replica) 라고 함
- DB의 모든 쓰기는 복제 서버에서 처리되어야함.

  - 리더 기반 복제 (능/수동, 마스터-슬레이브 복제)
  - 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그 또는 변경 스트림의 일부로 팔로워 (슬레이브, 읽기 복제서버, 2차, 핫 대기)에게 전송.

- 클라이언트가 읽기 요청을 하면 마스터 또는 슬레이브가 처리 가능하지만, 쓰기는 마스터만 가능

- DB 뿐만 아니라 인메모리 DB, 분산 메모리 브로커 등에도 적용가능함 (카프카, RabbitMQ, Redis)

## 5.2 동기식 vs 비동기식 복제

- 동기식 : 작업 하나가 끝날 때까지 나머지 작업은 대기.

  - 장점은 팔로워와 리더가 일관되게 최신 데이터 복사본을 갖고 있게 하는 것을 보장.
  - 단점은 작업이 마무리 되었다는 응답이 있기 전까지 나머지 작업들은 대기해야함.
  - 현실적으로 동기식 복제는 팔로워 하나는 동기식으로, 나머지는 비동기식으로 처리해야함. (반동기식)

- 비동기식 : 보통 리더 기반 복제는 비동기식.
  - 장점은 모든 팔로워가 잘못 되더라도 리더는 쓰기 지속 가능.
  - 내구성을 약화시키는 것 같지만, 데이터센터가 분산되어 있으면 비동기식 복제 널리 사용.

## 5.3 새로운 팔로워 설정

- 새로운 팔로워가 리더 데이터 복제본을 정확히 갖고 있는지 보장하는 방법

  - DB Lock이 아닌 스냅샷 사용 -> 최신 스토리지 서버들은 기본 제공 (ZFS)
  - 스냅샷은 팔로워 노드에 복사
  - 스냅샷 이후 발생한 데이터에 대해 변경 요청
  - 복제 노드에서 스냅샷 이후 변경 사항 반영했다 응답하면 -> 마스터 노드 신규 데이터 처리
  - 최신으로 출시되는 고가용성 데이터 서버는 거의 대부분 ZFS 파일 시스템 차용하면서 스냅샷 기본 제공
  - 최신 Workflow Pipeline에서 실행되는 스케줄러들도 스케줄링 서버가 죽으면 죽은 시점에서부터 실행되어야하는 스케줄 작업 전부 실행함. ([Flyte Scheduler CatchupAll-system](https://docs.flyte.org/en/latest/concepts/component_architecture/native_scheduler_architecture.html#catchupall-system))

## 5.4 리더의 장애 복구 (Failover)

1. 리더가 장애인지 판단함.

2. 새로운 리더 선택.

- Redis-Sentinel을 사용하면 Quorum 구조

- 참고: [redis-sentinel](http://redisgate.jp/redis/sentinel/sentinel.php)

3. 새로운 리더 사용을 위해 시스템 재설정

- 시스템에서 이전 리더가 팔로워가 되고, 새로운 리더 인식할 수 있게 변경함.

4. 장애 복구 과정은 잘못될 수 있는 것 투성이임.

- 리더 선출되기 전에 쓰기 요청이 들어오면? 가장 간단한 방법은 해당 쓰기 요청을 drop -> 하지만 내구성 원칙을 버리는 일이됌.

- 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정되는 상황에 특히 위험함.

- 특정 결함 상황에서 두 개 이상의 노드가 자신이 리더라고 믿는 상황은 무척 위험 (스플릿 브레인, Split Brain)

  - 쓰기 요청을 받으면 충돌이 발생할 확률이 무척 높은데, 충돌 해소를 안하면 데이터 유실 또는 오염 발생.

- 리더가 죽었다고 판단되는 적절한 타임아웃은? 시스템마다 다를듯.
  - 너무 길면 복구까지 시간이 길어짐 (데이터 유실 확률도 높음)
  - 너무 짧으면 불필요한 장애 복구 발생 (마스터 퇴출 / 새 리더 선출이 빈번해질 수도 있다?)

## 5.5 리더 기반 복제

- 리더 기반 복제의 내부

### 5.5.1 구문 기반 복제

- 모든 쓰기 요청을 (구문, statement) 기록하고 쓰기 실행 이후 다음 구문 로그를 팔로워에게 전송.
