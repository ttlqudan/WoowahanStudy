# Chapter 6. 파티셔닝

- 데이터셋이 매우 크거나 질의 처리량이 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있는데, 이를 샤딩이라함.

- 데이터 파티셔닝을 수행하는 가장 큰 이유는 확장성. DB가 여러 파티션을 동시에 건드리는 연산 작업 수행도 가능하지만, 각 파티션은 작은 DB 그 자체임.

## 6.1 파티셔닝과 복제

- 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장함.

- 각 레코드가 정확하게 한 파티션에 속한다 하더라도 여러 노드에 분산되어 동일한 레코드가 저장 되어 있으므로 내결함성이 보장된다는 의미임.

## 6.2 키-값 데이터 파티셔닝

- 파티셔닝이 고르게 안되어서 다른 파티션보다 데이터가 많거나 쿼리를 많이 받는 파티션이 있으면 쏠렸다(Skewed)라고 함.

- 불균형하게 부하가 높은 파티션을 핫스팟이라고함.

- 핫스팟을 회피하는 가장 좋은 방법은 레코드를 할당할 노드를 무작위로 선택하는 것.

  - 문제는 어느 노드에 저장되었는지 모르므로 모든 노드에 쿼리를 보내야함.

- 더 좋은 해결책으로 키-값 데이터 모델을 사용하면 항상 기본키로 레코드를 찾을 수 있음.

### 6.2.1 키-값 범위 기준 파티셔닝

- 파티셔닝 방법 중 하나는 백과사전처럼 연속된 범위 (최소 ~ 최대 값 지정)의 키를 할당하는 것.

- 이 때 키 범위의 크기는 반드시 동일할 필요가 없음.

- 각 파티션 내에서는 키를 정렬된 값으로 저장 가능함.

  - 이렇게 함으로써 범위 스캔이 쉬워지고, 키를 연속된 색인(index)으로 간주해 쿼리 하나로 레코드를 여러개 읽어올 수 있음.

  - 하지만 특정 접근 패턴이 핫스팟을 유발하는 단점 존재.

## 6.3 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟 이슈 등으로 많은 분산 데이터스토어는 키의 파티션을 정할 때 해시 함수 이용함.

- 좋은 해시 함수는 쏠린 데이터를 입력 받아 균일하게 분산해줌.

- 단점은 키의 해시값을 사용해서 파티셔닝하면 키 범위 파티셔닝의 좋은 속성을 잃어버림.

  - 범위 질의를 효율적으로 하는 능력을 못 사용.

### 6.3.1 쏠린 작업 부하와 핫스팟 완화

- **6.3 키의 해시값 기준 파티셔닝**은 핫스팟을 줄이는데 도움을 주지만 핫스팟을 완벽하게 제거할 수는 없음.
- 현대 데이터 시스템은 대부분 크게 쏠린 부하를 자동으로 보정 못하므로 애플리케이션 레벨에서 쏠림 완화해야함.

## 6.4 파티셔닝과 보조 색인

- 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단임.

- 많은 키-값 저장소는 복잡도 증가를 우려해 보조 색인을 지원 안하지만, 데이터 모델링에 유용함.

### 6.4.1 문서 기준 보조 색인

- 데이터베이스에 문서 추가, 삭제, 갱신 등의 작업을 실행할 때 쓰려고하는 문서 ID를 포함하는 파티션만 다루면 되는데, 이는 지역 색인 (Local Index)라고도 함.

- 문서 기준으로 파티셔닝 된 색인을 읽을 때 주의 사항이 있는데, 찾고자하는 값을 모두 얻기 위해서는 모든 파티션에 쿼리를 보내셔 결과를 수합해야함.

  - 쿼리를 보내는 파티션 뿐만 아니라 여러 파티션에 걸쳐 원하는 결과가 존재할 수 있음.

  - 이러한 방식을 스캐터/개더(Scatter/Gather)라고도 하는데, 보조 색인을 사용하는 쿼리는 비용이 많이 들수 있음.

- 파티션에서 질의를 병렬로 수행할 수 있더라도 스캐더/개더는 꼬리 지연 시간 증폭이 될 확률이 높음.
  - 꼬리 지연 증폭(tail latency amplification) : 병렬로 파티션에 쿼리를 보냈을 때, 하나의 쿼리에서 지연 시간이 길어져도 전체 속도가 함께 느려짐.

### 6.4.2 용어 기준 보조 색인 파티셔닝

- 모든 파티션의 데이터를 담당하는 전역 색인 구성 가능.

- 찾는 용어에 따라 색인의 파티션이 결정됨. 이런 식의 색인을 용어 기준으로 파티셔닝 되었다고함 (Term-Partitioned)

- 용어 자체를 사용하거나 용어의 해시값 사용 가능.

- 용어 자체를 쓰면 범위 스캔에 좋고, 해시값을 쓰면 부하를 고르게 분산 시킬 수 있음.

- 전역 색인 장점은 스캐터/게더 필요 없이 원하는 용어가 포함되어 있는 파티션으로만 요청 보내면 됨.

- 하지만 느리고 복잡함.

- 이상적인 상황은 색인이 늘 최신 상태이고, DB에 기록된 모든 문서는 바로 색인이 되어야함.

- 현실에선 전역 보조 색인은 비동기로 갱신됨

## 6.5 파티션 재균형화

- 시간이 지나면서 생기는 DB의 변화

  - 더 높은 부하 처리를 위해 CPU를 더 추가하거나
  - 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶거나
  - 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비에 넘기거나

- 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 작업을 재균형화라고함.

  - 재균형화 후, 클러스터 내 노드들 사이에 부하가 균등하게 배분되어야함.
  - 재균형화 중에도 노드는 데이터 읽기/쓰기 처리해야함.
  - 재균형화를 빠르게 수행하기 위해 네트워크와 I/O 부하를 최소화하고 노드 사이에 데이터가 필요 이상으로 옮겨지면 안됌.

### 6.5.1 재균형화 전략

#### 6.5.1.1 쓰면 안되는 방법: 해시 값에 모드(mod) N 연산을 수행

- 모드 N 방식은 노드 개수 N이 바뀌면 대부분의 키가 노드 사이에 옮겨져야하는데, 이는 키가 자주 이동하면 재균형화 비용이 증가할 수 밖에 없음.

##### 해결책 1: 파티션 개수 고정

- 파티션 개수를 노드 개수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 방식.

  - 쉽게 말해 Over Provisioning?

- 각 파티션에는 전체 데이터의 고정된 비율이 포함되므로 개별 파티션 크기는 클러스터의 전체 데이터 크기에 비례해서 증가함.

- 파티션이 너무 크면 재균형화 실행할 때 노드 장애로부터 복구 비용이 크게 올라감.

- 파티션이 너무 작으면 오버헤드가 커짐.

##### 해결책 2: 동적 파티셔닝

- 파티션 크기가 일정 수준을 넘어서면 파티션을 둘로 쪼개 원래 파티션의 절반 정도의 데이터가 포함되게 한다.

- 반대로 데이터가 많이 삭제되어 임계치 이하로 되면 인접한 파티션을 합친다.

- 동적 파티셔닝의 초점은 데이터 용량 맞춰 조정된다는 점.

- 그러나 DB에 데이터가 적거나 없으면 파티션은 1개로 시작함.

##### 해결책 3: 노드 비례 파티셔닝

- 앞선 두 사례는 노드 대수와는 독립적으로 적용됨.

- 노드 대수를 늘리거나 줄이면 파티션도 이에 비례해서 늘거나 줄어듦.

  - 개별 파티션 크기가 일정하게 유지됌.

##### 해결책 4: 자동 재균형화와 수동 재균형화

- 완전 자동 재균형화 : 시스템이 자동으로 파티셔닝을 재균형화하므로 운영하는 부서 내지 사람 입장에선 관리 포인트가 줄어듦.

- 완전 수동 재균형화 : 완전 자동 재균형화에서 응답 지연 또는 일시 네트워크 중단 등으로 파티셔닝이 재분배되면 안되므로, 적절한 선에서 사람에 의한 재균형화가 필요할 수도 있음.

## 6.6 요청 라우팅

- 클라이언트에서 요청 보낼 때, 어떤 노드로 접속해야하는지 알 수 있을까?

- 파티셔닝이 재균형화 되면, 접근하는 노드가 바뀌는 상황 발생함.

- DB에 국한되지 않는 더욱 일반적인 문제인 서비스 찾기 (Service Discovery)에 해당함.

  - 쿠버네티스에서는 일반적으로 Operator라는 것을 구성하는 것이 가능함.
    - 예시: [Shell Operator](https://github.com/flant/shell-operator)
  - 책에서는 IP를 찾는다고 하지만, 일반적으로 특정 파티셔닝이 할당되는 노드에 Log를 구성해서, 해당 Log가 발생되는 노드를 추적해 DNS를 업데이트하는 게 더 좋아보이기는 함.

### 6.6.1 병렬 질의 실행

- 대규모 병렬 처리 (Massively Parallel Processing, MPP) RDBMS 제품은 훨씬 더 복잡한 쿼리 지원함.

- 전형적인 DW는 조인, 필터링, 그룹화, 집계 연산을 포함함.
