# 파트2. 데이터 시스템의 기초

# 6장. 파티셔닝
- 파티션을 나누는 여러 방법
- 데이터 색인과 파티셔닝이 어떻게 상호작용하는지?
- 재균형화
- DB가 어떻게 요청을 파티션에 전달하고 질의를 실행하는지?

## 파티셔닝과 복제
- 보통 복제와 파티셔닝을 함께 적용한다
- 이를 통해 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다

## 키-값 데이터 파티셔닝
- 파티셔닝의 목적
  - 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것
- 파티셔닝이 고르게 이뤄지지 않아 특정 파티션에 데이터가 많거나, 질의를 많이 받으면 쏠렸다(skewed)라고 한다
- 쏠림이 있으면 파티셔닝의 효과가 매우 떨어진다
- 불균형하게 부하가 높은 파티션을 **핫스팟**이라 한다
- 핫스팟을 회피하는 가장 단순한 방법을 레코드를 할당할 노드를 무작위로 선택하는 것이다
- 이때 단점을 레코드를 읽을 때 어떤 노드에 저장되있는지 알 수 없으므로 모든 노드에 질의를 실행해야 한다는 것이다
- 키-값 데이터 모델을 사용하면 이 문제를 방지하고 언제나 원하는 항목을 빠르게 찾을 수 있다

## 키 범위 기준 파티셔닝
- 각 파티션에 연속된 범위의 키를 할당하는 방법
- 각 범위 경계 또는 노드가 어떤 파티션에 있는지 알면 적절한 노드로 요청을 보낼 수 있다
- 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다
- 범위 질의 시 유용하다
- 특정 접근 패턴이 핫스팟을 유발하는 단점이 있다
  - 타임스탬프가 키인 경우 등

## 키의 해시값 기준 파티셔닝
- 쏠림과 핫스팟의 위험때문에 많은 분산 데이터스토어는 키의 파티션을 정하는데 해시 함수를 사용한다
- 좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다
- 장점
  - 키를 파티션 사이에 균일하게 분산시키는데 좋다
- 단점
  - 범위 질의에 불리하다
  - 키들이 모든 파티셔넹 흩여져서 정렬 순서가 유지되지 않기 때문
- 카산드라는 범위, 해시 두가지 파티셔닝 전략 사이에서 타협했다!
  - 테이블 선언 시 여러 칼럼을 포함하는 복합 기본키를 지정할 수 있음
  - 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고
  - 남은 칼럼은 데이터를 정렬하는 연쇄된 색인으로 사용한다
  - 이렇게 하면 복합 키의 첫 칼럼에 대해선 범위 질의를 쓸수없지만 다른 칼럼에 대해선 범위 질의를 효율적으로 실행할 수 있다
  - 활용 사례
    - 수정한 문서의 기본키를 id와 timestamp로 선택해 특정 사용자가 어떤 시간 구간에서 수정한 모든 문서를 정렬해서 읽어옴

## 쏠린 작업부하와 핫스팟 완화
- 키를 해싱해서 파티션을 정하면 핫스팟을 줄일 수는 있지만 완벽히 제거할 수는 없다
- 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다
  - SNS에서 수백만 팔로워를 거느린 유명인
- 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다
- 예시
  - 각 키의 시작이나 끝에 임의의 숫자를 붙여 키를 분산시킴
  - 이렇게 하면 읽기 시 추가 작업이 필요해져 요청이 몰리는 소수의 키에만 적용하는게 적합하다

# 파티셔닝과 보조 색인
- 보조 색인이 연관되면 키-값 데이터 모델만으로는 처리가 어렵다
- 문서 기반 파티셔닝과 용어 기반 파티셔닝이 널리 쓰인다

## 문서 기준 보조 색인 파티셔닝
-  데이터가 추가되면 DB 파티션을 자동으로 보조 색인 항목에 해당 문서 ID를 추가한다
- 이 방법을 사용하면 각 파티션이 완전히 독립적으로 동작한다
- 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다
- 다른 파티션에 어떤 데이터가 저장되는지는 신경 쓰지 않고 DB 작업 시 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다
- 이러한 이유로 지역 색인(local index)라고도 한다
- 주의점
  - 문서 ID에 별도 작업을 하지 않는다면 같은 보조 색인 조건의 데이터가 동일한 파티션에 저장되리라는 보장이 없다 
  - 모든 파티션으로 질의를 보내 확인해야 한다
  - 이를 스캐터/개더(scatter/gather)라 한다
    - 꼬리 지연 시간 증폭이 발생하기 쉬움
- 대부분 보조 색인 질의가 단일 파티션에서만 실행되도록 파티셔닝을 설계하기 권장하지만 항상 가능하지는 않다

## 용어 기준 보조 색인 파티셔닝
- 각 파티션이 자신만의 지역 색인을 갖게 하는 대신, 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수도 있따
- 그러나 한 노드에만 색인을 저장하면 해당 노드가 병목이 될 수 있기에 이는 옳지않다
- 용어 자체로 파티셔닝
  - 범위 스캔에 유용
- 용어 해시값으로 파티셔닝
  - 부하가 좀 더 고르게 분산됨
- 문서 파티셔닝 색인 대비 장점은 읽기가 효율적인 것
  - 클라이언트는 모든 파티션에 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다
- 단점은 쓰기가 느리고 복잡하다는 것
  - 단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 때문
- 현실에서는 대개 비동기로 갱신된다

# 파티션 재균형화
- 시간이 지나면 DB에 변화가 생기고, 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다
- 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)이라고 한다
- 재균형화 요구사항
  - 균등한 부하 분배
  - 중단없는 읽기/쓰기 요청
  - 빠른 실행, 네트워크, 디스크 I/O 부하 최소화

## 재균형화 전략 - 쓰면 안 되는 방법: 해시값에 모드 N 연산을 실행
- 노드 개수 N이 바뀌면 대부분의 키가 옮겨져야 하기 때문에 쓰면 안된다
- 재균형화 비용이 지나치게 커진다

## 재균형화 전략 - 파티션 개수 고정
- 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 방법
- 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때 까지 기존 노드에서 파티션 몇 개를 뺏어올 수 있다
- 파티션은 노드 사이에서 통째로 이동만 한다
- 처음 설정된 파티션 개수가 사용 가능한 노드 대수의 최대치가 되므로 충분히 높은 값을 선택해야 한다
- 전체 데이터셋 크기 변동이 심하다면 적절한 파티션 개수를 정하기 어렵다
- 파티션이 너무 크면 재균형화 실행할 때와 노드 장애 복구 시 비용이 크다
- 그러나 너무 작으면 오버헤드가 너무 커진다

## 재균형화 전략 - 동적 파티셔닝
- 파티션 크기가 설정된 값을 넘어서면 파티션을 쪼갠다
- 파티션 개수가 전체 데이터 용량에 맞춰 조정된다는 장점이 있다
- 데이터 양이 적으면 파티션 개수가 적어도 되므로 오버헤드도 작다
- 그러나 빈 DB는 파티션 경계를 어떻게 정해야할지 모르므로 시작할 때는 파티션이 하나라는 단점이 있다
- 데이터셋이 작을 때는 모든 쓰기 요청이 하나의 노드에서만 실행된다
- HBase와 MongoDB에서는 빈 DB에 초기 파티션 집할을 설정할 수 있게해 이 문제를 완화했다

## 재균형화 전략 - 노드 비례 파티셔닝
- 파티션 개수가 노드 대수에 비례하게 하는 방법
- 개별 파티션 크기가 상당히 안정적으로 유지된다
- 새 노드가 클러스터에 추가되면 고정된 개수의 파티션을 무작위로 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 다른 절반은 새 노드에 할당한다
- 파티션을 무작위로 선택해서 균등하지 않은 분할이 생길 수 있지만, 평균적으로 보면 새 노드는 균등한 몫을 할당받게 된다

## 운영: 자동 재균형화와 수동 재균형화
- 완전 자동 재균형화는 유지보수가 편리하지만 예측하기 어렵다
- 주의 깊게 처리하지 않으면 네트워크나 노드에 과부하가 걸릴 수 있고 진행중에는 다른 요청 성능이 저하될 수 있다
- 운영 상 예상치 못한 일을 방지하려면 사람이 적당히 개입하는 것도 좋은 방안이다

# 요청 라우팅
- 클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?
- 접근법들
  - 아무 노드에 접속하게한다
  - 요청을 라우팅 계층으로 보내 라우팅 계층에서 요청을 처리할 노드를 알아내고 전달한다
  - 클라이언트가 직접 어떤 노드로 접속해야하는지 알고 있게 한다
- 핵심 문제는 구성요소가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐다
- 이 문제는 모든 곳에서 정보가 일치해야 하므로 다루기 어렵다
- 분산 시스템에서 합의 프로토콜이 있지만 제대로 구현하기 까다롭다
- 많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 주키퍼와 같은 별도 코디네이션 서비스를 사용한다
- 주키퍼 동작
  - 각 노드는 주키퍼에 자신을 등록하고 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다
  - 라우팅 계층이나 파티션 인지 클라이언트 같은 다른 구성요소들은 주키퍼에 있는 정보를 구독할 수 있다
  - 파티션 소유자가 바뀌든지, 노드가 추가/삭제되면 주키퍼는 라우팅 계층에 이를 알려 라우팅 정보를 최신으로 유지한다
- 예시
  - 링크드인의 에스프레소
    - 헬릭스를 써서 클러스터를 관리하고, 라우팅 계층을 구현함
  - 몽고DB의 몽고스(mongos) 데몬
    - 자체적인 설정 서버 구현에 의존하고 몽고스 데몬을 라우팅 계층으로 사용함
  - 카산드라와 리악의 가십 프로토콜(gossip protocol)
    - 클러스터 상태 변화를 노드 사이에 퍼트림
    - 아무 노드나 요청을 받을 수 있고 요청을 받은 노드는 요청을 처리할 파티션을 갖고 있는 올바른 노드로 요청을 전달해준다
    - 데이터베이스 노드에 복잡성을 더하지만 주키퍼 같은 외부 코디네이션 서비스에 의존하지 않는다
- 클라이언트는 라우팅 계층을 사용하거나 접속할 IP 주소를 알아내야 한다
