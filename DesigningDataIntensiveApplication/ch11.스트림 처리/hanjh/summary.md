## **이벤트 스트림 전송**

데이터베이스도 생산자와 소비자를 연결하는 역할을 할 수 있다.  db를 계속 해서 polling 하거나 관계형 디비에서 지원하는 트리거를 사용 할 수 있지만 효율성도 떨어지고 용도에 맞지않는다. 이보다는 이벤트 알림 전달 목적으로 개발된 특별한 도구들이 있다.

### 메시징 시스템

메시징 시스템에서는 TCP, UDP 같은 네트워크 프로토콜을 기반으로 확장한 방식으로 메시지를 전송함. 

**생산자에서 소비자로 메시지를 직접 전달하기**

- 메시지 생산자가 직접 소비자에게 메시지를 전달하는 구조
- udp 멀티캐스트, ZeroMQ, 소비자가 네트워크에 서비스를 노출하는 경우 HTTP 나 RPC 요청으로 사용 가능.
- 메시지 유실 가능성을 고려하여 애플리케이션 코드를 작성해야함.
- 메시지를 잃어버릴 가능성도 있음.

**메시지 브로커**

- 직접 메시징 시스템의 대안.
- 메시지 스트림을 처리하는 데 최적화된 데이터베이스의 일종.
- 클라이언트의 상태 변경(접속, 접속 해제, 장애)에 쉽개 대처 가능

**메시지 브로커와 데이터베이스의 비교**

- 데이터베이스는 명시적으로 데이터가 삭제될 때까지 데이터보관. 메시지 브로커 대부분은 소비자에게 데이터 배달이 성공할 경우 자동으로 메시지 삭제
- 메시지 브로커는 작업 집합(큐) 이 작다
- DB는 보조 색인을 지원하고 데이터 검색을 위한 다양한 방법을 지원하는 반면 메시지 브로커는 특정 패턴과 부합하는 토픽의부분 집합을구독하는 방식을 지원.
- 디비는 질의 할 때 질의 시점의 데이터 스냅숏을 기준으로함. 메시지 브로커는 데이터가 변하면 클라이언트에 알려준다.
- 메시지 브로커와 데이터베이스는 모두 데이터 관리 및 전송의 역할을 하지만, 그 방식과 목적에 차이가 있다.
    - 메시지 브로커는 실시간 메시지 전송에 초점을 맞추며, 데이터베이스는 데이터의 저장과 조회에 중점을 두고 있음.

**복수 소비자**

- 복수 소비자가 같은 토픽에서 메시지를 읽을 때 사용할 수있는 두가지 패턴이 있다.
    - 로드 밸런싱 - 각 메시지는 소비자 중 하나로 전달됨
    - 팬아웃 - 각 메시지는 모든 소비자에게 전달됨
- 두 가지 를 혼합해서 사용할 수도 있음.

**확인 응답과 재전송**

- 소비자는 언제든지 장애가 발생 할 수 있기 때문에 메시지를 잃어버리지 않기 위해 메시지가 성공적으로 전달되었는지 확인하는 메커니즘이 필요함.
- 브로커가 확인 응답을받기 전에 클라이언트로의 연결이 닫히거나 타임아웃 되면 브로커는 메시지가 처리되지 않았다고 가정하고 다른 소비자에 다시 전송함.
- 이런 경우 메시지가 발생한 순서와 처리되는 순서가 달라질 수 있음.
    - 메시지 간 인과성이 있다면 중요한 문제. 후반부에서 다룬다.

### 파티셔닝된 로그

일반적으로 메시징 시스템에 새로운 소비자를 추가하면 추가한 시점 이후에 전송된 메시지부터 받기 시작한다. 이전 메시지는 다시 복구할 수 없다.

하지만 **로그 기반 메시지 브로커(log-based message broker)** 를 사용 하면 이전에 발생한 이벤트도 다시 읽을 수 있다. (물론 한계는있음)

**로그를 사용한 메시지 저장소**

- 로그는 단순히 디스크에 저장된 추가 전용 레코드의 연속이고, 브로커를 구현할 때도 이와 같은구조를 사용한다.
- 처리량을 높이기 위해 로그를 파티셔닝 할 수 있다.
- 파티션별 오프셋이라고 부르는 단조증가하는 순번을 부여할 수 있고 순서 보장한다.(파티션간에 순서를 보장하진 않음.)
- 아파치 카프카, 아마존 키네시스 스트림

**로그 방식과 전통적인 메시징 방식의 비교**

- 로그 기반 접근법은 팬아웃 메시징 방식 제공, 각 클라이언트는 할당된 파티션의 메시지를 모두 소비
- 처리량이 많고 메시지를 처리하는 속도가 빠르지만 메시지 순서가 중요하다면 로그 기반 접근법이 효과적
- 반면 메시지를 처리하는 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 그렇게 중요하지 않다면 JMS/AMQP 방식의 메시지 브로커가 적합.

**소비자 오프셋**

- 파티션 하나를 순서대로 처리하면 메시지를 어디까지 처리했는 지 알기 쉽다.
- 소비자의 현재 오프셋 보다 작은 오프셋을 가진 메시지는 이미 처리한 메시지고 반대는 아직 처리 하지 않은 메시지.
- 주기적으로 소비자 오프셋을 기록하면 브로커는 확인 응답을 추적할 필요가 없다.
    - 이렇게 되면 오버헤드가 감소하고 처리량을 늘리는데 도움을 준다.

**디스크 공간 사용**

- 로그를 계속 추가한다면 결국 디스크 공간을 전부 사용하게됨.
- 로그는 크기가 제한된 버퍼로 구현하고 버퍼가 가득 차면 오래된 메시지 순서대로 버린다.
- 소비자 처리 속도가느리다면 소비자 오프셋이 이미 삭제된 조각을 가리킬 수도 있다. → 메시지 일부를 잃어버릴 가능성이 있다.

**소비자가 생산자를 따라갈 수 없을 때**

- 소비자가 메시지를 전송하는 생산자를 따라갈 수 없을 때 선택할 수 있는 세 가지. 메시지 버리기, 버퍼링, 배압 적용하기
- 로그 기반 접근법은 고정 크기의 버퍼를 사용하는 버퍼링의 형태
- 소비자가 느린 경우 메시지를 유실 할 수 있으니 모니터링 해서 메시지를 잃기 전에 조치를 해야함.

**오래된 메시지 재생**

- 로그 기반 메시지 브로커에서 메시지를 소비하는 것은 단순히 로그를 읽기만 하고 변화시키지는 않는 읽기 전용 연산
- 소비자의 오프셋 조작을 이용해 지나간 메시지를 재처리 할 수 있음.

## 데이터베이스와 스트림

로그 기반 브로커는 데이터베이스에서 아이디어를 얻어 메시징에 적용하였고, 그 반대도 가능함. 

데이터베이스의 복제 로그는 데이터베이스 기록 이벤트의 스트림이다.

### 시스템 동기화 유지하기

대부분 중요 애플리케이션은 요구사항을 만족하기 위해 몇 가지 다른 기술을 조합하여 사용하고 있음. 각 기술별 목적에 맞게 데이터를 최적화한 형태로 각각 저장하고 있어야함. 이 경우 데이터 동기화가 중요하다.

동기화를 위해 주기적으로 데이터베이스 전체를 덤프 할 수도 있고, 이게 너무 느리다면 이중 기록을 사용한다. 하지만 이 방법은 동시성 감지 메커니즘이 없다면 동시 쓰기 문제를 알아차리지 못한다. 또한 내결함성 이슈(한쪽 쓰기는 성공, 다른쪽 쓰기는 실패)가 있다.

동기화를 어떻게 할 수 있을까?

### 변경 데이터 캡처

최근 들어 변경 데이터 캡처에 관심이 높아지고 있다. 

데이터베이스에 기록하는 모든 데이터의 변화를 관찰해 다른 시스템으로 데이터를 복제할 수 있는 형태로 추출하는 과정. 

데이터가 기록 되자마자 변경 내용을 스트림으로 제공할 수 있다면 특히 유용함.

**변경 데이터 캡처의 구현**

- 트리거사용
    - 모든 변화를 관찰하는 트리거를 등록하고 변경 로그 테이블에 해당 항목을 추가.
    - 고장 나기쉽고성능 오버헤드가 상당함.
- 복제 로그 파싱
    - 스키마 변경 대응 등 해결해야 할 문제가 있음.
    - 트리거 방식보다 견고한 방법

**초기 스냅숏**

- 변경 로그를 사용해 데이터베이스전체 상태를재구축 할 수는 있지만 전체 로그 보관하는 것은 비용이 큼.
- 스냅숏을 사용 하고 변경 로그의 위치나 오프셋에 대응시켜 스냅숏 이후에 변경 사항을 적용할 시점을알 수 있도록 한다.
- 일부 CDC 도구는 이런 기능을 가지고있으나, 수작업으로 해야 하는 도구도 있다.

**로그 컴팩션**

- 로그 히스토리 양을제한한다면 새로운 파생 데이터 시스템을추가할 때마다 스냅숏을 만들어야 하는데, 이럴 때 로그 컴팩션이라는 대안이 있다.
- CDC 시스템에서 모든 변경에 기본키가 포함되게 하고 키의 모든 갱신이 해당 키의 이전 값을 교체한다면 특정 키에 대해 최신 쓰기만 유지하면 된다.
- 파생 데이터 시스템을 재구축 할 땐 새 소비자는 컴팩션 된 로그 토픽의 오프셋 0 부터 시작해서 순차적으로 데이터베이스의 모든 키를 스캔하면 된다. → 원본 디비 스냅숏을 만들지 않고도 데이터베이스 콘텐츠전체의 복사본을 얻을 수 있다.

**변경 스트림용 API 지원**

- 최근 들어 디비들은 점진적으로 변경 스트림을 기본 인터페이스로서 지원하기 시작.
    - 리싱크DB ******-****** 구독 가능한 질의
    - 파이어베이스, 카우치DB - 변경 피드 기반의 데이터 동기화
    - 미티어 - 몽고DB 의 oplog
    - 볼트DB - 스트림 형태로 데이터베이스에서데이터를 지속적으로 내보내는 트랜잭션
    - 카프카 커넥트 - 카프카를 광범위한 데이터 시스템용 변경 데이터 캡처 도구로 활용

### 이벤트 소싱

도메인 주도 설계 커뮤니티에서 개발한 기법인데, 스트리밍 시스템에 관련한 유용한 아이디어를 포함한다.

변경 데이터 캡처와 이벤트소싱은 추상화 레벨이 다르다는 차이점이 있음.

- 변경 데이터 캡처
    - 레코드를 자유롭게 갱신, 삭제 하고 변경 로그는 데이터베이스에서 저수준으로 추출. 애플리케이션은 CDC 가 실행중인지 알 필요가 없음.
- 이벤트 소싱
    - 이벤트는 추가만 가능하고 갱신이나 삭제는 권장하지 않거나 금지함. 애플리케이션 수준에서 발생한 일을 반영. 애플리케이션에서 동작한다.

**이벤트 로그에서 현재 상태 파악하기**

- 이벤트 로그는 수정 히스토리를 나타냄. 현재 상태를 알아내기 위해 이벤트를 하나씩 재실행 하여 현재 상태를 파악할 수 있다. - 결정적 과정 이어야함(재시도 했을 때 결과가 다르면 안된다.)
- CDC 와는 살짝 다른게, CDC 는 로그컴팩션이 가능하지만 이벤트 소싱은 불가능. 이벤트는 사용자 행동의 결과로 발생한 상태 갱신 메커니즘이 아닌 사용자 행동 의도를 표현하기 때문.

**명령과 이벤트**

- 이벤트 소싱에선 이벤트와 명령 구분을 잘해야함.
    - 사용자 요청이 처음 도착했을 때 이 요청은 명령. 경우에 따라(무결성 조건을 위반하는 경우) 실패 / 성공 가능
- 명령이 성공적으로 실행 되고 다음부터 이벤트가 전달됨
- 예를 들어 극장 좌석 예매 할 때
    - 애플리케이션은 좌석이 이미 예약 끝났는지 확인 → 명령
    - 확인 성공 하면 특정 고객이 특정 좌석을 예약한다는 이벤트 생성함. → 이벤트

### 상태와 스트림 그리고 불변성

**불변 이벤트의 장점**

- 데이터베이스에 불변성을 이용하는 아이디어는 생각보다 오래되었다.
- 금융 시스템이 특히 중요하고
- 불변성이 있다면 잘못된 상황(코드를 잘못 배포했다거나 하는) 에서 문제 상황의 진단과 복구가 쉽다.
- 단순히 현재 상태를 보는 것 보다 더 많은 정보를 준다.
    - 예를 들어 특정 행동을 하기 까지 사용자가 행했던 모든 액션을 볼 수 있음.

**동일한 이벤트 로그로 여러 가지 뷰 만들기**

- 불변 이벤트 로그에서 가변 상태를 분리하면 동일한 이벤트 로그로 다른 여러읽기 전용 뷰를 만들 수 있다.
- 신규 기능용으로 분리한 읽기 최적화된 뷰를 구축 해도 기존 시스템은 신경 쓸 필요 없음. 기존 시스템과 함께 운용 가능.
- 데이터를 쓰는 형식과 읽는 형식을 분리해 다양한 읽기 뷰를 허용하면 상당한 유연성을 얻을 수 있고, 이러한 개념을 CQRS(Command Query Responsibility Segregation) 라 부름.

**동시성 제어**

- 이벤트 로그의 소비가 대개 비동기로 이루어진다는 점이 이벤트 소싱 & 변경 데이터 캡처의 가장 큰 단점.
    - 164쪽의 자신이 쓴 내용 읽기에 문제점과 해결책을 다뤘다.
- 해결책은?
    - 읽기 뷰의 갱신과 로그에 이벤트를 추가하는 작업을 동기식으로 수행.
        - 이를 위해선 이벤트 로그와 읽기 뷰를 같은 저장 시스템에 담아야 하고, 다른 시스템에 있다면 분산 트랜잭션이 필요하다.
    - 이벤트 로그로 현재 상태를만들면 동시성 제어측면이 단순해짐.
        - 이벤트 소싱을 사용하면 사용자 동작에 대한 설명을 자체적으로 포함하는 이벤트를 설계 할 수 있고, 그러면 사용자 동작은 한 장소에서 한 번만 쓰기가 필요함. → 이벤트를 로그에 추가만 하면 원자적으로 만들기 쉽다.
    - 이벤트 로그와 애플리케이션 상태를 같은 방식으로 파티셔닝 하면 간단한 단일스레드 로그 소비자는 쓰기용 동시성 제어는 필요하지 않다. 파티션 내에서 이벤트의 직렬 순서를 정의하면 로그에서 동시성의 비결정성을 제거할 수 있다.

**불변성의 한계**

- 영구적으로 모든 변화의 불변 히스토리를 유지하는 것이 가능할까?
    - 데이터가 변경되는 정도에 따라 다르지만, 견고한 운영을 하는 데 큰 골칫거리가 됨.
    - 성능 이슈
- 관리상 이유로 데이터를 삭제할 필요가 있을 때(개인정보 보호 등의이유로)
    - 데이터를 진짜로 삭제하는 작업은 굉장히 어렵다.
    - 삭제는 해당 데이터를 찾기 불가능하게끔 하기 보다는 찾기 어렵게 하는 것.

## 스트림 처리

스트림을 처리 하는 방법은 크게 3가지가 있다.

1. 이벤트에서 데이터를 꺼내 데이터베이스나 캐시, 검색 색인 또는 유사한 저장소 시스템에 기록하고 다른 클라이언트가 이 시스템에 해당 데이터를 질의
2. 이벤트를 사용자에게 직접 보낸다. 이메일 경고나 푸시 알림의 형태
3. 하나 이상의 입력 스트림을 처리해 하나 이상의 출력 시스템을 생산한다.

일괄 처리 작업과 가장 크게 다른 점은 스트림은 끝나지 않는다는 점.

### 스트림 처리의 사용

스트림 처리는 모니터링 목적으로 오랜 기간 사용돼 왔다. 최근에는 모니터링 외에도 다른 목적으로 사용하는 사용자들이 나타났음.

**복잡한 이벤트 처리(Complex Event Processing, CEP)**

- 정규표현식이 문자 패턴을 찾는 방식과 유사하게 스트림에서 특정 이벤트 패턴을 찾는 규칙을 규정해 이벤트 분석
- 일반적인 질의와 데이터의 관계와 반대로 질의는 오랜 기간 저장되고 입력 스트림으로 부터 들어오는 이벤트는 지속적으로 질의를 지나 흘러가면서 이벤트 패턴에 매칭되는 질의를 찾는다.

**스트림 분석**

- CEP와의 경계가 불분명 하긴 하지만 일반적으로 분석은 연속한 특정 이벤트 패턴을 찾는 것보다 대량의 이벤트를 집계하고 통계적 지표를 뽑는 것을 더 우선한다. 예를 들어
    - 특정 유형의 이벤트 빈도 측정(시간당 얼마나 자주 발생?)
    - 특정 기간에 걸친 값의 이동 평균 계산
    - 이전 시간 간격과 현재 통계값의 비교
- 81쪽 성능 최적화 에서 나왔던 확률적 알고리즘을 사용하기도 한다. 블룸 필터, 하이퍼로그로그, 백분위 추정 알고리즘
- 데이터를 누락하거나 부정확하다고 생각하기 보다는 일종의 최적화 기법이라고 생각해야함.
- 예를 들어 스파크 스트리밍

**구체화 뷰 유지하기**

- 데이터베이스 변경에 대한 스트림은  캐시,검색, 색인, 데이터 웨어하우스 같은 파생 데이터 시스템이 원본 데이터베이스의 최신 내용을 따라잡게 하는 데 쓸 수 있다.
    - 캐시,검색, 색인, 데이터 웨어하우스 → 구체화 뷰의 사례

**스트림 상에서 검색하기**

- 전문 검색 질의와 같은 복잡한 기준을 기반으로 개별 이벤트를 검색해야 하는 경우가 있다.
    - 부동산 웹사이트 → 부동산 시장에 사용자가 설정한 검색 기준과 매칭되는 새 부동산이 나오면 알려달라고 요청 가능.
    - 엘라스틱서치의 여과(percolator) 기능
- 전통적인 검색 엔진의 처리 순서와 달리 스트림 검색은 질의를 먼저 저장한다. 그리고 CEP와 같이 문서는 질의를 지나가면서 실행 된다.

### 시간에 관한 추론

분석 목적으로 스트림 처리를 사용 할 때 시간을 다루게 된다. “지난 5분” 의 의미는 정확히 어떤것일까? 의미를 정확히 파악하는게 중요한가?

**이벤트 시간 대 처리 시간**

- 메시지가 지연되면 메시지 순서를 예측하지 못할 수도 있다.
    - 스타워즈 에피소드 IV(4) : 1977
    - 에피소드 V(5) : 1980
    - 에피소드 I, II, III : 1999, 2002, 2005
- 이벤트 시간과 처리 시간을 혼동하면 좋지 않은 데이터가 만들어진다.

**준비 여부 인식**

- 이벤트 시간 기준으로 윈도우를 정의할 때 특정 윈도우에서 모든 이벤트가 도착 했다거나 아직도 이벤트가 계속 들어오고 있는지를 확신할 수 없다는 점이 까다롭다.
- 윈도우를 이미 종료한 후에 도착한 낭공자 이벤트를 처리할 방법은?
    - 낙오자 이벤트 무시
    - 수정 값을 발행

**어쨌든 어떤 시계를 사용할 것인가?**

- 이벤트를 발생 시키는 앱 의 로컬 시계를 따르는 것이 발생 시점을 정확하게 나타낼 수 있으나 고의 또는 우연히 시간이 잘못 설정 됐을 가능성이 있다.
- 서버 시간만 따르기에는 이벤트가 지연에 의해 순서가 뒤바뀌어 도착할 수 있다.
- 이를 위해 세 가지 타임스탬프를 로그로 남긴다.
    - 이벤트가 발생한 시간 → 장치 시계
    - 이벤트를 서버로 보낸 시간 → 장치 시계
    - 서버에서 이벤트를 받은 시간 → 서버 시계
    
    두 번째와 세 번째의 타임스탬프 차이를 구해 장치 시계와 서버 시계 간의 오프셋을 추정
    

**윈도우 유형**

이벤트 타임스탬프를 결정 한 다음엔 윈도우기간을 어떻게 정의할지 결정해야 한다.

아래는 일반적으로 사용하는 윈도우 유형의 몇가지 이다.

- 텀블링 윈도우
    - 윈도우크기 고정, 모든 이벤트는 정확히 한 윈도우에 속함.
- 홉핑 윈도우
    - 고정 길이 사용, 윈도우 중첩 가능
        - 윈도우 1 : 10시 03분 00초 ~ 10시 07분 59초
        - 윈도우 2 : 10시 04분 00초 ~ 10시 08분 59초
- 슬라이딩 윈도우
    - 각 시간 간격 사이에서발생한 모든 이벤트 포함.
    - 시간 기준으로 정렬한 이벤트를 버퍼에 유지하고 오래된 이벤트가 만료되면 윈도우에서 제거하는 방식
        - 홉핑 윈도우를 더 세분화?
- 세션 윈도우
    - 고정된 기간 없음.
    - 같은 사용자가 짧은 시간 동안 발생시킨 모든 이벤트를 그룹화해서 세션 윈도우를 정의.
    - 일정 시간이 지나 사용자가 비활성화 되면 윈도우 종료

### 스트림 조인

조인의 유형을 스트림 스트림 조인, 스트림 테이블 조인, 테이블 테이블 조인 세 가지로 구분한다.

**스트림 스트림 조인(윈도우 조인)**

- 스트림 처리자가 상태를 유지해야 한다.
    - 예를들어 지난 시간에 발생한 모든 이벤트를 세션 ID 로 색인
    - 검색 이벤트나 클릭 이벤트가 발생할 때마다 해당색인에 추가하고 스트림 처리자는 같은 세션 ID로 이미 도착한 다른 이벤트가 있는지 다른 색인 확인
    - 이벤트가 매칭 되면 검색한 결과를 클릭 했다고 말해주는 이벤트 방출
    - 검색 이벤트가 클릭 이벤트 매칭 없이 만료되면 검색 결과가 클릭되지 않았다고 말해주는 이벤트 방출
- **스트림 테이블 조인(스트림 강화)**
    - 데이터베이스의 정보로 활동 이벤트를 **강화**
        - 입력 : 사용자 ID를 포함한 활동 이벤트 스트림
        - 출력 : 해당 ID를 가진 사용자 프로필 정보가 추가된 활동 이벤트
    - 일괄 처리 작업은 입력으로 데이터베이스의특정 시점 스냅숏을 사용하지만 스트림 처리는 오랜 기간 수행하기 때문에 데이터베이스의 로컬 복사본을 최신 상태로 유지해야 한다. → 변경 데이터 캡처 사용하면 해결 가능함.
    - 스트림 조인과 매우 비슷하나 테이블 변경 로그 스트림 쪽은 “시작 시간” 까지 이어지는윈도우를 사용하며 레코드의 새 버전으로 오래된 것을 덮어씀.
- **테이블 테이블 조인(구체화 뷰 유지)**
    - 두테이블을 조인하는 질의에 대한 구체화 뷰 유지
- **조인의 시간 의존성**
    - 위 세가지 방식은 공통점이 많다.
        - 스트림 처리자가 하나의 조인 입력을 기반으로 한특정 상태(검색과 클릭 이벤트, 사용자 프로필, 팔로워 목록)를 유지해야 하고 다른 조인 입력에서 온 메시지에 그 상태를 질의한다.
    - 상태를 유지하는 이벤트의순서는 매우 중요함.
    - 복수 개의 스트림에 걸친 이벤트 순서가 결정되지 않으면 조인도 비결정적이다.
    - 이러한 문제를 천천히변하는차원(slowly changing dimension, SCD) 이라 함.
        - 조인되는 레코드의 특정 버전을 가리키는 데 유일한 식별자를 사용해 해결함.

### 내결함성

스트림 처리에서 발생하는 내결함성 문제를 해결할 수 있는 해결책에 대해 알아본다.

- **마이크로일괄 처리와 체크포인트**
    - 스트림을 작은블럭으로 나누고 각블럭을 소형 일괄 처리와 같이 다루는 방법
        - 스파크 스트리밍에서 사용
    - 1초 정도 성능상 타협
    - 일괄 처리크기와 같은 텀블링 윈도우를 암묵적으로 지원함.
    - 마이크로 일괄 처리 지원 프레임워크 내에선 정확히 한번 시멘틱을 지원하지만 외부 부분에선 부수 효과가 두번 발생함
- **원자적 커밋 재검토**
    - 처리가 성공했을 때만 모든 출력과 이벤트처리의 부수효과가 발생하도록 한다.
        - 357쪽 분산트랜잭션과 2단계 커밋을 부분에서 다룬 개념
    - 스트림 처리 프레임워크 내에서 상태 변화와 메시지를 관리해 트랜잭션을 내부적으로 유지
- **멱등성**
    - 처리한 효과가 두 번 나타나는 일 없이 안전하게 재처리하기 위해 실패한 태스크의 부분 출력을 버리는 것이 목표. 분산트랜잭션 이외에 **멱등성**에 의존하는 방법이 있음.
    - 멱등성을 위한 몇가지 가정
        - 실패한 태스크를 재시작 할때는 반드시 같은 순서로 같은 메시지를 재생해야 한다.
        - 처리는 결정적이어야 하며 어떤 노드도 동시에 같은값을 갱신하지 않아야함.
        - 장애 복구가 일어날 때 실제로 살아있는 노드의간섭을 방지하기 위해 펜싱이 필요함.
    - 오버헤드가 적은 효율적인 방법.
- **실패 후에 상태 재구축하기**
    - 상태가 필요한 스트림(윈도우집계, 조인용 테이블, 색인) 처리는 실패 후에도 해당 상태가 복구됨을 보장해야함.
    - 한 가지 방법은 원격 데이터저장소에 상태를 유지하고 복제하는 것.
    - 다른 방법은 스트림 처리자의 로컬에 상태를유지하고 주기적으로 복제하는 것.
    - 상당히작은 크기의 윈도우를 집계해 만든상태라면 그냥 해당윈도우에 해당하는 입력 이벤트를 재생해도 충분히 빠르다.
    - 인프라스트럭처의 성능 특성에 따라 다름.
