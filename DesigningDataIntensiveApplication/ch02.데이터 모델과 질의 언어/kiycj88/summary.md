# 파트1. 데이터 시스템의 기초

# chapter 2. 데이터 모델과 질의 언어
데이터 중심 애플리케이션에서는 적합한 데이터 모델을 선택하는 것이 가장 중요한 작업중에 하나이다.
여러 데이터 모델을 알아보고 이를 이용하는 질의 언어에 대해 살펴보자

## 관계형 모델과 문서 모델
관계형 모델이 등장한 이래로 오랜시간 계속 사용되고 있다. 네트워크 모델, 계층 모델 등 여러 대안을이 제시되었지만 결국 관계형 모델을 대체하지 못하였다.
아시다시피, 요즘도 많이 사용되고 있다.

### NoSQL의 탄생
2010년대에 관계형 모델의 아성을 넘보는 NoSQL이라는 데이터 모델이 등장!!
- 대규모 데이터셋, 매우 높은 쓰기 처리량을 위한 Scale-out의 용이성
- 상용제품보다 오픈소스 소프트웨어에 대한 선호도 확산
- RDBMS에서 제공하지 않는 특수 Query
- 관계형 스키메의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

Polyglot persistence: RDBMS와 NoSQL이 같이 사용됨

### 객체 관계형 불일치
객체지향 언어에서 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 전환 계층이 필요하다. 이런 모델 사이의 분리를 "임피던스 불일치" 라고 한다.

ex) 이력서
- RBMS에서는 여러 테이블을 이용하여 표현한다. Document 모델에서는 하나의 JSON과 같은 포맷으로 저장이 가능하다.
- Read시
    - RDBMS: 여러 테이블을 JOIN 해야하는 번거로움
    - JSON: findById만 하면된다.

### 다대일과 다대다 관계
RDBMS에서는 보통 ID값을 통해서 데이터의 관계를 정의한다. 그래서 그 데이터를 갱신하고 싶으면 값만 변경하면 된다. ex) companyId: 50, companyName: "Tweeter"

데이터 갱신시에 Document 모델에서의 두가지 방법
- ID를 참조: Application Level에서 Join 구현이 필요
- Value를 참조: 모든 데이터 full scan해서 업데이트

이러한 문제 때문에, many-to-one 관계에서 Document모델은 적합하지 않다. Document모델에서 이를 해결하기 위해서는 Application Level에서 Join 구현해야 한다.
many-to-many에서도 당연히 똑같은 문제가 발생한다.

### 문서 데이터베이스는 역사를 반복하고 있나?
Document reference: RDBMS 외래키와 같이 다른 문서의 ID를 참조

### 관계형 데이터베이스와 오늘날의 문서 데이터베이스
RBMS와 NoSQL을 비교할 때, 내결함성, 동시성 처리 등 고려해야 할 점이 많지만 여기서는 데이터 모델의 차이점에만 집중한다.

문서 데이터모델을 주로 선호하는 이유는
- 스키마 유연성
- 지역성에 기인한 더 나은 성능

#### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 한다고 말 할 수 없다.

문서 데이터모델 한번에 전체 데이터를 다 넣을 때 좋다. many-to-many 관계가 있으면 애플리케이션 레벨에서 데이터 일관성을 위한 추가 작업이 필요하고,
Join은 애플리케이션 레벨에서 구현이 필요하고, 데이터베이스 내 특화된 코드에 비해 보통 성능이 안 좋다.

상호 연결이 많은 데이터의 경우
- 문서 모델: 나쁨
- 관계형 모델: 보통
- 그래프 모델: 좋음

#### 문서 모델에서의 스키마 유연성
Schemaless라 불리지만, 데이터베이스에서 강제하지 않을 뿐이지, 애플리케이션에서는 관리해야 한다.

- Schema-on-write: 스키마는 명시적으로 데이터베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다.
- Schema-on-read: 데이터 구조는 암묵적으로 데이터를 읽을 때만 해석된다.
#### 질의를 위한 데이터 지역성
문서는 보통 JSON, XML 형태릐 String 혹은 JSON, XML의 binary encoded 포맷으로 저장된다.
애플리케이션이 전체 문서에 자주 접근해야 할때, 저장소 지역성(storage locality)을 활용하면 성능 이점이 있다.

지역성에 대해서는 3장에서 자세히 다룰 예정


#### 문서 데이터베이스와 관계형 데이터베이스의 통합
서로를 보완하기 위해 혼합모델들이 등장하고 있다.

RDBMS에서도 문서모델의 일부를 지원하고 있다. ex) Mysql JSON Column


## 데이터를 위한 질의 언어
- 명령형: 코드로 질의
- 선언형: SQL로 질의
    - 질의 내부적으로 수행되는 상세구현은 숨겨져 있기 때문에, 질의를 변경하지 않고, 상세 구현을 변경함으로써 성능 향상을 꾀할수 있다.
    - 선언형이 종종 병렬 실행에 적합

### 웹에서의 선언형 질의
js로 코드 작성하는것보다 선언형으로 CSS 스타일을 사용하는 편이 좋다!

### 맵리듀스 질의
맵리듀스는 대량의 데이터를 처리하기 위한 프로그래밍 모델이다. map, reduce 함수를 기반으로 동작.
- map: data를 하나하나 paramter로 받아서 <key, value>로 emit
- reduce: map에서 emit한 <key, [value1, value2, value3, ...]> 을 parameter로 받아서 aggregation 처리

MongoDB에서는 map, reduce 함수가 pure 함수여야 한다. pure함수란 직접 입력된 데이터만 사용하는 함수


## 그래프형 데이터 모델
다대다 관계가 일반적으로 일어나는 경우에 적합. 그래프 데이터구조를 생각하면 된다.
정점(vertex)와 간선(edge)로 이루어져 있다.

ex) 소셜 그래프
- 정점(vertex): 사람
- 간선(edge): 사람사이의 관계

### 속성 그래프
Vertex의 구성요소
- 고유한 식별자
- set of outgoing edge
- set of incoming edige
- 속성 컬렉션 <key, value>

Edge의 구성요소
- 고유한 식별자
- edge가 시작하는 vertex (tail vertex)
- edge가 끝나는 vertex (head vertex)
- 관계 유형을 설명하는 label
- 속성 컬렉션 <key, value>

정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 제한하는 스키마는 없다.
정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을수 있고 그래프를 순회할 수 있다. 즉 일련의 정점을 따라 앞뒤 방향으로 순회한다.
다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

### 사이퍼 질의 언어
사이퍼(Cypher)는 속성 그래프를 위한 선언형 질의 언어 Neo4j Graph DB용으로 만들어졌다.
- Vertex와 Edge를 Create문으로 정의
- MATCH RETURN을 통해 질의가 가능
    - [WITHIN*0..]와 같은 형태로 recursive하게 질의가 가능

### SQL의 그래프 질의
WITH RECURSIVE 이용해서 구현이 가능하지만, 상당히 복잡하고 어렵다.

### 트리플 저장소와 스파클
- 주어(subject), 서술어(predicate), 목적어(object) 처럼 세 부분 구문 형식으로 저장. ex) ('Jamie', 'like', 'Apple')
- 주어는 정점과 동등하고, 목적어는 두가지중 하나
    - 데이터의 primitive type의 속성
        - ex) (Lucy, age, 33) => (Lucy {'age': 33})
    - 그래프의 다른 정점. 이 경우는 서술어는 edge, subject는 tail vertex, object는 head vertex
        - ex) (Lucy, marry, Jamie), Lucy와 Jamie는 Vertex, marry는 edge


- 자원 기술 프레임워크(Resource Description Framework, RDF): 서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법
- 스카플(SPARQL): RDF 데이터 모델을 사용한 트리플 저장소 질의 언어

### 초석: 데이터 로그
트리플 저장소 모델과 유사하지만 조금 더 일반화됐다.
서술어(주어, 목적어)
