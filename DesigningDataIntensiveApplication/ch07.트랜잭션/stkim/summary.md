# Chapter 7. 트랜잭션

## 1. 들어가기 전에...

- 냉혹한 현실세계에서 발생할 수 있는 문제들

  - DB SW/HW는 언제나 실패할 수 있다.
  - 애플리케이션은 언제든 뻗을 수 있다.
  - 네트워크 장애로 DB<->애플리케이션, DB<->노드 사이에 통신이 안될 수 있다.
  - 여러 클라이언트가 동시에 쓰기 연산을 해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
  - 클라이언트가 부분적으로만 갱신되서 비정상적 읽기가 진행될 수 있다.
  - 클라이언트 사이의 경쟁 조건은 예상치 못한 버그를 야기할 수 있다.

- 따라서, 잘못될 수 있는 모든 경우에 대해 테스트하고 해결책이 실제로 동작하는지 확인 필요함.

- 트랜잭션의 정의 : 애플리케이션에서 몇 개의 읽기/쓰기를 하나의 논리적 단위로 묶는 방법
  - 개념적으로 한 트랜잭션의 몇 개의 읽기/쓰기를 한 연산으로 실행됨.
  - 트랜잭션은 DB에 접속하는 **애플리케이션에서 프로그래밍 모델을 단순화**하려는 목적에서 시작됨
  - 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도 잠재적 오류 시나리오나 동시성 문제를 무시할 수 있음.
    - DB에서 관련 일을 대신해주기 때문 -> 안전성 보장 (safety guarantee)
- 다루게 될 내용
  - 커밋 후 읽기 (read committed)
  - 스냅 숏 격리 (snapshot isolation)
  - 직렬성 (serializability)

## 2. 애매모호한 트랜잭션 개념

- 현대에 오면서 분산 DB 확산 등의 이슈로 트랜잭션 개념 모호해짐.

### 2.1 ACID의 의미

- 원자성 (Atomicity), 일관성 (Consistency), 격리성 (Isolation), 지속성 (Durability)

- 현실에서 ACID 구현이 제각각이고, 시스템이 ACID를 준수한다고 하는 것이 정말 준수하는지 알 수 없어, 오늘날 의미 모호함.

- 원자성

  - "원자적" 이라는 의미는 더 이상 쪼갤 수 없는 것.
  - 컴퓨터 공학에선 의미가 미묘하게 다름.
    - 예를 들어, 다중 스레드 작업에서 한 스레드의 처리 중인 작업의 중간을 다른 스레드가 관찰하는 것이 불가능함.
  - 또한 동시성과는 전혀 관계 없음.
  - 단, 클라이언트가 여러 개의 쓰기 작업을 하는데 그 중 일부에 결함이 생기면 무슨 일이 발생했는지 설명하려고함.
  - 원자성이 없으면 여러 변경을 적용 중에 어떤 문제가 발생했는지 해명하기가 무척 어려움.
    - 애플리케이션에서 재시작하면 되지만, 동일 쓰기가 2번 실행되면서 잘못된 데이터가 만들어지기 쉬움.

- 일관성

  - 복합적인 의미가 얽혀 사용됨

    - 복제 일관성과 비동기적으로 복제되는 시스템에서 사용되는 최종적 일관성에 대해 설명
    - 일관성 해싱
    - CAP에서 일관성이라는 단어의 의미는 선형성을 의미함.
    - ACID의 맥랙에서 일관성의 의미는 데이터 베이스가 좋은 상태에 있어야한다는 것.

  - 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션 책임임.

  - ACID에서 C를 제외한 속성은 모두 DB의 속성이고, 일관성은 애플리케이션의 속성임.

- 격리성

  - 동시에 실행되는 트랜잭션은 서로 격리됨.
    - 트랜잭션이 다른 트랜잭션을 방해할 수 없음.
  - DB에선 실제로 여러 트랜잭션이 동일 레코드에 동시에 실행됐더라도 트랜잭션 커밋의 결과는 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

- 지속성

  - 트랜잭션이 성공적으로 커밋되면 하드웨어 결함이 발생하거나 DB가 죽더라도 모든 데이터는 손실되지 않는 것을 보장함.
  - 단일 노드 DB에서 지속성은 일반적으로 비휘발성 디스크에 기록되었다는 뜻임.
  - 과거에는 지속성이 아카이브 테이프에 기록하는 것이었고, 그 후에는 디스크 또는 SSD, 그리고 현재는 복제를 의미하게 되었음.

## 3. 단일 객체 연선과 다중 객체 연산

- ACID의 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러번의 쓰기를 하면 DB가 어떻게 해야하는지 서술

  - 원자성 : 쓰기를 이어서 실행 중 오류 발생시 Abort 수행. 그 때까지 작성 중인 내용은 모두 폐기해서 아무것도 반영되지 않는 것을 보장해야함. (부분 실패 걱정X)
  - 격리성 : 동시 실행되는 트랜잭선은 서로 방해 X.

- 이러한 정의는 다중 객체 트랜잭셔넹서 데이터의 여러 조각이 동기화된 상태로 유지돼어야 할 때 필요.

### 3.1 단일 객체 쓰기

- 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로함.

- 여러 클라이언트에서 동시에 같은 객체에 스기를 할 때 갱신 손실 (lost update)를 방지하므로 유용.

### 3.2 다중 객체 트랜잭션의 필요성

- 많은 분산 데이터 스토어는 다중 객체 트랜잭션 지원을 포기.

  - 여러 파티션에 걸쳐 구현이 어렵고, 높은 가용성 & 성능 필요한 곳에는 방해 되는 시나리오 존재.

- 많은 경우 키-값 데이터 모델과 단일 객체 연산만으로 충분한 사례가 있지만 여러개의 다른 객체에 실행되는 쓰기 작업은 코디네이션이 되어야함.

### 3.3 오류와 어보트 처리

- 트랜잭션 핵심 기능은 오류 생기면 Abort, 그 후 안전하게 재시도.

- ACID 원칙을 구현한 DB에서 원자성, 격리성, 또는 지속성 보장을 위반할 위험이 있으면 트랜잭션은 절반 정도 완료된 상태에 머무르기보다 완전히 폐기.

- 하지만 모든 시스템이 이 철학을 따르지는 않음. 오류 복구는 애플리케이션의 몫.

### 3.4 완화된 격리 수준
