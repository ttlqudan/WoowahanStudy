# Chapter 7. 트랜잭션

## 1. 들어가기 전에...

- 냉혹한 현실세계에서 발생할 수 있는 문제들

  - DB SW/HW는 언제나 실패할 수 있다.
  - 애플리케이션은 언제든 뻗을 수 있다.
  - 네트워크 장애로 DB<->애플리케이션, DB<->노드 사이에 통신이 안될 수 있다.
  - 여러 클라이언트가 동시에 쓰기 연산을 해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
  - 클라이언트가 부분적으로만 갱신되서 비정상적 읽기가 진행될 수 있다.
  - 클라이언트 사이의 경쟁 조건은 예상치 못한 버그를 야기할 수 있다.

- 따라서, 잘못될 수 있는 모든 경우에 대해 테스트하고 해결책이 실제로 동작하는지 확인 필요함.

- 트랜잭션의 정의 : 애플리케이션에서 몇 개의 읽기/쓰기를 하나의 논리적 단위로 묶는 방법
  - 개념적으로 한 트랜잭션의 몇 개의 읽기/쓰기를 한 연산으로 실행됨.
  - 트랜잭션은 DB에 접속하는 **애플리케이션에서 프로그래밍 모델을 단순화**하려는 목적에서 시작됨
  - 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도 잠재적 오류 시나리오나 동시성 문제를 무시할 수 있음.
    - DB에서 관련 일을 대신해주기 때문 -> 안전성 보장 (safety guarantee)
- 다루게 될 내용
  - 커밋 후 읽기 (read committed)
  - 스냅 숏 격리 (snapshot isolation)
  - 직렬성 (serializability)

## 2. 애매모호한 트랜잭션 개념

- 현대에 오면서 분산 DB 확산 등의 이슈로 트랜잭션 개념 모호해짐.

### 2.1 ACID의 의미

- 원자성 (Atomicity), 일관성 (Consistency), 격리성 (Isolation), 지속성 (Durability)

- 현실에서 ACID 구현이 제각각이고, 시스템이 ACID를 준수한다고 하는 것이 정말 준수하는지 알 수 없어, 오늘날 의미 모호함.

- 원자성

  - "원자적" 이라는 의미는 더 이상 쪼갤 수 없는 것.
  - 컴퓨터 공학에선 의미가 미묘하게 다름.
    - 예를 들어, 다중 스레드 작업에서 한 스레드의 처리 중인 작업의 중간을 다른 스레드가 관찰하는 것이 불가능함.
  - 또한 동시성과는 전혀 관계 없음.
  - 단, 클라이언트가 여러 개의 쓰기 작업을 하는데 그 중 일부에 결함이 생기면 무슨 일이 발생했는지 설명하려고함.
  - 원자성이 없으면 여러 변경을 적용 중에 어떤 문제가 발생했는지 해명하기가 무척 어려움.
    - 애플리케이션에서 재시작하면 되지만, 동일 쓰기가 2번 실행되면서 잘못된 데이터가 만들어지기 쉬움.

- 일관성

  - 복합적인 의미가 얽혀 사용됨

    - 복제 일관성과 비동기적으로 복제되는 시스템에서 사용되는 최종적 일관성에 대해 설명
    - 일관성 해싱
    - CAP에서 일관성이라는 단어의 의미는 선형성을 의미함.
    - ACID의 맥랙에서 일관성의 의미는 데이터 베이스가 좋은 상태에 있어야한다는 것.

  - 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션 책임임.

  - ACID에서 C를 제외한 속성은 모두 DB의 속성이고, 일관성은 애플리케이션의 속성임.

- 격리성

  - 동시에 실행되는 트랜잭션은 서로 격리됨.
    - 트랜잭션이 다른 트랜잭션을 방해할 수 없음.
  - DB에선 실제로 여러 트랜잭션이 동일 레코드에 동시에 실행됐더라도 트랜잭션 커밋의 결과는 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.

- 지속성

  - 트랜잭션이 성공적으로 커밋되면 하드웨어 결함이 발생하거나 DB가 죽더라도 모든 데이터는 손실되지 않는 것을 보장함.
  - 단일 노드 DB에서 지속성은 일반적으로 비휘발성 디스크에 기록되었다는 뜻임.
  - 과거에는 지속성이 아카이브 테이프에 기록하는 것이었고, 그 후에는 디스크 또는 SSD, 그리고 현재는 복제를 의미하게 되었음.

## 3. 단일 객체 연선과 다중 객체 연산

- ACID의 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러번의 쓰기를 하면 DB가 어떻게 해야하는지 서술

  - 원자성 : 쓰기를 이어서 실행 중 오류 발생시 Abort 수행. 그 때까지 작성 중인 내용은 모두 폐기해서 아무것도 반영되지 않는 것을 보장해야함. (부분 실패 걱정X)
  - 격리성 : 동시 실행되는 트랜잭선은 서로 방해 X.

- 이러한 정의는 다중 객체 트랜잭셔넹서 데이터의 여러 조각이 동기화된 상태로 유지돼어야 할 때 필요.

### 3.1 단일 객체 쓰기

- 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로함.

- 여러 클라이언트에서 동시에 같은 객체에 스기를 할 때 갱신 손실 (lost update)를 방지하므로 유용.

### 3.2 다중 객체 트랜잭션의 필요성

- 많은 분산 데이터 스토어는 다중 객체 트랜잭션 지원을 포기.

  - 여러 파티션에 걸쳐 구현이 어렵고, 높은 가용성 & 성능 필요한 곳에는 방해 되는 시나리오 존재.

- 많은 경우 키-값 데이터 모델과 단일 객체 연산만으로 충분한 사례가 있지만 여러개의 다른 객체에 실행되는 쓰기 작업은 코디네이션이 되어야함.

### 3.3 오류와 어보트 처리

- 트랜잭션 핵심 기능은 오류 생기면 Abort, 그 후 안전하게 재시도.

- ACID 원칙을 구현한 DB에서 원자성, 격리성, 또는 지속성 보장을 위반할 위험이 있으면 트랜잭션은 절반 정도 완료된 상태에 머무르기보다 완전히 폐기.

- 하지만 모든 시스템이 이 철학을 따르지는 않음. 오류 복구는 애플리케이션의 몫.

## 4 완화된 격리 수준

- 동시성 문제는 타이밍이 운이 없을 때 발생되기 때문에 테스트하기 무척 어려움.

  - 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 투랜적션이 동시에 같은 데이터를 변경하려고 할 때.

- DB에서는 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했음.

- 직렬성 격리는 DB가 여러 트랜잭션들이 직렬적으로 실행되는 것 (즉, 동시성 없이 한 번에 트랜잭션 하나만 실행)과 동일한 결과가 나오도록 보장하는 것을 의미

  - 현실은 격리가 쉽지 않음.

  - 어떤 동시성 이슈로부터는 보호헤주나 모든 이슈로부터 보호해주지 않는, 완전 격리 수준을 사용하는 시스템이 흔함.

### 4.1 커밋 후 읽기

- 가장 기본적인 수준의 트랜잭션 격리

- 아래 2가지를 보장해줌.

  - DB에서 읽을 때 커밋된 데이터만 보게 된다 (더티 읽기 X)
  - DB에서 쓸 대, 커밋된 데이터만 덮어쓰게 됨 (더티 쓰기 X)

### 4.2 더티 읽기 방지

- 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있는 상황을 더티 읽기라고함.

- 더티 읽기를 막는 게 유용한 이유

  - 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 발생하면 다른 트랜잭션이 일부는 갱신된 값을 읽고, 다른 일부는 갱신되지 않은 값을 보게 됨.

  - DB에 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 즉, 실제로 DB에 결코 커밋되지 않을 데이터를 볼 가능성이 존재함.

### 4.3 더티 쓰기 방지

- 먼저쓴 내용이 아직 커밋되지 않는 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어버리면 더티 쓰기라고함.

- 더티 쓰기를 막는 게 유용한 이유

  - 트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 더 나쁜 결과 유발.

### 4.4 커밋 후 읽기 구현

- 가장 흔한 방법으로는 DB 로우 수준 잠금을 사용해 더티 쓰기 방지.

- 트랜잭션에서 특정 객체(로우 또는 문서)를 변경하고 싶다면 먼저 해당 객체에 대한 잠금 획득 필요.

- 더티 읽기 막는 한 가지 방법은 트랜잭션이 잠시 잠금을 획득한 이후 일긱가 끝난 직후에 바로 해제하는 것.

  - 현실에서 잘 동작하지 않음.

  - 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭현 하나가 완료될 때가지 기다려야할 수 있기 때문.

  - 읽기만 실행하는 여러 트랜잭션들의 응답 시간에까지 영향 주기 대문에 운용성이 너무 나쁨.

  - 다른 애플리케이션들에 연쇄 효과

- 이런 이유로 쓰여진 모든 객체에 대해 DB는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다.

  - 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거 값을 읽게 됨.

### 4.5 스냅숏 격리와 반복 읽기

- 비반복 읽기 (nonrepeatable read) 또는 읽기 스큐 (Read Skew) : 트랜잭션이 끝난 시점에 데이터를 읽으면 이전 질의에서 봤던 것과는 다른 값을 목격하게 되는 현상.

- 어떤 상황에서는 이러한 비반복 읽기 또는 읽기 스큐가 허용되면 안되는 상황이 존재함.

  - 백업
  - 분석 질의와 무결성 확인

- 스냅숏 격리는 이런 상황에서 가장 흔한 해결책

  - 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.
  - 데이터가 나중에 트랜잭션으로 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.

### 4.6 스냅숏 격리 구현

- 핵심 개념은 읽는 쪽에서 쓰는 쪽을 차단하지 않고, 쓰는 쪽에서 읽는 쪽을 차단하지 않는 원리

- DB에서 여러 객체 버전을 함께 유지하므로 이 기법은 다중 버전 동시성 제어라고도함.

### 4.7 일관된 스냅숏을 보는 가시성 규칙

- 동작 방식

  - 각 트랜잭션 시작할 때 그 시점에 진행 중인 모든 트랜잭션 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 무시된다.

  - 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.

  - 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션 커밋 여부와 관계 없이 모두 무시된다.

  - 그 밖의 모든 데이터는 애플리케이션 질의로 볼 수 있다.

### 4.8 색인과 스냅숏 격리

- 카우치DB, 데이토믹, LMDB에서는 추가 전용이며 쓸 때 복사되는 (Append-Only/Copy-on-Write) 변종 사용

### 4.9 반복읽기와 혼란스러운 이름

- 오라클에서는 직렬성이라고하고, PSQL에서는 반복 읽기라고함.

- 이름이 여러개인 이유는 SQL 표준에 스냅숏 격리의 개념이 없기 때문.

- 표준이 정의되어 있지 않다보니, 결과적으로 반복 읽기의 뜻을 아는 사람은 아무도 없음.

### 4.10 갱신 손실 방지
