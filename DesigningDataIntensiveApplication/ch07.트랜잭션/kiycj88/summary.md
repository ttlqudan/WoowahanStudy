# chapter 7. 트랜잭션
- 트랜잭션: 애플리케이션에서 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법

## 애매모호한 트랜잭션의 개념
### ACID의 의미
- Atomicity(원자성): 여러 쓰기 작업이 같이 반영되는 것을 보장하는 것. (같이 commit, 같이 abort)
- Consistency(일관성): 데이터의 무결성 유지
  - 이 책에서는 데이터베이스의 속성이 아니라, 애플리케이션의 속성이다 라고 말하고 있음.
- Isolation(격리성): 트랜잭션들은 서로 격리, 트랜잭션이 동시에 실행되더라도 순차적으로 실행됐을 때의 결과와 동일하도록 보장
- Durability(지속성): 트랜잭션이 성공적으로 커밋됐다면, 데이터베이스가 죽더라도 모든 데이터는 손실되지 않는다는 것을 보장

### 단일 객체 연산과 다중 객체 연산

#### 단일 객체 쓰기
한 객체에서도 쓰기 도중 문제가 발생하면 부분적으로 갱신하는 것이 아니라 전체적으로 한 객체가 한번에 반영되어야 한다.
  - ex) 데이터베이스가 기존 값을 덮어쓰는 쓰기 도중 죽는 경우

단일 객체 쓰기만으로 충분한 경우도 있지만, 다중 객체 트랜잭션이 필요한 다양한 경우들이 있다.

#### 다중 객체 트랜잭션의 필요성
  - 관계 데이터모델에서의 외래키 참조
  - 문서 데이터모델에서 비정규화된 정보를 여러 문서에 갱신해야 하는 경우 
  - 색인 (트랜잭션 관점에서는 색인도 별도의 객체로 볼 수 있다.)
  
트랜잭션이 없더라도 구현은 가능하지만, 원자성이 없으면 오류 처리가 훨씬 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다.

#### 오류와 어보트 처리
트랜잭션의 핵심 기능은 오류가 생기면 어보트되고, 안전하게 재시도 할수 있는 것이다. 

하지만 모든 시스템이 이 철학을 따르지는 않는다.

어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류처리 매커니즘이지만 완벽하지는 않다.

## 완화된 격리 수준(Isolation Level)
직렬성(Serializable) 격리는 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장한다. 다만 성능 비용이 크기 때문에 보통 완화된 격리 수준을 사용한다.

### 격리후 읽기 (Read Committed)
- Dirty Read: 다른 트랜잭션에서 commit되지 않은 데이터가 보이는 것
- Dirty Write: 트랜잭션에서 commit되지 않은 데이터를 다른 트랜잭션에서 덮어쓰는 것 

Read Commmitted는 다음을 보장한다
- Dirty Read 방지
- Dirty Write 방지 

#### Read Committed 구현 방법
- Dirty Write 방지: Row Level Lock을 걸어서 트랜잭션이 commit or abort하기 전까지 다른 트랜잭션에서의 쓰기를 방지
- Dirty Read 방지: 과거에 커밋된 값과 현재 Write lock을 갖고 있는 트랜잭션에서 Write한 새로운 값을 모두 기억하고, 해당 트랜잭션이 실행 중인 동안에는 과거의 값을 읽게 한다.
  - Dirty Read 방지도 똑같이 Row Level Lock을 걸어서 구현 할수 있지만, 성능적인 문제가 있음.
    - 읽기 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될때까지 기다려야 할수 있다.
    - lock으로 인한 latency가 다른 부분에 연쇄효과를 미칠수 있다.


### 스냅숏 격리와 반복 읽기 (Repeatable Read)
- NonRepeatable Read: Multi Read Transaction 실행 중에 Multi Write Transaction에서 데이터를 update and commit한 경우, Write Transaction이 시작되기 이전에 실행된 Read의 값이 옛날의 값을 가지고 있는 문제
  - 다시 Read하면 해결되지만, 이런 일시적인 비일관성을 감내할수 없는 경우가 있을 수 있다.
    - 백업: 일부는 이전 데이터, 일부는 최신 데이터 가지고 있으면 비일관성이 영속적이게 된다.
    - 분석 질의: 맞지 않는 결과를 만들수 있다.

Read Committed 에서는 NonReapeatable Read 문제를 방지할수 없다.

스냅숏 격리를 통해서 NonRepeatable Read 문제를 해결할 수 있다.

스냅숏 격리: 트랜잭션 단위로 반영된 일관된 스냅숏으로터 Read하는 것.

#### 스냅숏 격리 구현
- Write는 Read Committed와 동일하게 Row level lock 이용
- reader never blocks writer, writer never blocks reader.
- 객체마다 커밋된 여러 버전을 함께 유지 (다중 버전 동시성 제어, multi-version concurrency control, MVCC)
  - created_by: 각 row마다 그 row를 insert한 txId
  - deleted_by: update시 기존 데이터를 지우지 않고, deleted_by에 row를 update한 txId를 저장, 처음엔 nil
  - 삭제된 데이터에 접근이 필요한 데이터가 없어지면 garbage collection 프로세스가 삭제

##### 일관된 스냅숏을 보는 가시성 규칙
- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

### 갱신 손실 방지
read committed와 스냅숏 격리는 동시 실행된 Write가 있을 때, Read 트랜잭션이 무엇을 볼수 있는지에 대해 보장하는 것이었다. 

두 트랜잭션이 동시에 쓰기를 실행할 때의 문제들은 무시했었는데, dirty-write 이외에도 다른 write-write conflict가 있다.

갱신 손실(lost-update) 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.(read-modify-write 주기)
두 트랜잭션이 read-modify-write를 동시에 하면 lost-update가 발생 할수 있다.
    - ex) counter 문제

#### 해결하기 위한 방법
- Atomic Operation: 데이터베이스에서 read-modify-write를 할 필요없이 하나의 연산으로 제공
- Explicit lock: 애플리케이션에서 갱신할 객체를 명시적으로 잠금. 다른 트랜잭션에서 read-modify-write 시에 기다리게 한다. 
- Automatically detecting lost updates: 앞선 두가지는 각 트랜잭션이 read-modify-write를 순차적으로 실행되도록 하는 것이었는데, 이 방법은 병렬적으로 실행을 허용하고, 트랜잭션 관리자가 lost-update를 발견하면 트랜잭션을 abort시키고 retry하도록 강제하는 방법
  - 장점은 데이터베이스가 스냅숏 격리와 결합해서 이 방법을 효율적으로 수행할 수 있다는 것
- Compare-and-set: write 할때 처음 read 할때의 값도 같이 compare 해서 set 해서, lost update를 회피. (Optimistic Lock 이 이거 같은데?)

#### 충돌 해소와 복제 
lock과 compare-and-set 연산은 데이터의 최신 복사본이 하나라고 가정하고 있는데, multi-leader, leaderless replication에서는 여러 쓰기가 동시에 실행되고, 비동기적으로 복제되기 때문에 데이터의 최신 복사본이 하나라고 보장할 수 없다. 

그래서 이런 경우에는 잠금과 CAS 연산을 기반으로 한 기법을 적용할 수 없다.

흔히 쓰는 방법은 동시에 실행될 때 한 값에 대해 여러개의 충동된 버전(sibiling)을 생성하는 것을 허용하고, 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 병합하는 것.

교환법칙이 성립하는 연산이라면 영향이 없다.
- ex) counter, Set에 데이터 추가 와 같은 경우에 순서 바껴도 영향이 없다.

LWW 충돌 해소 방법은 lost-update가 발생하기 쉽다. (유감스럽게도 많은 DB에서는 LWW가 기본 설정..)


### 쓰기 스큐와 팬텀
- 쓰기 스큐(write skew): 2개의 트랜잭션이 2개의 객체를 aggregation 하는 Read 후, 2개의 다른 객체를 갱신하여서 aggregation할때의 데이터의 제약성을 깨뜨리는 것

#### 방지방법
- 직렬성 격리
- 제약 조건을 설정 - 대부분의 데이터베이스는 이런 제약 조건을 내장하지는 않지만, 데이터베이스에 따라 트리거나 구체화 뷰(materialized view)를 사용해 구현할 수 있다.
- 직렬성 격리를 사용할수 없다면 트랜잭션이 의존하는 모든 로우를 명시적으로 잠금.

#### 쓰기 스큐를 유발하는 팬텀
1. SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지(go or stop) 결정한다.
3. go 인 경우에, 데이터베이스에 Write하고 트랜잭션 커밋한다. 이 쓰기로 인해서 다른 트랜잭션의 go or stop 을 판단하는 조건이 달라져버린다. 즉, 1을 다시 실행하면 2를 통과할수 없는 상태를 만들어 버릴 수 있다.

- 팬텀(phantom): 어떤 트랜잭션에서 실행한 Write가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과

- 쓰기 스큐를 해결하기 위해서 앞서 말한것 처럼 트랜잭션이 의존하는 모든 로우를 명시적으로 잠그는 방법을 이용할수 있는데, 어떤 검색 조건에 부합하는 로우가 존재하지 않는지 확인하고 진행하는 경우에는 lock을 걸 row가 없다!!
  - 충돌 구체화 방법을 이용해서 해결: row의 존재 유무가 아니라 lock을 걸수 있는 형태의 row를 미리 추가해놓는 것. 

## 직렬성
- 직렬성 격리는 가장 강력한 격리 수준, 병렬로 실행되더라도 동시성 없이 한번에 하나씩 직렬로 실행될 때와 같도록 보장한다.
- 다만, 이를 보장하기 위해서 tradeoff들이 있는데, 현재 직렬성을 구현하는 방법들에 대해 알아보고 확인해보자.

##### 직렬성을 구현하는 기법
- 실제적인 직렬 실행
- 2단계 잠금
- 직렬성 스냅숏 격리 같은 낙관적 동시성 제어(optimisitic concurrency control

### 실제적인 직렬 실행
- 단일 쓰레드로 트랜잭션을 순차적으로 처리
  - 램 가격이 저렴해져서, 메모리에 active data set을 메모리에 유지할 수 있게 되었다.
  - OLTP 트랜잭션은 보통 짧고, 실행하는 읽기와 쓰기의 개수가 적다라는 것을 알게 되었다.
  - 단일 쓰레드가 성능이 나을 때도 있다. lock coordination overhead를 피할수 있기 때문에, But CPU Core 하나의 처리량으로 제한되기 때문에 트랜잭션이 전통적인 형태와 다르게 구조화되어야 한다.
  
#### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
- 단일 스레드에서 다중 구문 트랜잭션을 허용하면, 애플리케이션 내부의 로직들로 인해 성능 문제가 발생 할수 있다. 그래서 단일 스레드에서는 다중 구문 트랜잭션을 허용하지 않는다.
- 그래서 다중 구문 트랜잭션을 하고 싶으면, 트랜잭션 코드 전체를 Stored Procedure 형태로 미리 제출해야 한다.

#### 스토어드 프로시저의 장단점
- 범용 프로그래밍 언어에 비해서 스토어드 프로시저용 언어가 좀 구리다.
  - 현대에는 개선되었음. 
    - 볼트DB: java, groovy
    - Redis: lua
- Logging, Debugging, Monitoring 등이 어렵다.
- 데이터베이스는 애플리케이션 서버보다 훨씬 더 성능에 민감할 때가 많다. 여러 애플리케이션 서버가 하나의 데이터베이스 인스턴스를 공유해서 사용하기 때문.

스토어드 프로시저가 있고, 데이터가 메모리에 저장된다면, 모든 트랜잭션을 I/O 대기가 필요없기 때문에 다른 동시성 제어 메커니즘의 overhead를 회피할수 있기 때문에 단일 스레드로도 상당히 좋은 성능을 보여줄수 있다.

#### 파티셔닝
- 단일 쓰레드 모델에서는 하나의 CPU Core만을 사용해야 하는 제한이 있었는데, 이를 해결하기 위해서 데이터를 파티셔닝해서 여러 Cpu Core를 사용하도록 할수 있다.
- 다만, 여러 파티션의 데이터에 접근하는 트랜잭션이 있으면 모든 파티션에 대해 코디네이션을 해야해서 추가적인 오버헤드가 발생할 수 있다.

#### 직렬실행 요약
- 모든 트랜잭션은 작고 빨라야 한다
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다.


### 2단계 잠금(2-phase locking, 2PL)
2PL: Write, Read 트랜잭션은 다른 Write, Read 트랜잭션을 전부 block.

#### 2PL 구현
- 데이터베이스의 각 객체에 잠금을 사용해 구현한다.
- 잠금
  - shared mode: 다른 트랜잭션이 같이 lock을 획득하는 것을 허용
  - exclusive mode: 혼자 독적점으로 lock을 획득하고 있는 것

시나리오
- 트랜잭션이 Read시 shared mode로 lock 획득 시도한다. 이미 shared mode로 lock이 걸려있으면 lock을 획득할수 있지만, exclusive mode lock이 걸려있으면, 다른 트랜잭션이 끝날때 까지 wait해야한다.
- 트랜잭션이 Write시 exclusive mode로 lock을 획득해야 한다. 이미 lock이 있으면 대기해야 한다
- 트랜잭션이 Read 하다가 Write하면 shared mode에서 exclusive mode로 lock 업그레이드 해야 한다. 
- 트랜잭션이 lock을 획득한 후에는 트랜잭션이 종료될때까지 lock을 갖고 있어야 한다.

- DeadLock: 두 트랜잭션이 서로 lock을 획득하기 위해 대기하는 상태
  - 데이터베이스는 DeadLock을 감지하고 하나를 abort 시켜서 진행되도록 해야함. 애플리케이션에서 재시도.
  - 
#### 2PL의 성능
- 성능이 안 좋다. 
  - lock 획득, 해제 overhead도 있지만, 더 큰 문제는 동시성이 줄어들어서 다른 트랜잭션이 끝날때까지 기다려야 하기 때문..
  - DeadLock도 자주 발생할수 있음.

#### 서술 잠금(predicate lock)
- 특정 객체에 속하지 않고 어떤 검색 조건에 부합하는 모든 객체에 거는 lock)
- 데이터베이스에 아직 존재하지 않지만, 미래에 추가될 수 있는 객체에도 적용이 가능

#### 색인 범위 잠금
Predicate lock은 진행중인 트랜잭션이 획득한 lock이 많으면 조건에 부합하는 lock을 확인 하는데 시간이 오래 걸린다. 그래서 Predicate lock은 실제로 잘 동작하지 않는다.
그래서, 대부분의 데이터베이스는 색인 범위 잠금(index-range locking)을 구현한다.

- index-range locking: Predicate를 index가 걸려있는 column으로 간략화 해서 lock을 거는 방법

### 직렬성 스냅숏 격리(serializable snapshot isolation, SSI)
완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있다.

2PL, 직렬 실행은 비관적 동시성 제어 메커니즘이다. 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는게 낫다는 원칙을 기반으로 한다.

SSI는 낙관적 동시성 제어 기법이다. 위험한 상황이 발생할 가능성이 있을 때 계속 진행한다. 트랜잭션이 커밋되려고 할때, 격리 위반이 됐는지 확인하고, 있으면 트랜잭션을 abortgksek.

SSI는 스냅숏 격리처럼 Read는 데이터베이스의 일관된 스냅숏을 보게된다. Write시에는 직렬성 충돌을 감지하고 abort시킬 트랜잭션을 결정하는 알고리즘을 추가한다.

#### 뒤처진 전제에 기반한 결정
트랜잭션이 데이터베이스에서 Read -> Check -> Write를 하는데, Write하는 시점에 이전의 Read의 값이 최신이 아닐 수 있다. 그래서 Check의 결과가 달라질 수 있다는 전제를 기반으로 abort시킬지 말지 판단한다.

데이터베이스에서는 어떻게 Read 값이 변경되었다는 것을 알수 있나?
- 오래된(stale) MVCC 객체 버전을 읽었는지 감지하기 (읽기 전에 커밋되지 않은 쓰기가 발생했음)
- 과거의 읽기에 영향을 미치는 쓰기 감지하기 (읽은 후에 쓰기가 실행됨)

##### 오래된 MVCC 읽기 감지하기
다른 트랜잭션에서 commit되지 않은 update가 있어서, 오래된 MVCC Read를 한 경우에 Write 후 Commit하는 시점에 abort 시킨다.

##### 과거의 읽기에 영향을 미치는 쓰기 감지하기
트랜잭션에서 데이터를 읽었다는 history를 남기고(색인 범위로), 그 데이터를 변경하는 다른 트랜잭션이 커밋될 때, 데이터를 읽었다는 history를 가지고 있는 트랜잭션에게 알려준다. 알림을 받은 트랜잭션은 commit 할때 abort된다.  

#### SSI의 성능
abort 비율이 SSI의 전체적인 성능에 큰 영향을 미친다. 이를테면 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트 되기 쉬워서 SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다.

