# 파트2. 데이터 시스템의 기초

# 7장. 트랜잭션
- 애플리케이션에서 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
- 내결함성을 갖춘 시스템을 구현하기 위해 필요함
  - DB에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적
  - 잠재적인 오류 시나리오와 동시성 문제를 애플리케이션이 아닌 DB에서 맡아줌
- 트랜잭션이 제공하는 안전성 보장에는 어떤 것이 있는지, 이와 관련된 비용은 무엇인지?
- 문제가 생길 수 있는 여러 예시와 이런 문제를 방지하기 위해 DB에서 사용하는 알고리즘
  - 특히 동시성 제어 분야를 깊게 다루고, 발생가능한 다양한 경쟁 조건과 DB 격리 수준을 어떻게 구현하는지

## 애매모호한 트랜잭션의 개념
- 분산 DB의 주장 : 트랜잭션은 확장성의 안티테제이다
- DB 벤더의 주장 : 트랜잭션은 중요 데이터가 있는 애플리케이션에 필수적인 요구사항이다
- 두 관점 모두 과장이다

### ACID의 의미
- ACID(Atomicity, Consistency, Isolation, Durability)와 BASE(Basically Available, Soft state, Eventual consistency)의 정의는 모호하다

### 원자성
- 원자적 : 더 작은 부분으로 쪼갤 수 없는 무언가
- 시스템은 연산을 실행하기 전이나 후의 상태에만 있을 수 있고, 그 중간 상태에는 머무를 수 없다
- 하나의 원자적 트랜잭션으로 묶인 여러 쓰기 작업에 결함이 발생하면 **어보트(abort)**되고 DB는 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소한다

### 일관성
- 일관성이란 단어는 굉장히 여러 의미로 쓰이고 있다
  - **복제 일관성(replica consistency)**과 비동기식 복제 시스템에서 발생하는 **최종적 일관성(eventual consistency)**
  - 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법인 **일관성 해싱**
  - CAP 정리에서 선형성(linearizability)을 의미하는 **일관성**
  - ACID의 맥락으로 사용되는 **일관성**
- ACID 맥락 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(**불변식(invariant)**)이 있다는 것
- 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족한다고 확신할 수 있음
- + 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 **애플리케이션의 책임**이다. DB의 책임이 아니다!
- DB는 불변식을 위반하는 데이터를 쓰지 못하게 막을 수 없기 때문이다
- 원자성, 격리성, 지속성은 **DB의 속성**인 반면(ACID에서), 일관성은 **애플리케이션의 속성**이다

### 격리성
- ACID에서 **격리성**은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다
- 직렬성 : 여러 트랜잭션이 동시에 실행되도 각 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다
- 실제로 직렬성 격리는 성능 손해를 동반해 현실에서 거의 사용하지 않고, 이보다 완화된 격리 수준을 주로 사용한다

### 지속성
- DB의 목적은 데이터를 잃어버리지 않는 안전한 저장소를 제공하는 것
- 지속성(durability)은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 DB가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장
- 지속성을 보장하려면 트랜잭션이 성공적으로 커밋됐다고 보고하기 전 쓰기나 복제가 완료될 때까지 기다려야한다

## 단일 객체 연산과 다중 객체 연산
- **다중 객체 트랜잭션**은 데이터의 여러 조각이 동기화된 상태로 유지해야 할 때 필요하다
- 또한 어떤 읽기/쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다
  - RDB에서는 클라이언트와 DB 서버 사이의 TCP 연결을 기반으로 한다
  - 특정 연결 내에서 BEGIN TRANSACTION 문과 COMMIT 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여긴다
    - 이 방법은 이상적이지 않다
    - 왜냐하면 TCP 연결이 끊기면 트랜잭션은 어보트되야 하는데
    - 클라이언트가 커밋 요청을 보냈지만 서버가 커밋 여부를 확인해주기 전에 연결이 끊긴다면 클라이언트는 트랜잭션이 커밋됐는지 아닌지 알 수 없기 때문이다
    - 이 문제를 해결하려면 트랜잭션 관리자는 특정 TCP 연결에 엮이지 않은 **고유한 트랜잭션 식별자**를 사용해 연산을 묶을 수 있다
    - 이런 식별자는 어떤 것이 있을까?
  - 비관계형 DB에서는 위와 같은 방법이 없는 경우가 많다

### 단일 객체 쓰기
- 단일 객체 쓰기 시 발생할 수 있는 문제(원자성, 격리성 관점에서)
  - 20KB의 JSON 문서를 보내는 중 10KB 시점에서 네트워크 연결이 끊기면 이미 보내진 JSON을 저장할 것인가?
  - DB가 디스크에 저장된 기존 값을 덮어쓰는 중 전원이 나가면 기존 값과 새 값은 어떻게 처리?
- 위 문제는 매우 어렵고, 저장소 엔진들은 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다
- 원자성은 장애 복구용 로그로, 격리성은 각 개체에 잠금을 사용해 동시에 한 스레드만 접근하도록해 구현할 수 있다
- 또는 compare and set 연산과 같은 방법으로 원자적 연산을 제공하기도 한다
  - 변경하고자 하는 값이 누군가에 의해 동시에 바뀌지 않았을 때만 쓰기가 반영되도록 허용함
- 이런 단일 객체 연산은 여러 클라이언트에서의 동시성 문제에 대해 갱신 손실을 방지해준다
- 그러나 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 매커니즘으로 이해된다

### 다중 객체 트랜잭션의 필요성
- 트랜잭션이 없어도 구현은 할 수 있지만 오류 처리와 동시성 문제를 처리하기 매우 복잡하고 어려워진다

### 오류와 어보트 처리
- 트랜잭션 핵심 기능 : 오류가 생기면 어보트되고 안전하게 재시도 할 수 있다는 것
- 오류 복구는 애플리케이션에게 책임이 있다
- 완벽하지 않은 트랜잭션 재시도 사례
  - 클라이언트와 서버 간 커밋 성공을 알리는 중 네트워크가 끊기면 중복 처리 가능성이 있다
  - 오류 원인이 과부하때문이면 트랜잭션 재시도는 문제를 악화시킬 수 있다. 재시도 횟수 제한, 지수적 백오프 등 과부하 관련 오류는 별도 방식으로 처리해야한다
  - 일시적인 오류만 재시도 가치가 있고, 영구적 오류는 재시도 가치가 없다
  - 여러 다른 시스템이 반드시 함께 커밋/어보트 되게 하고 싶다면 2단계 커밋이 도움될 수 있다
  - 클라이언트 프로세스가 재시도 중에 죽어버리면 클라이언트가 DB에 쓰려고 했던 데이터가 손실된다

## 완화된 격리 수준
- DB는 애플리케이션 개발자들에게 트랜잭션 격리를 제공해 동시성 문제를 감추려고 했다
- 그렇지만 직렬성 격리의 경우 성능 비용이 있고 많은 DB들은 그 비용을 지불하려 하지 않는다
- 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터는 보호해주지 않는 **완화된 격리 수준**을 사용하는 애플리케이션들이 흔하다

### 커밋 후 읽기
- DB에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기 없음)
- DB에서 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기 없음)

### 더티 읽기 방지
- 더티 읽기 : 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있는 현상
- 부분적으로 갱신된 DB를 보게 되거나, 나중에 롤백될 데이터를 볼 수 있기 때문에 더티 읽기를 막는게 유용하다

### 더티 쓰기 방지
- 나중에 실행된 트랜잭션이 커밋되지 않은 값을 덮어써버리는 현상
  - 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 다음 쓰기를 지연시키는 방법을 사용
- 쓰기 반영 시 처리하는 로직이 꼬일수도 있고, 내용이 섞일 수도 있기 때문에 더티 쓰기를 막는게 유용하다
- 더티 읽기/쓰기를 막아도 race condition은 해결하지 못한다(갱신 손실 방지로 해결해야 함)

### 커밋 후 읽기 구현
- 가장 흔한 방법 : DB 로우 잠금을 사용해 더티 쓰기를 방지함
- 읽기 잠금까지 사용하면 응답 시간이 너무 느려져서 현실에서는 잘 사용하지 않는다
- 그래서 대부분 DB는 쓰여진 모든 객체에 대해 과거 커밋된 값과 현재 트랜잭션에서 쓴 새로운 값을 모두 기억한다
- 해당 트랜잭션이 실행중인 동안 이 객체를 읽는 트랜잭션들은 과거의 값을 보게 된다
- 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된

### 스냅숏 격리와 반복 읽기
- 커밋 후 읽기 격리 수준을 사용해도 동시성 버그가 생길 수 있는 경우가 많다
- **비반복 읽기(nonrepeatable read)**가 대표적
- 최종적 일관성을 만족하게 되나, 어떤 상황에서는 이러한 일관성을 감내하지 못하는 경우도 있다
- **스냅숏 격리**는 이런 문제의 가장 흔한 해결책이다
  - 각 트랜잭션은 DB의 **일관된 스냅숏**으로 부터 읽는다
  - 트랜잭션은 시작할 때 DB에 커밋된 상태였던 모든 데이터를 본다
  - 데이터가 나중에 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다
- 스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 요긴하다

### 스냅숏 격리 구현
- 스냅숏 격리는 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다
- 읽을 떄는 아무 잠금도 필요없다
- 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고, 쓰는 쪽에서도 읽는 쪽을 결코 차단하지 않는다
- 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되고, 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다
- 구현을 위해 DB는 객체마다 커밋된 버전 여럿을 유지하는 **다중 버전 동시성 제어(MVCC, multi-version concurrency control)**을 사용한다
  - 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID를 할당받는다
  - 트랜잭션이 DB에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다
  - 테이블 로우에는 트랜잭션 ID를 갖는 필드와 로우를 삭제했음을 표시하는 필드가 있다
  - 트랜잭션이 로우를 삭제하면 실제 DB에서 지우지 않고, 삭제 표시 필드만 업데이트하고 나중에 아무 트랜잭션도 접근하지 않는게 확실해지면 DB의 GC 프로세스가 삭제한다
  - 갱신은 내부에서 삭제와 생성으로 변환된다

### 일관된 스냅숏을 보는 가시성 규칙
- 트랜잭션은 DB에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정한다
- 가시성 규칙을 정의해 DB의 일관된 스냅숏을 애플리케이션에게 제공할 수 있다
  - 동작방식
  - DB는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만들고, 이 트랜잭션들이 쓴 데이터는 모두 무시된다
  - 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다
  - 트랜잭션 ID가 더 큰 (현재 트랜잭션이 시작한 이후에 시작한) 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부와 관계없이 모두 무시된다
  - 이외 모든 데이터는 애플리케이션의 질의로 볼 수 있다
- DB는 갱신할 때 값을 교체하지 않고 새 버전을 생성해 적은 오버헤드로 일관된 스냅숏을 제공할 수 있다

### 색인과 스냅숏 격리
- 다중 버전 DB에서 색인은 어떻게 동작할까?
  - 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 함
  - GC가 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제할 때 대응 되는 색인 항목도 삭제 됨
- PostgreSQL은 동일한 객체의 다른 버전들이 같은 페이지(page)에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다
- 카우치DB, 데이토믹, LMDB는 다른 방법을 쓴다
  - B트리를 사용하지만 추가 전용이며 쓸 때 복사되는 변종을 사용한다
  - 트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다
  - 트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고, 그것들의 자식 페이지들의 새 버전을 가리키도록 갱신된다
  - 쓰기에 영향을 받지 않는 페이지들은 복사될 필요가 없고 변함 없는 상태로 남는다
- 추가 전용 B트리를 사용하면 쓰기를 실행하는 모든 트랜잭션은 새로운 B 트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 DB의 일관된 스냅숏이 된다
- 나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B 트리를 변경할 수 없으므로 **트랜잭션 ID를 기반으로 객체를 걸러낼 필요**가 없다

### 반복 읽기와 혼란스러운 이름
- 스냅숏 격리는 특히 읽기 전용 트랜잭션에 유용하다
- 반복 읽기 격리 수준을 DB마다 제공하는 보장에 차이가 크다

## 갱신 손실 방지
- 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌이 여러 종류 있다
- 가장 널리 알려진 것은 **갱신 손실(lost update)** 문제이다(동시에 두 트랜잭션에서 카운터를 증가시키는 예)
- 갱신 손실은 DB에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다
- 변경 중 하나가 손실될 수 있다
- 갱신 손실의 다양한 해결책을 알아보자

### 원자적 쓰기 연산
- DB에서 제공하는 원자적 갱신 연산
- 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해 구현
- 갱신이 적용될 때까지 다른 트랜잭션에서 객체를 읽지 못하게 함
- 다른 선택지는 모든 원자적 연산을 단일 스레드에서 실행하도록 강제하는 것

### 명시적인 잠금
- 애플리케이션에서 갱신할 객체를 명시적으로 잠금
- 애플리케이션이 read-modify-write 주기를 수행할 수 있고, 다른 트랜잭션에서 동시에 같은 객체를 읽으려 하면 기존 주기가 완료될때까지 기다린다
- 애플리케이션 로직을 신중하게 구현해야 함. 코드 어딘가 필요한 잠금 추가하는 것을 잊으면 race condition 유발 쉬움

### 갱신 손실 자동 감지
- 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견시키면 트랜잭션을 어보트 시키고 재시도하도록 강제하는 방법
- 애플리케이션에서 어떤 DB 기능도 사용하지 않아도 되게 해줌
- 자동으로 갱신 손실을 감지하여 오류가 덜 발생하게 해줌

### Compare and set
- 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것
- 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 재시도
- DB에서 where 절이 오래된 스냅숏으로부터 읽는 거 ㅅ을 허용하면 동시에 다른 쓰기 작업이 실행되고 있어도 참이 될 수 있기에 갱신 손실을 막지못할 수 있음

### 충돌 해소와 복제
- 복제가 적용된 DB의 갱신 손실을 막는 것은 다른 차원의 문제
- 데이터가 다른 노드들에서 동시에 변겨될 수 있어 갱신 손실을 방지하려면 추가 단계가 필요함
- 데이터 최신 복사본이 하나만 있다고 보장할 수 없음
- 그렇기에 잠금과 Compare and set 기반 방법을 적용할 수 없음
- 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전(형제(sibling))을 생성하는 것을 허용하고 
- 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합함
- 원자적 연산은 복제 환경에서도 잘 동작함
- **최종 쓰기 승리(last write wins, LWW)** 충돌 해소 방법은 갱신 손실이 발생하기 쉽지만 많은 복제 DB는 LWW가 기본 설정이다

### 쓰기 스큐와 팬텀
- 쓰기 스큐 : 두 트랜잭션이 두 개의 다른 객체를 동시에 갱신할 때 발생하는 이상 현상
- 두 트랜잭션이 같은 객체들을 읽고 그중 일부를 갱신할 때 나타날 수 있음
- 스냅숏 격리 수준에서는 쓰기 스큐를 막을 수 없다

### 쓰기 스큐를 유발하는 팬텀
- 팬텀 : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
- 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 읽기 쓰기 트랜잭션에서는 그렇지 못할 수 있다

### 충돌 구체화
- 팬텀의 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 DB에 잠금 객체를 추가할 수 있지 않을까?
- 조건에 해당하는 내용을 별도 테이블 로우로 만들어 이에 대해 잠금 처리?
- 이런 방법을 **충돌 구체화**라고 한다
- 이 방법은 알아내기 어렵고 오류가 발생하기 쉽다
- 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 나오는 형태도 바람직하지 못하다
- 따라서 이 방안은 최후의 방안으로 고려해야 하고, 대부분 직렬성 격리 수준이 더 선호된다

## 직렬성
- 가장 강력한 격리 수준
- 여러 트랜잭션이 병렬로 실행되도 최종 결과는 동시성없이 한 번에 하나씩 **직렬로** 실행될 때와 같도록 보장함
- DB가 발생할 수 있는 모든 경쟁 조건을 막아준다

### 실제적인 직렬 실행
- 동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것(단일 스레드)
- 뻔한 생각처럼 보이지만 상당히 최근(2007년 경)에 이 것이 실현가능하다고 결론내렸다
  - 램 가격 인하
  - OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달음
- 볼트DB, H-스토어, 레디스, 데이토믹에서 구현돼 있다
- 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와 다르게 구조화돼야 한다(CPU 코어 하나로 처리하기 때문)

### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
- 단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템들은 상호작용하는 다중 구문 트랜잭션을 허용하지 않는다
  - 다음 질의 발행 대기하는데 시간을 다 써 성능이 최악이 될 것
- 대신 애플리케이션은 트랜잭션 코드 전체를 **스토어도 프로시저** 형태로 DB에 미리 제출한다

### 스토어드 프로시저의 장단점
- I/O 대기가 필요없고 다른 동시성 제어 메커니즘의 오버헤드가 없으므로 단일 스레드로 상당히 좋은 처리량을 얻을 수 있다
- 하지만 DB에서 실행되는 코드는 관리하기 어렵고, 라이브러리 생태계가 빈약하고 성능에 민감한 단점도 있다

### 파티셔닝
- 쓰기 처리량이 높은 애플리케이션에는 단일 스레드 트랜잭션 처리자가 심각한 병목이 될 수 있다
- 여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝 할 수도 있다(볼트 DB)
- 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝 할 수 있다면
- 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있다
- 이렇게 하면 트랜잭션 처리량을 CPU 코어 개수에 맞춰 선형적으로 확장할 수 있다
- 하지만 여러 파티션에 접근해야 하는 트랜잭션은 DB가 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐 코디네이션을 해야하기 때문에 엄청 느리다
- 이는 데이터 구조에 의존한다
- 키-값 데이터는 쉽게 파티셔닝이 가능하지만 여러 보조 색인이 있는 데이터는 여러 파티션에 걸친 코디네이션이 필요할 가능성이 높다


