# 7. 트랜잭션
데이터 시스템에 생길 수 있는 여러 가지 문제들이 존재한다.
* 데이터베이스 소프트웨어나 하드웨어는(쓰기 연산이 실행 중일 때를 포함해서) 언제라도 실패할 수 있다.
* 애플리케이션은 (연속된 연산이 실행되는 도중도 포함해서) 언제라도 죽을 수 있다.
* 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
* 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
* 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
* 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

신뢰할 수 있는 시스템은 이런 문제들을 모두 해결할 수단이 있어야 한다.
수년간 이런 문제를 트랜잭션이라는 개념으로 단순화하여 관리했다.
이로인해 데이터시스템을 이용하는 애플리케이션 프로그래밍 모델이 단순해지는 효과를 얻었다.

<br>
<br>

## 애매모호한 트랜잭션의 개념
### ACID의 의미
현실의 데이터베이스의 내결함성 매커니즘을 의미하는 ACID는 모호하고 데이터베이스마다 구현이 제각각이다.

#### 원자성(Atomicity)
트랜잭션에서 발생한 쓰기 기록들을 완료 시키거나 취소 시킬 수 있는 능력.
전체를 적용하거나 적용하지 말아야 한다.

#### 일관성(Consistency)
ACID의 일관성은 데이터에 관한 불변식을 보장하는 것이다.
데이터에 관한 불변식을 지키는 것은 애플리케이션의 책임이다.
따라서 C는 실제로 데이터베이스에 속하지 않는다.

#### 격리성(Isolation)
동시에 실행 되는 트랜잭션들을 격리하는 방법.
데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
하지만 직렬성 격리(Serializable Isolation)는 성능상 손해를 동반하므로, 어떤 데이티베이스는 이를 직렬성보다 보장이 약한 스냅숏 격리를 이용한다.

한 트랜잭션이 여러번의 쓰기를 한다면 다른 트랜잭션은 그 내용을 전부 볼 수 있던지, 전부 볼 수 없던지 해야한다.

#### 지속성(Durability)
트랜잭션이 성공했다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
하지만 궁극적인 완전한 보장이라는 개념은 존재하지 않으며, 트레이드 오프를 이해해야 한다.

<br>

### 단일 객체 연산과 다중 객체 연산
#### 단일 객체 쓰기
저장소 엔진들은 보편적으로 한 노드에 저장하는 단일 객체 수준에서 원자성과 격리성 지원을 목표로 한다.
* 원자성: 장애복구용 로그를 이용
* 격리성: 잠금을 이용

증가연산을 제공하는 경우, 변경하려는 값이 누군가로 인해 변경 되지 않았을 때만 허용

#### 다중 객체 트랜잭션의 필요성
단일 객체 연산만으로 애플리케이션을 구성할 수도 있으나, 다음의 사유들로 인해 다중 객체 트랜잭션은 필요하다.
(심지어 분산 데이터베이스는 그것을 포기했음에도 불구하고)
* 관계형/그래프형 데이터 모델은 다른 데이터와 관계를 맺고 있고, 그것들의 키와 정보가 올발라야 한다.
* 갱신되어야 하는 정보가 하나의 문서에 집약 되어 있는 문서 데이터 모델일지라도, 반정규화된 데이터와 동기화가 필요한 경우가 있다.
* 보조 색인이 있는 데이터베이스는 값을 변경할 때 보조 색인도 변경 되어야 한다.

다중 객체 트랜잭션이 보장 되지 않는다면, 이 문제들은 모두 애플리케이션에서 구현 되어야 한다.

#### 오류와 어보트 처리
트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재실행 될 수 있게 하는 것이다.
하지만 모든 시스템이 이 철학을 따르지는 않는다. 특히 리더 없는 복제는 Best Effort 원칙을 기반으로 더 많은 처리를 수행한다.

어보트된 트랜잭션을 재실행 하는 것은 간단하고 효과적인 오류 처리 매커니즘이지만 완벽하지는 않다.
* 트랜잭션이 실제로는 성공 했지만, 네트워크 이슈로 인해 클라이언트에게 성공 응답을 보내는 것이 실패한 경우. 재시도하면 트랜잭션이 총 두 번 실행된다. (중복 문제 발생 가능)
* 오류가 과부하 때문이라면 재시도는 문제를 악화시킬 수 있다. 재시도 횟수 제한이나 지수적인 백오프등이 필요하다.
* 일시적 오류(ex: 교착 상태, 격리성 위반, 일시적인 네트워크 단절, 장애 복구)만 재시도할 가치가 있으며, 영구적인 요구(ex: 제약조건 위반)등은 재시도해도 아무 소용 없다.
* 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수효과가 발생할 수 있다.
* 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

<br>
<br>


## 완화된 격리 수준
### 커밋 후 읽기
### 스냅숏 격리와 반복 읽기
### 갱신 손실 방지
### 쓰기 스큐와 팬텀

<br>
<br>

## 직렬성
### 실제적인 직렬 실행
### 2단계 잠금
### 직렬성 스냅숏 격리
