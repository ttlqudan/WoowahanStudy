# 7. 트랜잭션
데이터 시스템에 생길 수 있는 여러 가지 문제들이 존재한다.
* 데이터베이스 소프트웨어나 하드웨어는(쓰기 연산이 실행 중일 때를 포함해서) 언제라도 실패할 수 있다.
* 애플리케이션은 (연속된 연산이 실행되는 도중도 포함해서) 언제라도 죽을 수 있다.
* 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
* 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
* 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
* 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

신뢰할 수 있는 시스템은 이런 문제들을 모두 해결할 수단이 있어야 한다.
수년간 이런 문제를 트랜잭션이라는 개념으로 단순화하여 관리했다.
이로인해 데이터시스템을 이용하는 애플리케이션 프로그래밍 모델이 단순해지는 효과를 얻었다.

<br>
<br>

## 애매모호한 트랜잭션의 개념
### ACID의 의미
현실의 데이터베이스의 내결함성 매커니즘을 의미하는 ACID는 모호하고 데이터베이스마다 구현이 제각각이다.

#### 원자성(Atomicity)
트랜잭션에서 발생한 쓰기 기록들을 완료 시키거나 취소 시킬 수 있는 능력.
전체를 적용하거나 적용하지 말아야 한다.

#### 일관성(Consistency)
ACID의 일관성은 데이터에 관한 불변식을 보장하는 것이다.
데이터에 관한 불변식을 지키는 것은 애플리케이션의 책임이다.
따라서 C는 실제로 데이터베이스에 속하지 않는다.

#### 격리성(Isolation)
동시에 실행 되는 트랜잭션들을 격리하는 방법.
데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
하지만 직렬성 격리(Serializable Isolation)는 성능상 손해를 동반하므로, 어떤 데이티베이스는 이를 직렬성보다 보장이 약한 스냅숏 격리를 이용한다.

한 트랜잭션이 여러번의 쓰기를 한다면 다른 트랜잭션은 그 내용을 전부 볼 수 있던지, 전부 볼 수 없던지 해야한다.

#### 지속성(Durability)
트랜잭션이 성공했다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
하지만 궁극적인 완전한 보장이라는 개념은 존재하지 않으며, 트레이드 오프를 이해해야 한다.

<br>

### 단일 객체 연산과 다중 객체 연산
#### 단일 객체 쓰기
저장소 엔진들은 보편적으로 한 노드에 저장하는 단일 객체 수준에서 원자성과 격리성 지원을 목표로 한다.
* 원자성: 장애복구용 로그를 이용
* 격리성: 잠금을 이용

증가연산을 제공하는 경우, 변경하려는 값이 누군가로 인해 변경 되지 않았을 때만 허용

#### 다중 객체 트랜잭션의 필요성
단일 객체 연산만으로 애플리케이션을 구성할 수도 있으나, 다음의 사유들로 인해 다중 객체 트랜잭션은 필요하다.
(심지어 분산 데이터베이스는 그것을 포기했음에도 불구하고)
* 관계형/그래프형 데이터 모델은 다른 데이터와 관계를 맺고 있고, 그것들의 키와 정보가 올발라야 한다.
* 갱신되어야 하는 정보가 하나의 문서에 집약 되어 있는 문서 데이터 모델일지라도, 반정규화된 데이터와 동기화가 필요한 경우가 있다.
* 보조 색인이 있는 데이터베이스는 값을 변경할 때 보조 색인도 변경 되어야 한다.

다중 객체 트랜잭션이 보장 되지 않는다면, 이 문제들은 모두 애플리케이션에서 구현 되어야 한다.

#### 오류와 어보트 처리
트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재실행 될 수 있게 하는 것이다.
하지만 모든 시스템이 이 철학을 따르지는 않는다. 특히 리더 없는 복제는 Best Effort 원칙을 기반으로 더 많은 처리를 수행한다.

어보트된 트랜잭션을 재실행 하는 것은 간단하고 효과적인 오류 처리 매커니즘이지만 완벽하지는 않다.
* 트랜잭션이 실제로는 성공 했지만, 네트워크 이슈로 인해 클라이언트에게 성공 응답을 보내는 것이 실패한 경우. 재시도하면 트랜잭션이 총 두 번 실행된다. (중복 문제 발생 가능)
* 오류가 과부하 때문이라면 재시도는 문제를 악화시킬 수 있다. 재시도 횟수 제한이나 지수적인 백오프등이 필요하다.
* 일시적 오류(ex: 교착 상태, 격리성 위반, 일시적인 네트워크 단절, 장애 복구)만 재시도할 가치가 있으며, 영구적인 요구(ex: 제약조건 위반)등은 재시도해도 아무 소용 없다.
* 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수효과가 발생할 수 있다.
* 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

<br>
<br>


## 완화된 격리 수준
데이터베이스 시스템은 직렬성을 제공함으로서 애플리케이션에게 동시성 문제를 감춘다.
이론상으로 격리성은 동시성이 없는 것 처럼 행동하므로 애플리케이션 개발자들의 부담을 줄여줘야 하나, 현실은 그렇지 못하다.
많은 시스템들은 완화된 직렬성을 제공하고 있기 때문에 이것을 이해해야 한다.

### 커밋 후 읽기
#### 더티 읽기 문제
더티 읽기는 커밋 되지 않은 트랜잭션의 데이터를 다른 트랜잭션에서 읽는 문제이다.
더티 읽기는 다음의 문제들을 유발하낟.
* 트랜잭션이 여러 객체를 갱신하면 다른 트랜잭션의 일부는 갱신되기 전의 값을, 일부는 갱신된후의 값을 읽게 된다.
* 트랜잭션이 어보트 되면 여지껏 쓴 내용은 롤백 된다. 따라서 영원히 커밋 되지 못할 값을 읽을 수도 있다.

#### 더티 쓰기 문제
더티 쓰기 문제는 데이터베이스에 있는 동일한 객체를 수정할 때 발생한다.
커밋 후 읽기 격리 수준에서 실행 되는 트랜잭션은 더티 쓰기를 방지해야 한다.
더티 쓰기는 최종적으로 갱신된 객체의 값과 관련된 다른 객체의 불변성을 해칠 수 있다.

### 커밋 후 읽기 구현
커밋 후 읽기 구현은 굉장히 보편적으로 사용 되는 격리 수준이다. 가장 간단한 방법으로 로우 수준 잠금을 사용한다.

더티 읽기를 방지하기 위해 쓰기 잠금과 동일한 잠금을 읽기에도 사용하는 것이 있다.
하지만 이는 읽기만 하는 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때 까지 기다려야 할 수도 있다.

이런 이유로 대부분의 데이터베이스는 쓰여진 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다.
그리고 쓰기가 진행되는 동안, 읽기 연산은 과거의 커밋값을 이용한다.

### 스냅숏 격리와 반복 읽기
커밋 후 읽기가 많은 것을 해주는 것 처럼 보이지만, 이것으로도 해결할 수 없는 문제가 있다.
비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew)라고 한다.

애플리케이션에 따라 이를 감내할 수 있는 것들도 있으나, 그렇지 못한 것들도 있다.
(ex: 백업, 분석 질의와 무결성 확인)

이런 문제 해결을 위해 스냅숏 격리를 사용할 수 있다.
각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다.
트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.
데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.

#### 스냅숏 격리 구현
커밋 후 읽기 구현처럼 쓰기 잠금을 사용한다. 하지만 읽을 때는 아무런 잠금도 사용하지 않는다.
읽기와 쓰기 연산간에 결코 상호 차단하지 않는다.

데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. 이를 위해 다중 버전 동시성 제어를 이용한다.

#### 일관된 스냅숏을 보는 가시성 규칙
트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용하여 어떤 것을 볼 수 있고, 어떤 것을 볼 수 없는지 확인한다.
1. 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다.
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 현재 트랜잭션이 시작된 이후에 시작 되었다면, 그 트랜잭션의 커밋 여부와 관계 없이 모두 무시된다.
4. 그 박의 모든 데이터는 애플리케이션 질의로 볼 수 있다.

#### 색인과 스냅숏 격리
다중 버전 데이터베이스에서 색인의 동작을 위해 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 할 수 있다.
그 후 가비지 컬랙션이 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제할 때 대응되는 색인 항목도 삭제된다.

알고리즘에 따라 동시성 성능이 결정 된다.

<br>

### 갱신 손실 방지
갱신 손실은 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때(read-modify-write) 발생할 수 있다.
두 번째 쓰기 값이 첫 번째 쓰기 값의 내용을 반영하고 있지 않다면, 갱신 손실이 발생한다.

#### 1. 원자적 쓰기 연산
데이터베이스에서 지원하는 원자적 쓰기 연산은 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애준다.
원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. 이 기법을 커서 안정성이라고 부르기도 한다.

#### 2. 명시적인 잠금
원자적 쓰기 연산 대신, 명시적인 잠금을 선택할 수도 있다.

#### 3. 갱신 손실 자동 감지
* 1, 2의 대안으로 이들의 병렬 수행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도하도록 강제하는 방법도 있다.
데이터베이스가 이 확인을 스냅숏 격리와 결합하여 효율적으로 수행할 수 있다는 것이다.

#### 4. Compare-and-set
이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다.
하지만 데이터베이스가 WHERE 절이 오래된 스냅숏으로 부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다.

#### 5. 충돌 해소와 복제
복제가 허용된 데이터베이스의 갱신 손실 방지는 다른 차원의 문제이다.
잠금과 compare-and-set은 데이터베이스의 최신 복사본이 하나만 있다고 가정하나, 다중 리더나 리더 없는 복제는 이렇지 않기 때문에 사용이 불가능하다.

대신 한 값에 대해 여러 개의 충돌된 버전(형제(sibling))을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것이다.

<br>

### 쓰기 스큐와 팬텀
더티 쓰기나 갱신 손실보다 더 오묘한 쓰기 문제들이 있다.

#### 쓰기 스큐
두 트랜잭션이 두 개의 다른 객체를 갱신하였으나, 결과적으로 비지니스 도메인 데이터의 일관성이 지켜지지 않는 경우.
데이터베이스 객체 수준의 쓰기 관련 문제는 없으나, 엄연한 충돌이자 경쟁조건이다.
또한 더티 쓰기나 갱신 손실보다 데이터베이스 시스템의 도움을 받기 어렵다.
* 여러 객체과 관련되므로 원자적 단일 연산은 도움이 되지 않는다.
* 일부 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 도움이 되지 않는다.
* 어떤 데이터베이스에는 여러 객체에 걸친 규약으로 완화할 수 있다.
* 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것을 차선택으로 선택할 수 있다.

어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.
스냅숏 격리 읽기는 전용 질의에선즌 팬텀을 회피하지만, 읽기 쓰기 트랜잭션에서는 팬텀이 쓰기 스큐의 까다로운 문제를 발생시킬 수 있다.

#### 충돌 구체화
트랜잭션이 의존하는 로우자체가 없는 경우는 명시적인 잠금조차 사용할 수 없다.
이를 위해 충돌의 대상을 객체로 구체화 하는 방법을 선택할 수 있다.
하지만 충돌을 구체화하는 방법을 알아내기 어렵고, 이런 내용이 애플리케이션 레이어에 드러나는 것이 적절하지 못하다.
그리고 좋은 대안으로 직렬성 격리 수준이 존재한다.

<br>
<br>

## 직렬성
### 실제적인 직렬 실행
### 2단계 잠금
### 직렬성 스냅숏 격리
