# chapter 3. 저장소와 검색

### 데이터베이스를 강력하게 만드는 데이터 구조
- Log: Append-Only DataFile
- 색인: 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해 다른 데이터 구조로 관리하는 데이터
  - 색인의 Trade-Off: Write 성능 하락, more data, Read 성능 상승

#### 해시색인
키를 데이터 파일의 바이트 오프셋에 매핑해 해시맵을 유지
- 특정 사이즈의 세그먼트로 로그를 나누고, 특정 사이즈에 도달하면 컴팩션 수행
  - 컴팩션: 중복된 키를 버리고 각 키의 최신값만 유지
  - 키를 삭제하려면 툼스톤 레코드를 추가 ex) value=null
  - 해시테이블은 메모리에 저장해야 하기 떄문에 키가 너무 많으면 DISK IO가 많이 발생하는 문제
  - Range Query하기 어렵다.

#### SS테이블과 LSM트리
- SSTable: Sorted String Table
- SSTable로 세그먼트를 구성하면
  - 파일에서 특정 키를 찾기 위해서 모든 키의 색인을 메모리에 유지할 필요가 없다.
    - 메모리에는 sparse index, 각 세그먼트의 시작만 저장해두면 어디 세그먼트를 찾아가면 될지 찾을수 있음.
- SSTable의 데이터를 키로 정렬하려면?
  - Write시에 인메모리 balanced tree에 추가 "memtable"
  - memtable의 사이즈가 임계점을 넘기면 SSTable 파일로 디스크에 기록 - balanced tree로 key가 이미 정렬되있음. 
  - Read시에 memtable 뒤지고, 최신순으로 SSTable 세그먼트를 뒤지면서 찾는다.
  - 병합과 컴팩션 과정을 백그라운드에서 수행 

#### B트리
- depth: 항상 O(logN)
- Insert 시에, 임계점을 넘기면 여러 페이지에 대해 덮어쓰기를 해야 하는데, 이때 고아페이지가 발생할수 있다. 이를 방지하기 위해 WAL(Write-ahead log)를 추가

#### B트리와 LSM 트리 비교
보통 LSM 트리가 쓰기에서 더 빠르고, B 트리는 읽기에서 더 빠르다

##### LSM 트리의 장점
- 쓰기 증폭(Write amplification)이 BTree보다 더 낮다
- 압축률이 더 좋다
 
##### LSM 트리의 단점
- 컴팩션 과정이 읽기ㅡ, 쓰기 성능에 영향을 줄수 있다.
- 컴팩션 시 높은 쓰기 처리량이 발생한다. (디스크의 대역폭 문제)
- 컴팩션이 유입 쓰기 속도를 따라갈 수 없는 경우, 세그먼트 수가 계속 증가하고, 읽기시 더 많은 세그먼트 파일을 읽어야 해서 성능 하락
- B트리는 각 키가 색인의 한곳에만 존재하지만, LSM 트리는 여러곳에 존재 할수 있다. => 강력한 트랜잭션 시맨틱을 제공하기 어렵다.

#### 기타 색인 구조
Value의 구성
- 참조: 실제 데이터의 참조만 저장 
- Clustered Index: 실제 레코드의 모든 데이터를 저장
  - Mysql InnoDB 엔진의 경우, Primary key는 clustered index, secondary index는 primary key를 참조
- Covering Index: 레코드의 일부 데이터만 저장

##### 다중 칼럼 색인
- 여러 컬럼을 같이 묶어서 색인
  - RGB, location 등에서 사용

### 트랜잭션 처리나 분석?
- OLTP: 실제 서비스에 사용
- OLAP: 데이터 분석에 사용 - OLTP와 분리하기 위해 별도의 데이터웨어하우스를 운용한다. 

#### 데이터 웨어하우징
- 데이터웨어하우스: OLTP작업에 영향을 주지 않고, 마음껏 질의할수 있는 별도의 데이터베이스
- ETL(Extract-Transform-Load): 데이터웨어하우스로 데이터를 적재하는 과정
- 
#### 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마
- 별 모양 스키마: Fact Table로부터 dimension table 참조
- 눈꽃송이 모양 스키마: 더 정규화 한것.

### 칼럼 지향 저장소
로우별로 저장하는 것이 아니라, 칼럼별로 데이터를 저장. 질의에 사용되는 칼럼만 읽으면 되서 효율적

#### 칼럼 압축
한 칼럼에는 같은 타입의 데이터가 저장되기 때문에 압축에 용이 

#### 칼럼 저장소와 순서 정렬
각 칼럼을 독립적으로 정렬할 수 없다.
- 순서대로 정렬: 컬럼의 우선순위에 따라 정렬 
- 복제 데이터를 다른 방식으로 정렬해서 저장. 질의 처리시, 제일 적합한 버전을 사용

#### 집계: 데이터 큐브와 구체화 뷰
- 구체화 집계: materialized aggregate
- 구체화 뷰 : materialized view
  - aggregation data에 대해서 미리 계산해서 저장