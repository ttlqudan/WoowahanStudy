# 파트2. 데이터 시스템의 기초

# 3장. 저장소와 검색
- 데이터베이스가 어떻게 저장과 검색을 다루는지
- 트랜잭션 처리 최적화(OLTP)와 분석 최적화(OLAP)의 차이
- 작업 별 적절한 저장소 엔진


- 데이터 구조에 따른 저장소 엔진 종류
  - 로그 구조(log-structured) 계열
  - 페이지 지향(page-oriented) 계열

- 효율적인 탐색을 위해 필요한 데이터 구조
  - 색인
    - 부가적인 메타데이터를 두어, 원하는 데이터를 탐색하는 데 도움을 줌
    - 추가적인 데이터를 유지보수해야하기 때문에, 쓰기 시 오버헤드 발생
    - 읽기 성능을 향상시키기 위해 사용
    - 애플리케이션의 전형적인 질의 패턴을 활용해 적절한 색인을 선택해야함

- 해시 색인
  - 사전 타입과 유사하고, 보통 해시 맵으로 구현
  - 데이터 증가에 따라 색인 또한 비례해 늘어나게 될 것이고, 결국 디스크 공간이 부족해질 것
  - 디스크 공간 부족 문제를 해결하는 방법
    - 특정 크기의 세그먼트로 로그를 나눠 해결함
    - 특정 크기에 도달하면 세그먼트 파일을 닫고 새 세그먼트 파일에 쓰기를 수행함
    - 이후 세그먼트 파일들에 대해 **컴팩션(compaction)**을 수행
    - 컴팩션
      - 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것
    - 컴팩션으로 인해 각 세그먼트를 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 가짐
      - 키 값을 찾을때 최신 세그먼트 해시 맵을 먼저 확인함
      - 키가 없다면 두 번째 최신 세그먼트 등을 확인함
      - 병합 과정을 통해 세그먼트 수를 적게 유지하기 때문에 조회 시 여러 해시 맵을 확인하지 않아도 됨
    - 추가 전용 로그
      - 순차적인 쓰기 작업이기에 보통 무작위 쓰기보다 훨씬 빠름
      - 불변성으로 인해 동시성과 고장 복구가 간단함
        - 예시 : 값을 덮어쓰는동안 데이터베이스가 죽어도 이전 값과 새로운 값을 포함한 파일을 나누어 남겨둬 쉽게 복구 가능
      - 시간이 지남에 따라 조각화되는 문제를 피할 수 있음
    - 제약사항
      - 메모리에 저장해야 하므로 키가 너무 많으면 안됨
      - 범위 질의(range query)에 비효율적임, 모든 개별 키를 조회해야 하기 때문

- SS(Sorted String Table)테이블과 LSM(Log-Structured Merge-Tree) 트리
  - SS 테이블
    - 키-값 쌍을 키로 정렬
    - 각 키는 각 병합된 세그먼트 파일 내에 한 번만 나타나야 함
    - 장점(해시 색인 대비)
      - 세그먼트 병할이 간단하고 효율적임
      - 파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음
      - 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전 압축해두어, 읽기 시 블록 단위로 탐색할 수 있음.
      - 이는 탐색 효율화와 더불어 디스크 공간과 I/O 대역폭까지 줄여줌
  - LSM 트리
    - LSM 저장소 엔진
      - 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진

- 성능 최적화
  - 성능을 악화 시키는 접근들
    - LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있음
      - 키가 존재하지 않는 것을 확인하기 위해 가장 오래된 세그먼트까지 확인해야 하기 때문
  - 이런 접근에 대한 최적화 방안
    - 블룸 필터
      - 집합 내용을 근사한 메모리 효율적 데이터 구조
      - 데이터 존재 유무 확인 작업의 복잡도를 낮춰줌
    - SS테이블을 압축,병합하는 순서와 시기를 결정하는 전략
      - 크기 계층 컴팩션
        - 상대적으로 새롭고 작은 테이블을 오래되었고 큰 테이블에 연이어 병합
      - 레벨 컴팩션
        - 키 범위를 더 작은 테이블로 나누고 오래된 데이터는 개별 레벨로 이동시켜 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용함

- B 트리
  - 4KB(때론 더 큰)의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기/쓰기 수행
  - N개의 키를 가진 B트리의 깊이는 항상 O(log N), 대부분의 경우 깊이는 3~4단계로 충분함
    - 분기 계수 500의 4KB 페이지의 4단계 트리는 256TB까지 저장 가능

- 신뢰할 수 있는 B트리
  - 데이터베이스 고장 시 스스로 복구할 수 있도록 만들어야 함
    - 디스크 상에 쓰기 전 로그(write-ahead log, WAL)(재실행 로그(redo log)) 데이터 구조를 추가해 구현
  - 쓰기 전 로그
    - 변경 내용을 적용하기 전에 모든 변경 사항을 기록하는 추가 전용 파일
    - 고장 이후 복구 시 일관성 있는 상태로 다시 복원하는데 사용함

- B 트리 최적화
  - 페이지 덮어 쓰기와 WAL 유지 대신 쓰기 시 복사 방식(copy-on-write scheme)을 사용
    - 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가르킴. 동시성 제어에도 유용
  - 키를 축약하면 공간도 절약할 수 있고, 이는 트리 깊이 수준도 낮추는 효과를 얻음

- B 트리와 LSM 트리 비교
  - LSM은 쓰기가 더 빠르고, B트리는 읽기가 더 빠르다
    - LSM 트리 읽기가 더 느린 이유는 각 컴팩션 단계에 있는 여러 데이터구조와 SS테이블을 확인해야 하기 때문
  - LSM 트리 장점
    - 쓰기 시 여러 페이지를 덮어쓰지 않고 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문에 처리량을 높게 유지할 수 있다
    - 압축률이 좋고, 주기적으로 파편화를 없애기 때문에 저장소 오버헤드가 낮다
  - LSM 트리 단점
    - 컴팩션 작업의 오버헤드 때문에 읽기 쓰기 성능에 영향을 줄 수 있고, 이는 곧 성능 예측을 어렵게 만든다
    - 하나의 키가 여러 세그먼트에 존재할 수 있다. 
      - 따라서, 트랜잭션 시맨틱을 제공하는 데이터베이스에는 LSM 대신 B 트리를 사용한다

- 트랜잭션 처리, 분석
  - 온라인 트랜잭션 처리(OnLine Transaction Processing, OLTP)
    - 레코드는 사용자 입력을 기반으로 삽입되거나 갱신됨
  - 온라인 분석 처리(OnLine Analytic Processing, OLAP)
    - 데이터 분석 목적 
    - 원시 데이터가 아닌 많은 수의 레코드를 스캔해 레코드당 일부 칼럼만 읽어 집계나 통계

- 컬럼 지향 저장소
  - 모든 값을 하나의 로우에 함께 저장하지 않고, 각 칼럼별로 모든 값을 함께 저장함
  - 질의에 사용되는 칼럼만 읽고 구분 분석하면 되어 작업량을 줄일 수 있음
  - 데이터 압축에 적합하여 디스크 처리량도 줄일 수 있음
  - 다양한 질의는 서로 다른 정렬 순서의 도움을 받으므로 같은 데이터를 다양한 방식으로 정렬, 저장해 활용할 수 있음 
  - 로우 지향 저장소 대비 읽기 성능이 유리하다
  - 제자리 갱신(update in place) 불가능

* 키워드
    - 블룸 필터, OLTP, OLAP, 데이터 웨어하우스
    - https://namu.wiki/w/블룸%20필터