# chapter 3. 저장소와 검색

### 1. 들어가면서

- 데이터베이스가 수행하는 가장 기본적인 기능 2가지

  - 데이터 저장
  - 저장한 데이터에 대한 요청이 있으면 그 데이터 다시 제공

- 데이터베이스가 내부적으로 검색과 저장을 하는 과정을 애플리케이션 개발자가 주의해야되는 이유
  - 대개 애플리케이션 개발자는 DB 엔진을 밑바닥부터 빌드하기보다, 비즈니스 상황에 적합한 엔진을 선택해서 작업함.
  - 특정 상황에 대한 작업부하 (Workload)에 DB 퍼포먼스를 높이면, 상황에 맞는 엔진을 선택해야하기 때문.

### 2. 데이터베이스를 강력하게 만드는 구조

- 가장 간단한 DB 구조 예시

```bash
#!/bin/bash

db_set(){
  echo "$1,$2" >> database
}

db_get(){
  grep "$1^," database | sed -e "s/^$i, //" | tail -n 1
}
```

- 일반적으로 파일 추가 기능은 매우 효율적인 작업이라, 간단한 작업에 대해서 성능이 꽤 좋게 나옴 (`db_set`)

  - 많은 DB는 Append-only인 데이터 파일 로그 사용함 (ex. redis)

- 반면 `db_get` 함수는 성능이 나쁨. key를 찾을 때까지 저장된 데이터 계속 순회해야함.

  - 검색 비용이 `O(N)` 으로 수렴.

- 특정 키를 보다 효율적으로 찾는 방법 : 색인 (index)

  - 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것. 메타 데이터가 이정표 역할을 해서 원하는 데이터를 찾는데 도움을 줌.

  - 책을 펼치면 앞머리에 목차(Table of Content)가 있는 것과 같은 원리.

  - 색인은 기본 데이터 (primary data)에서 파생된 추가적인 구조.

  - 색인 자체는 DB 성능에 영향을 주진 않으나, 쿼리 성능에는 영향 줌.

  - 추가적인 구조의 유지 보수는 특히 쓰기 과정에서 오버헤드 발생. 예를 들어 단순 파일 추가 작업을 능가하는 쓰기 작업의 성능은 찾기 어려움.

  - 데이터 쓰기를 할 때마다 색인도 갱신되기 때문에 쿼리 성능에 영향 갈 수 밖에 없음.

  - Trade-off: 색인을 설정하면 읽기 쿼리 속도가 올라가나 쓰기 쿼리 속도가 내려감.

    - 이것 때문에 DB가 자동으로 index 설정 안하고, 애플리케이션 개발자 판단하에 수동 index 적용됨.

### 3. 해시 색인

- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵 유지하는 전략을 예제로 듦.
- 새로운 키-값 쌍을 추가할 때마다 방금 저장한 데이터 오프셋을 반영하기 위해 해시맵도 갱신함.
- 값을 조회하려면 해시맵에서 데이터 파일의 오프셋을 찾아 위치를 찾고 값을 읽음.
- 이 방식은 각 키의 값이 자주 갱신되는 상황에서 사용하기 적합함. (비트 캐스크, 리악의 DB 엔진)

  - 키당 쓰기 수가 많으나 메모리에 모든 키 관리 가능.

- 그러나 파일에 계속 추가만 한다면, 결국 디스크 공간 부족으로 연결됨.

  - 특정 크기의 세그먼트(segment)로 로그를 나누는 방식이 좋은 해결책.
  - 세그먼트 파일들에 대한 컴팩션(Compaction) 유지 가능. 즉, 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것.
  - 컴팩션 수행 시, 여러 세그먼트 병합하며 새로운 세그먼트 생성함 (세그먼트가 쓰여진 후에는 변경이 불가함.)
  - 컴팩션 수행 중에는 이전 세그먼트 접근 가능하지만, 완료 후에는 새로운 세그먼트 파일에 접근하게 전환.
    - 결국 나중 값이 이전 값보다 우선하는 상황
  - 병합하면서 세그먼트 수를 적게 유지하기 때문에, 많은 세그먼트 탐색이 필요 없음.

- 위 문제를 해결할 때 고려해야할 사항들

  - 파일 형식
  - 레코드 삭제
  - 고장(Crash) 복구
  - 부분적으로 레코드 쓰기
  - 동시성 제어

- 추가 전용 설계의 장점들

  - 순차 쓰기이므로 무작위 쓰기보다 성능 좋음.
  - 세그먼트 파일이 순차 쓰기 전용이거나 불변성이면 동시성과 고장 복구에 좋음
  - 오래된 세그먼트 병합은 시간이 지남에 따라 조각화 되는 데이터 파일 문제 피할 수 있음

- 해시 테이블 자체 제약사항

  - 인메모리 상황에서 키가 너무 많으면 문제됨.
  - 디스크가 가득 찼을 때 발생하는 확장비 + 충돌 해소를 피하기 위한 로직 필요.
  - range query에 부적합.

### 4. SS 테이블과 LSM 트리

#### 4.1 SS 테이블

- 키-값의 쌍을 키를 기준으로 정렬하면서 각 키는 병합된 세그먼트 파일에서 한 번씩만 나타나야하는 것이 SS 테이블 (Sorted String)

  - 컴팩션이 이미 이를 보장하고, 세그먼트 병합은 Merge Sort와 유사.

- 키를 정렬하기 위해서는 레드 블랙 트리 또는 AVL 트리로 정렬된 순서를 통해 키 읽기 가능.

- 단, 디스크에 기록되지 않는 데이터는 (memtable)은 DB가 고장나면 데이터 손실이 되기 때문에 쓰기로 즉시 추가할 수 있게 분리된 로그를 디스크에 유지 필요.

  - 멤테이블을 SS 테이블로 기록하고 나서 로그 버리면 됨.

#### 4.2 LSM 테이블

- 정렬된 병합과 컴팩션 원리를 기반으로하는 DB 엔진을 LSM 저장소 엔진이라함. (Log-Structured Merge-Tree)
  - 루씬, 엘라스틱서치, 솔라 등에서 기반으로 하는 전문 검색 엔진.
- LSM 테이블 기본 개념은 연쇄적으로 백그라운드에서 SS 테이블을 병합하는 것

### 5. 성능 최적화

- 알고리즘 외의 많은 세부 사항들이 저장소 엔진을 잘 실행되도록 지원하고 있음.

  - 예: LSM 트리가 존재하지 않는 키를 찾느라 수행이 느릴 수 있음.
  - 이 때 블룸 필터(Bloom Filter)라는 것을 사용함.
  - 키가 DB에 존재하지 않는다고 알려주는 것.

- SS 테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략
  - 크기 계층 (Size-Tiered)와 레벨 컴팩션 (Level Compaction)

### 6. B 트리

- 가장 널리 쓰이는 것은 B 트리로 LSM 트리와는 구조가 많이 다름.
- 고정 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 수행.
  - 예: PSQL의 default block size는 8k임.
- 디스가 고정 크기 블록으로 배열 되기 때문에 이런 설계는 근본적으로 하드웨어 설계와 더 밀접한 연관 있음.
- 하나의 페이지가 다른 페이지의 주소나 위치를 알고 있고, 그 페이지가 루트가 되어서 색인에서 키를 탐색.
- B 트리 자체가 계속 트리를 균형이 잡히게끔 유도하고, 트리 깊이는 항상 `O(log n)` 유지.
- 대부분의 DB에서 B 트리 깊이가 3 ~ 4단계 정도면 충분해서 많은 페이지 참조를 따라가지 않아도 됨.

### 7. 신뢰할 수 있는 B 트리 만들기

- 새로운 데이터가 디스크 상의 페이지에 덮어쓰더라도, 페이지 위치는 변경되지 않음. 즉, 페이지 데이터가 바뀌더라도 페이지를 가리키는 모든 참조는 유지됨.

  - LSM 트리와 대조되는 점.

- HDD이건, SSD이건 DB 고장 상황에서 스스로 데이터를 복원하게 하려면 WAL Log를 사용해야함 (Write-ahead log)

  - WAL은 페이지에 변경된 내용을 적용하기 전 모든 B 트리의 변경 사항을 기록하는 로그임.
  - DB 고장 이후 복구할 때 일관성 있는 상태를 B 트리에 유지시키기 위해 사용함.

- 멀티 스레드 상황에서 데이터 일관성이 깨질 수 있으므로 Latch 등으로 동시성 제어를 통해 데이터 구조 보호 가능.

### 8. B 트리 최적화

- WAL 대신 Copy-on-Write Scheme 사용
- 페이지에 전체 키를 사용하는 게 아니라 키 축약해서 사용.
- B 트리 구현 상에서 Leaf 페이지를 연속적으로 두게 유도. 트리가 커지면 순서 유지 어려움.
- 트리에 포인터 추가.
- 프랙탈 트리 사용? (프랙탈 구조와는 전혀 관계 없은 알고리즘 개념)

### 9. B 트리와 LSM 트리 비교

- 경험적으로 LSM 트리는 쓰기에서, B 트리는 읽기에서 더 빠르다고 알려짐.
  - LSM 트리에는 여러 SS 테이블과 데이터 구조 확인이 필요해서 B 트리보다 상대적으로 읽기가 느림.
