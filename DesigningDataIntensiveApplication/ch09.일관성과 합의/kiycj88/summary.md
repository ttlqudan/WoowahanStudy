# chapter 9. 일관성과 합의
이 장에서는 내결함성을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프토콜의 몇가지 예를 설명할 예정
8장에서 말한 모든 문제가 발생할수 있다고 가정
- 네트워크 문제
- 시간 문제
- 노드는 언제든 죽을 수 있다
  내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것

## 일관성 보장
복제 데이터베이스는 대부분 최소한 ***최종적 일관성*** 을 제공한다.
데이터 시스템이 제공할수 있는 더욱 강한 일관성 모델을 살펴볼 예정
- 선형성
- 이벤트 순서화 보장
- 분산 트랜잭션 원자적 커밋

강한 보장을 제공하는 만큼 트레이드오프로 성능이 나빠지거나 내결함성이 약해질 수 있다.


## 선형성
최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 쿼리를 날리면, 과거의 데이터가 미래에 다시 보이는 문제가 발생할 수 있다. ***선형성***은 데이터 복사본이 하나만 있다는 환상을 유지하는 것(최신성 보장)

### 시스템에 선형성을 부여하는 것은 무엇인가?
선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고, 결코 뒤로 가서는 안된다는 것!

### 선형성에 기대기
선형성이 중요한 요구사항이 되는 영역들
- 잠금과 리더 선출: 단일 리더 복제를 사용하는 시스템은 리더가 여러개(스플릿 브레인)가 아니라 진짜로 하나만 존재하도록 보장해야 한다.
- 제약 조건과 유일성 보장: 엄격한 유일성 제약 조건에는 선형성이 필요하다
- 채널 간 타이밍 의존성: 부가적인 통신 채널이 있을 때
    - 자신이 쓴 내용 읽기 같은 대안적인 방법이 있음

### 선형성 시스템 구현하기
선형성을 구현하는 가장 쉬운 방법은 replica를 하나만 두는 것. 근데 이러면 replica 장애 나면 끝.

복제 방법들에 대해서 선형성이 가능한지 비교
- 단일 리더 복제: 선형적이 될 `가능성이 있음
- 합의 알고리즘: 선형적
- 다중 리더 복제: 비선형적
- 리더 없는 복제: 아마도 비선형적
  - 성능을 포기하면, 선형성 읽기와 쓰기는 가능하지만, coampare-and-set은 어려움.

### 선형성의 비용
- 선형성은 유용한 보장이지만, 실제로 선형성을 잘 보장하는 시스템은 드물다. 왜냐하면 선형성을 제공해주기 위한 트레이드오프가 성능이기 떄문. 
- 네트워크 문제가 발생하지 않더라도 성능에는 영향을 무조건 준다. 

## 순서화 보장
전체 순서(total order): 어떤 것이 먼저인지 항상 판단이 가능한 것
부분 순서(partial order): 비교불가한 케이스가 있는 것.
### 순서화와 인과성
인과적으로 일관적(casually consistent): 시스템이 인과성에 의해 부과된 순서를 지킨다는 보장

#### 인과적 순서가 전체 순서는 아니다
- 선형성: 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.
- 인과성: 두 이벤트에 인과적인 관계끼 있으면 이들은 순서가 있지만, 이들이 동시에 실행되면 비교할수 없다. 인과성이 전체 순서가 아닌 부분 순서를 정의.

#### 선형성은 인과적 일관성보다 강하다.
- 선형성은 인과성을 내포한다. 선형성이 인과성을 보존하는 유일한 방법은 아니다. 선형성을 보장하기 위해서는 성능 손해를 유발하는데, 인과적 일관성은 성능 손해를 유발하지 않고 만족시킬 수 있다.
- 인과적 일관성은 네트워크 지연 때문에 느려지지 않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강한 것.
- 선형성이 필요해 보이는 많은 부분에서 실제로는 인과적 일관성을 필요로 하고, 이것은 더 효율적으로 구현이 가능.

#### 인과적 의존성 담기
- 인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다. like SSI

### 일련번호 순서화
- 순서를 일련번호나 타임스탬프를 써서 정할 수 있는데, 일 기준 시계는 신뢰성이 떨어지기 때문에, 논리적 시계를 이용할 수 있다. (모든 연산마다 증가하는 counter)
  - 전체 순서를 제공

#### 비인과적 일련번호 생성기
- 단일 리더가 없다면 일련번호를 생성할 수는 있는 여러 방법들이 있지만, 인과성에 일관적이지 않다.

#### 램포트 타임스탬프
- 인과성에 일관적인 일련번호를 생성하는 간단한 방법으로 소개되었음.
- Pair<counter, nodeId>
- counter가 같으면 nodeId가 큰 것이 더 큰 TimeStamp로 취급.
- 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최대값을 포함시킨다. 노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운터를 그 최댓값으로 증가 시킨다.

#### 타임스탬프 순서화로는 충분하지 않다
램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만, 분산 시스템의 여러 공통 문제를 해결하는데 아주 충분하지는 않다.

ex) 사용자명이 unique 해야하는데, 동시에 같은 사용자명으로 생성 요청을 할때, 한명은 성공하고, 다른 한명은 실패 해야한다.
- 이런 경우에 램포트 타임스탬프를 사용하면, 타임스탬프가 더 낮은 경우는 성공, 더 높은 경우는 실패하게 해야 하는데, 사후에 이렇게 처리를 할수는 있지만, 요청시점에 바로 결정하기는 어렵다.
- 여기서의 문제는 연산의 전체 순서가 모든 연산을 모은 후에야 알수 있다는 것. 연산 그 시점에는 알수가 없다.
- 사용자명에 대한 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서로는 충분치 않다. 언제 그 순서가 확정되는지 알아야 한다.

언제 전체 순서가 확정되는지 알아야 한다는 아이디어를 *** 전체 순서 브로드캐스트*** 의 주제에서 다룰 예정

### 전체 순서 브로드캐스트
전체 순서 브로드캐스트: 분산 시스템에서는 total order를 정하는 것
- 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술된다
- 두 가지 안정성 속성을 항상 만족해야 한다
  - 신뢰성 있는 전달: 어떤 메시지도 손실되지 않는다. 메시지가 한 노드에 전달되면 모든 노드에도 전달된다.
  - 전체 순서가 정해진 전달: 메시지는 모든 노드에 같은 순서로 전달된다.
전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야 한다.
  - 네트워크가 끊기면 re-try해서 네트워크 복구시에 전달되게 할 수 있다. (이때에도 순서는 보장되어야 한다)

#### 전체 순서 브로드캐스트 사용하기
- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현하고 있다.
- 데이터베이스 복제에 적합 - 신뢰성 있고, 순서가 보장되기 때문. ***상태 기계 복제(state machine replicatoin)*** 이라고 한다.
- 모든 노드에 같은 메시지를 같은 순서로 전달해야 하는 로그에 적합
- fencing token을 제공하는 locking 서비스 구현에도 유용


#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현
- 전체 순서 브로드캐스트는 비동기. 메시지가 고정된 순서로 신뢰성있게 전달되도록 보장하지만 ***언제*** 메시지가 전달될지는 보장하지 않는다.
- 선형성 쓰기를 보장하지만, 선형성 읽기는 보장하지 않는다. - 선형성 읽기를 보장하기 위해서는 몇가지 다른 방안들을 적용해야 한다

#### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현
- 선형성 저장소에서 atomic increment-and-get 연산을 수행하고, 메시지에 일련번호로 사용하면 됨
- atomic increment-and-get 연산을 만드는 것은 하나의 노드에서 구현하는 것은 쉽지만, 그 노드가 장애가 날때 복구하는 데에 어려움이 있다. 이를 고심하다 보면 필연적으로 합의 알고리즘에 도달하게 된다.

***선형성 compare-and-get(increment-and-get) 레지스터와 전체 순서 브로드캐스트는 둘다 합의와 동등하다고 증명할 수 있다(equivalent to consuensus)***

## 분산 트랜잭션과 합의
합의의 목적은 단지 여러 노드들이 뭔가에 동의하게 만드는 것

###### 노드가 동의하는 것이 중요한 예
- 리더 선출: 스플릿 브레인 방지
- 원자적 커밋: 멀티 노드에서의 원자적 커밋

먼저 원자적 커밋에 대해서 자세히 살펴볼 예정. 원자적 커밋을 해결하는 2단계 커밋 알고리즘(2PC)에 대해서 설명할 예정

### 원자적 커밋과 2단계 커밋(2PC)
원자성이란, 다 성공하거나 다 실패하도록 하는 것. 절반만 성공한 상태로 두지 않는 것


#### 단일 노드에서 분산 원자적 커밋으로
단일 노드에서 트랜잭션 커밋은 데이터가 디스크에 지속성 있게 쓰여지는 순서에 결정적으로 의존한다. 데이터가 먼저고 커밋 레코드는 그 다음이다. 

트랜잭션의 commit, abort를 결정하는 시점은 disk가 commit record write를 마치는 시점이다.

즉, commit을 atomic하게 만들어주는 것은 단일 장치(disk)다.

분산된 노드에서는 어떻게 해야 할까? => 2PC 

#### 2PC 소개
- 2PC: 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하는 알고리즘
- XA 트랜잭션: 애플리케이션 레벨에서 2PC를 사용하게 해주는 표준.

2PC는 commit/abort 과정이 두 단계로 나뉜다: prepare, commit
참여자: 트랜잭션에 참가하는 노드들
![2PC.png](2PC.png)
- coordinator가 각 노드들에게 prepare 요청을 보내서 커밋할수 있는 확인
  - 전부 yes라고 하면 commit
  - 하나라도 안된다고 하면 abort
- coordinator가 prepare 단계에서 yes 응답을 받으면, 최종적으로 commit or abort를 결정한다. 
  - coordinator는 추후 죽엇을 때 복구 하기 위해서 트랜잭션 로그에 이를 기록. ***commit point***
  - commit or abort 요청이 실패하면, 성공할때까지 영원히 재시도해야 한다.
    - 참여자가 죽으면 복구될때까지 계속 retry

##### 코디네이터 장애발생하면?

###### prepare 요청 전
참여자가 트랜잭션 abort할수 있다.

###### prepare 요청 후, 참여자가 응답하였고, commit or abort를 보내기 전
- 참여자는 코디네이터로부터 commit or abort 가 올때까지 기다릴 수 밖에 없다. 이 상태를 의심스럽다(in doubt) or 불확실하다(uncertain) 라고 한다.
- 완료할수 있는 유일한 방법은 코디네이터가 복구되기를 기다리는 것 뿐.

##### 3단계 커밋
- 2PC는 코디네이터가 복구하기를 기다리느라 멈출수 있다는 사실 때문에 블로킹 원자적 커밋 프로토콜이라고 불린다. 이론상으로는 노드에 장애가 나도 멈추지 않도록 원자적 커밋 프로토콜을 논블로킹하게 만들수 있다. 현실적으로 어려울 뿐
- 논블록킹 방식으로 3PC라는 방법이 제안되었는데, 완벽한 장애 감지기가 있어야 해서, 기약 없는 지연이 있는 네트워크에서 구현이 어렵기 때문에 2PC가 계속 쓰이고 있다.

### 현실의 분산 트랜잭션
분산 트랜잭션에 대한 평판이 엇갈린다.
- 중요한 안정성 보장 제공 vs 운영상의 문제를 일으키고 성능을 떨어뜨린다.
- 그래서 여러 클라우드 서비스들은 분산 트랜잭션을 구현하지 않는 선택을 한다
- 어떤 분산 트랜잭션 구현은 무거운 성능 손해를 수반(Mysql은 10배 이상?)

분산 트랜잭션의 종류
- 데이터베이스 내부 분산 트랜잭션: 같은 시스템에서 호환하기 때문에 아무 프로토콜이나 쓸수 있고, 최적화 할수 있다.
- 이종 분산 트랜잭션: 훨씬 더 어렵다
  - 다양한 시스템들이 강력한 방법으로 통합될 수 있게 한다. ex) exactly once 
  - But, 트랜잭션의 영향을 받는 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있을 때만 가능. - 11장에서 다시 살펴볼 예정

#### XA 트랜잭션
- 이종 기술에 걸친 2PC를 구현하는 표준 인터페이스
- 드라이버는 코디네이터가 참여자에게 prepare, commit, abort를 요청할수 있는 callback도 제공.
- 트랜잭션 코디네이터는 XA API를 구현한다. 보통 애플리케이션에서 실행되고, 로컬디스크에 있는 로그를 사용한다.

애플리케이션 서버가 죽으면 코디네이터도 같이 사라지고, 참여자들은 의심스러운 상태에 빠지게 된다. 애플리케이션이 다시 재시작이 되어야지 계속 진행이 가능하다.

위와 같은 문제가 발생하였을 때, 참여자 데이터베이스는 계속 lock을 걸고 있어야 한다. 코디네이터가 다시 재시작 될떄까지.. 그동안 lock걸린 record를 변경할수가 없다.

이 문제를 해결하는 유일한 방법은 관리자가 수동으로 트랜잭션 commit, rollback 하는 것이다.

여러 XA 구현에서는 의심스러운 상태의 트랜잭션을 commit할지 abort할지 일방적으로 결정할수 있도록 하는 기능을 제공.

##### 분산 트랜잭션의 제약
- 코디네이터가 단일 장비에서 실행되면, 코디네이터가 Single Point of Failure(SPOF)가 될수 있다.
- 코디네이터가 애플리케이션 서버에서 실행되면, stateless 가 아니라 stateful이 되어서 애플리케이션 노드 자체를 계속 사용해야 됨.
- 광범위한 데이터 시스템과 호환되어야 하므로 최소 공통분모가 될 필요가 있다. 
- 분산 트랜잭션은 장애를 증폭시키는 경향이 있다. 이는 내결함성을 지닌 시스템을 구축하려는 목적에 어긋난다.

이런 제약사항들을 회피하고 이종 분산 트랜잭션의 고통 없이 같은 것을 달성할 수 있게 허용해주는 대안적인 방법이 있다 ***합의***

### 내결함성을 지닌 합의
합의 문제는 "하나 또는 그 이상의 노드들이 값을 제안할 수 있고 합의 알고리즘이 그 값중 하나를 결정한다"고 형식화된다.

합의 알고리즘은 다음 속성을 만족해야 한다.
- 균일한 동의: 어떤 두 노드도 다르게 결정하지 않는다.
- 무결성: 어떤 노드도 두번 결정하지 않는다.
- 유효성: 한 노드가 값 v를 결정하면 v는 어떤 노드에서 제안된 것이다.
- 종료: 죽지않은 모든 노드는 결국 어떤 값을 결정한다.
  - 합의 시스템 모델은 노드가 죽으면 결코 돌아오지 않는다고 가정한다.
  - 최소한 과반수의 노드가 정상 동작해야 한다(정족수)
- 비잔틴 결함이 없다고 가정

#### 합의 알고리즘과 전체 순서 브로드캐스트
잘 알려진 내결함성을 지닌 합의 알고리즘: 뷰스탬프 복제(Viewstamped Replication), 팍소스(Paxos), 라프트(Raft), 잽(Zap)

이 알고리즘 중 대다수(Viewstamped Replication, Raft, Zap)는 값의 순차열에 대해 결정해서 전체 순서 브로드캐스트 알고리즘을 만든다. 전체 순서 브로드캐스트를 하려면 모든 노드에게 정확히 한 번, 같은 순서로 전달되어야 한다. 
이것은 합의를 몇회 하는 것과 동일하다. 각 회마다 노드들은 다음에 보내기 원하는 메시지를 제안하고 전체 순서 상에서 전달될 다음 메시지를 결정한다.

그래서, 전체순서 브로드캐스트는 합의를 여러번 반복하는 것과 동일하다.(각 합의 결정이 하나의 메시지 전달에 해당)

#### 단일 리더 복제와 합의
단일 리더 복제가 본질적으로 전체 순서 브로드캐스트라 할 수 있는데, 단일 리더 복제는 리더가 죽었을 때가 문제가 된다. 

#### 에포크 번호 붙이기와 정족수
앞서 말했던 합의 프로토콜은 내부적으로 리더를 사용하지만 리더가 유일하다고 보장하지는 않는다. 대신 그들은 더 약한 보장을 할수 있다.

에포크 번호(Epoch Number)를 정의하고 각 에포크 내에서는 리더가 유일하다고 보장한다.

1. 현재 리더가 죽었다고 생각될때마다 새 노드를 선출하기 위해 노드 사이에서 투표가 시작
2. 이 선출은 에포크 번호를 증가시키며 따라서 에포크 번호는 전체순서가 있고 단조 증가한다
3. 두 가지 다른 에포크에 있는 두 가지 다른 리더 사이에 충돌이 있으면, 에포크 번호가 높은 리더가 이긴다.
    - 리더가 뭔가를 결정하도록 허용하기 전에 충돌되는 결정을 할지도 모르는 에포크 번호가 더 높은 다른 리더가 없는지 먼저 확인해야 하는데, 리더는 내리려고 하는 모든 결정에 대해 제안된 값을 다른 노드에게 보내서 노드의 정족수가 찬성한다고 응답하기를 기다려야 한다


#### 합의의 제약
- 전체 순서 브로드캐스트를 제공하고, 내결함성 있는 방식으로 선형성 원자적 연산을 구현 할수 있다.
- 제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제 -> 성능 문제
- 엄격한 과반수가 동작하기를 요구 -> 비용 문제
- 투표에 참여햐는 노드 집합이 고정되어있다고 가정하고, 동적 멤버십 확장은 허용하지만 정적 멤버십보다 훨씬 어렵다
- 네트워크 문제에 특히 민감


### 멤버십과 코디네이션 서비스
- 잘 알려진 코디네이션 서비스로는 "Zookeeper", "etcd" 가 있다.
- 주키퍼와 etcd는 완전히 메모리 안에 들어올 수 있는 작응 양의 데이터를 보관하도록 설계됐다. 이 소량읟 ㅔ이터는 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 사용해 모든 노드에 걸쳐 복제된다.

사용 예
- 작업을 노드에 할당하기
  - 리더 장애 시, 리더 선발
  - 작업 스케줄러, 상태 저장 시스템 등
  - 파티션 리밸런싱
  - 보통 주키퍼로 관리되는 데이터의 종류는 매우 느리게 변한다. ex) "특정 IP의 노드가 파티션 n의 리더다"
- Service Discovery
- 멤버십 서비스
  - 클러스터에서 어떤 노드가 active 상태인지 결정
