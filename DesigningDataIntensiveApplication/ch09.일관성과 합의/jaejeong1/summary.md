# Chapter 9. 일관성과 합의

## 개요
- 분산 시스템에서는 많은 것들이 잘못될 수 있고, 이에 대한 가장 간단한 대응은 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것
- 이 방법이 어렵다면, 결함이 발생해도 서비스는 올바르게 동작하게 할 방법을 찾아야 한다
- 내결함성을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜을 살펴볼 것
- 가장 좋은 방법 : 유용한 보장을 해주는 범용 추상화를 찾아 구현하고, 애플리케이션에서 이에 의존하게 하는 것 (예시 : 트랜잭션, 합의)

## 일관성 보장
- 복제 DB는 대부분 최소한 최종적 일관성을 보장함
- 이 시점이 언제가 될지는 알 수 없고, 그 전까지 읽기는 뭔가를 반환할 수도, 아무것도 반환하지 않을 수도 있다
- 최종적 일관성은 단일 스레드 동작과 다르므로, 애플리케이션 개발자에게 어렵다
- 약한 보장만 제공하는 DB를 다룰 때는 그 제한을 계속 알아야 하고 너무 많은 것을 가정하면 안된다
- 최종적 일관성의 에지 케이스는 시스템 결함이 있거나 동시성이 높을 때만 분명히 드러난다

## 선형성
- DB 복제본이 여럿이 아닌 하나만 있다면 복제 지연 걱정없이 일관성을 기대할 수 있지 않을까?
- 이것이 선형성을 뒷받침하는 아이디어, 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 연산을 원자적인 것처럼 보이게 만드는 것
- 최신성 보장(recency guarantee)
- 네트워크 지연의 변동 때문에 클라이언트는 DB가 언제 자신의 요청을 처리했는지 정확히 알지 못한다
- 새로운 값을 반환(읽기나 쓰기)한 적이 있은 후에는 모든 후속 읽기도 반드시 새로운 값을 반환해야한다

### 선형성과 직렬성의 차이
- 직렬성 : 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성
  - 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해줌
- 선형성 : 개별 객체에 실행되는 읽기와 쓰기에 대한 최신성 보장
  - 연산을 트랜잭션으로 묶지 않아 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다

### 선형성에 기대기
- 선형성이 중요한 요구사항이 되는 영역들
- 잠금과 리더 선출 : 아파치 주키퍼나 etcd같은 코디네이션 서비스
- 제약 조건과 유일성 보장 : RDB PK 등
- 채널 간 타이밍 의존성 : 이미지 변경 서비스
  - 이미지 저장보다 메시지 큐가 더 빠르면 문제 발생. 선형성 보장 필요

### 선형성 구현
- 진짜 데이터 복사본 하나만 사용하면 결함을 견뎌낼 수 없고 SPOF 밖에 안된다
- 가장 흔한 방법은 복제를 사용하는 것

### 선형성과 정족수
- 다이나모 스타일 복제를 하는 리더 없는 시스템(리악, 카산드라 등)은 선형성을 제공하지 않는다라고 봐야함

### 선형성의 비용
- 네트워크가 끊기면 선형성과 가용성 사이에서 선택해야 한다
- 다중 리더가 아니라면 네트워크 끊길 시 대응 불가능

### CAP 정리
- 애플리케이션이 선형성을 요구하지 않는다면 각 복제 서버가 다른 복제 서버(다중 리더 등)와 연결이 끊기더라도 독립적으로 요청을 처리해 쓰기를 처리할 수 있다
- 선형성을 요구한다면 네트워크 연결이 끊긴 동안은 요청을 처리할 수 없다
- CAP는 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는게 좋다
- 선형성을 제공하는 더욱 빠른 알고리즘은 존재하지 않지만 완화된 일관성 모델은 훨씬 더 빠를 수 있다
- 이 트레이드오프를 선택하는 것이 중요하다

## 순서화 보장
- 선형성 보장을 위해 순서화는 중요한 근본적 아이디어일 수 있다
  - 단일 리더 복제에서 리더의 주 목적은 복제 로그에서 쓰기의 순서를 결정하는 것
  - 직렬성은 트랜잭션들이 마치 어떤 일련 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것
  - 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서(순서)를 부여하는 시도

### 순서화와 인과성
- 순서화는 인과성을 보존하는데 도움을 줌
- 인과성은 이벤트에 순서를 부과한다. 이런 연쇄는 시스템에서 인과적 순서, 무엇이 무엇보다 먼저 일어났는가를 정의한다
- 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적(causally consistent)라고 한다
  - 예시 : 스냅숏 격리

### 인과적 순서가 전체 순서는 아니다
- 선형성 : 연산의 전체 순서를 정할 수 있다
- 인과성 : 전체가 아닌 부분 순서를 정할 수 있다
- 선형성은 인과성을 내포하는 개념
- 시스템을 선형적으로 만들 경우 특히 네트워크 지연이 크면 성능과 가용성에 해가 될 수 있다
- 이를 절충해야된다, 대부분 필요한 건 선형성이 아닌 인과적 일관성
- 인과적 순서를 결정하기 위해 DB는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다

## 일련번호 순서화
- 인과성은 중요한 개념이지만 모든 인과적 의존성을 추적하는 것은 실용성이 떨어짐
- 일련번호나 타임스탬프를 써서 이벤트의 순서를 정하자
  - 인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다
- 단일 리더가 없다면 연산에 사용할 일련번호를 생성할 방법이 명확해보이지 않는다
  - 비인과적 일련번호 생성기 : 각 노드가 미리 예약한 비트내에서 고유한 일련 번호 생성
  - 인과성에 일관적이지 못함
  - 여러 노드 간 연산 순서를 올바르게 담지 못하기 때문
    - 초당 연산수, 시계 스큐에 종속적인 이유 등
- 램포트 타임스탬프는 인과성에 일관적인 일련번호를 생성할 수 있다
  - 각 노드는 고유 식별자를 갖고 각 노드는 처리한 연산 개수를 카운터로 유지
  - 램포트 타임스탬프는 (카운터, 노드 ID)의 쌍
  - 두 노드는 떄떄로 카운터 값이 같을 수 있지만 타임스탬프에 노드 ID를 포함시켜서 각 타임스탬프는 유일하게 된다
  - 핵심 아이디어 : 모든 노드/클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킨다
  - 노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운터를 그 최댓값으로 증가시킨다
- 하지만 당장 유일성 보장이 필요할 때(사용자명에 대한 유일성 제약 조건 등)는 위 방법으로도 부족하다
- 언제 전체 순서가 확정되는지 알아야한다

### 전체 순서 브로드 캐스트
- 어려운 문제는 처리량이 단일 리더가 처리할 수 있는 수준을 넘어설 때 시스템을 어떻게 확장할 것인가와
- 리더에 장애가 발생했을 때 어떻게 장애 복구를 처리할 것인가이다
- 이 문제는 전체 순서 브로드캐스트나 원자적 브로드캐스트로 알려져 있다
- 신뢰성 있는 전달과 전체 순서가 정해진 전달을 만족한다
  - 어떤 메시지도 손실되지 않는다. 메시지가 한 노드에 전달되면 모든 노드에도 전달된다
  - 메시지는 모든 노드에 같은 순서로 전달된다
- 네트워크가 끊겼다 복구되어도 메시지는 결국 전달되야 하고, 올바른 순서여야 한다
- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다
- 메시지가 전달되는 시점에 그 순서가 고정됨

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현
- 전체 순서 브로드캐스트는 비동기적
- 전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 구현할 수 있다
- 이는 선형성 쓰기를 보장하지만 선형성 읽기는 보장하지 않는다

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현
- 선형성 레지스터를 증가시켜 얻은 숫자들은 틈이 없는 순열을 형성하고, 램포트 타임스탬프는 그렇지 않다. 이것이 핵심차이다
- 선형성 compare-and-set 레지스터와 전체 순서 브로드캐스터는 둘 다 합의와 동등하다고 증명할 수 있다

## 분산 트랜잭션과 합의
- 합의의 목적은 여러 노드들이 뭔가에 동의하게 만드는 것
  - 리더 선출, 원자적 커밋 등에 필요

### 원자적 커밋과 2단계 커밋(2PC)
- 단일 노드에서 트랜잭션 커밋을 데이터가 디스크에 지속성있게 쓰여지는 순서에 결정적으로 의존한다
- 트랜잭션 커밋/어보트 결정하는 핵심적 시점은 디스크가 커밋 레코드 쓰기를 마치는 시점이다
- 여러 노드가 관여하면 일부만 어보트 될 수 있는데, 커밋된 트랜잭션은 다시 취소할 수 없다(원자성 보장 위반)
- 보상 트랜잭션은 애플리케이션 관점 정확성을 위한 처리지, DB 관점에선 이것도 분리된 트랜잭션이다

### 2단계 커밋
- 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성, 모든 노드의 커밋/어보트 보장
- 단일 노드 트랜잭션에는 존재하지 않는 코디네이터를 사용함
- 애플리케이션이 커밋할 준비가 되면, 코디네이터가 1단계를 시작한다
  - 각 노드에 준비 요청을 보내 커밋할 수 있는지 물어본다
  - 그 후 코디네이터는 참여자들의 응답을 추적한다
  - 모든 참여자가 '네' 응답하면 코디네이터는 2단계에서 커밋 요청을 보내고 실제 일어난다
  - 누구라도 아니오 라고 하면 2단계에서 모든 노드에 어보트 요청을 보낸다

### 약속에 관한 시스템
- 2PC에는 두 개의 돌아갈 수 없는 지점이 있다
- 참여자는 네 에 투표할 때 나중에 분명히 커밋할 수 있을 거라고 약속한다
- 그리고 코디네이터가 한 번 결정하면 그 결정은 변경할 수 없다
- 이런 약속은 2PC의 원자성을 보장한다

### 코디네이터 장애
- 코디네이터가 죽거나 네트워크에 장애가 나면?
- 참여자가 네 에 투표한 후 발생하면 어보트할 수 없고, 단지 복구를 기다릴 수 밖에 없다
- 따라서, 코디네이터는 참여자들에게 커밋/어보트 요청을 보내기 전 디스크에 있는 트랜잭션 로그에 반드시 이를 써놔야한다

### 3단계 커밋
- 2단계 커밋은 2PC가 코디네이터 복구를 기다리느라 멈출 수 있다는 사실 떄문에 블로킹 원자적 커밋 프로토콜이라 불린다
- 이를 논블로킹하게 만들어 처리할 수 있지만 실제론 어렵다

### 현실의 분산 트랜잭션
- 2PC는 안전성을 보장하지만 성능이 매우 떨어짐

### 정확히 한 번 메시지 처리
- 메시지 전달이나 데이터베이스 트랜잭션 중 하나가 실패하면 둘 다 어보트 되고 메시지 브로커는 나중에 메시지를 안전하게 다시 전달 가능
- 메시지와 그 처리 과정의 부수 효과를 원자적으로 커밋함으로써 메시지가 결과적으로 정확히 한 번 처리되도록 보장할 수 있다

### 분산 트랜잭션의 제약
- 핵심 구현은 트랜잭션 코디네이터 자체가 일종의 DB여야 한다는 점
- 코디네이터가 단일 장비에서 실행되면 SPOF가 됨
- 2PC가 성공하려면 모든 참여자가 응답해야하는 문제가 있으므로, 이는 어떤 부분 하나라도 고장나면 트랜잭션이 실패하게 되고 결국 장애를 증폭시킴

### 내결함성을 지닌 합의
- 합의 알고리즘을 다음과 같은 특성을 만족해야 한다
  - 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다
  - 무결성 : 어떤 노드도 두 번 결정하지 않는다
  - 유효성 : 한 노드가 값을 결정하면 그 값은 어떤 노드에서 제안된 것이다
  - 종료 : 죽지 않는 모든 노드는 결국 어떤 값을 결정한다
- 대부분의 합의 알고리즘은 비잔틴 결함이 없다고 가정한다
- 노드가 프로토콜을 올바르게 따르지 않으면 안전성 속성이 꺠질 확률이 높다

### 멤버십과 코디네이션 서비스
- 멤버십 서비스
  - 클러스터에서 어떤 노드가 현재 살아있는 멤버인지 결정한다
  - 장애감지와 연결하면 노드들은 어떤 노드의 생사를 결정할 수 있다


## 정리
- 선형성의 목적 : 복제된 데이터가 오직 하나의 복사본만 있는 것처럼 보이게 하고 데이터에 대한 모든 연산을 원자적으로 만드는 것
- 네트워크 지연이 큰 환경에서 느리다는 단점이 강하게 부각된다
- 모든 연산을 하나의 전체 순서가 정해진 타임라인에 넣는 선형성과 달리 인과성은 더 약한 일관성 모델을 제공한다
- 인과적 일관성은 선형성의 코디네이션 오버헤드가 없고 네트워크 문제에 훨씬 덜 민감하다
- 인과적 순서를 담아내도(램포트 타임스탬프 등) 유일성 제약등 이 방법으로도 구현할 수 없는 것들이 있다
- 한 노드가 등록을 받아들이려면 다른 노드가 같은 처리를 하지 않고 있음을 알아야하고 이는 결국 합의가 필요해지는 상황을 야기한다
- 합의를 달성하는 것은 결정된 것에 모든 노드가 동의하고 결정을 되돌릴 수 없는 방식으로 뭔가를 결정한다는 뜻
- 합의를 쉽게 처리하려면 한 노드에 결정을 위임하면 되는데 이는 SPOF를 유발한다
- 주키퍼 같은 도구는 합의, 장애 감지, 멤버십 서비스를 위탁하는데 중요한 역할을 수행한다
- 합의로 환원될 수 있는 문제 중 하나를 원하고, 이것이 내결함성을 지니길 원한다면 주키퍼 같은 것을 쓰는 것이 현명하다