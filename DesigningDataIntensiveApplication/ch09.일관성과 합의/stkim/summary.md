# Chapter 9. 일관성화 합의

## 1. 들어가기 전에...

- 분산 시스템을 운영할 때는 많은 문제점이 발생할 수 있는데, 이 때 문제에 대응하는 가장 쉬운 방법은 전체 서비스가 실패하게 두고, 사용자에게 오류 메세지를 보여주는 것임.

- 서비스가 실패하게 두는 것이 싫다면, 내부 결함이 있더라도 견뎌내고 (tolerating), 서비스가 올바르게 동작할 수 있게 할 방법을 찾아야한다.

- 네트워크 패킷 손실, 노드 중단 등으로 분산 시스템에는 언제든 장애가 발생할 수 있다.

  - 범용 추상화 및 이에 의존하는 애플리케이션 설계가 필요함.

  - 대표적인 분산 시스템 에러에 대응하는 범용 추상화 아키텍처는 합의, 모든 노드가 어떤 것에 동의하게 만드는 것이다.

  - 주로 노드의 리더는 하나이고, 모든 노드가 리더가 누구인지 동의하는 게 중요함.

  - 두 노드가 서로 리더라고 생각하는 현상 -> 스플릿 브레인 (split brain)

## 2. 일관성 보장

- 복제 데이터베이스는 대부분 최소한 **최종적 일관성**을 제공한다.

  - 데이터 베이스에 쓰기를 멈추고 특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻임.

  - 바꿔 말하면 불일치는 일시적이고, 스스로 해소됨.

  - 하지만, 이는 곧 값을 쓰고 바로 읽으면 방금 작업한 값이 안보일 것이라는 뜻이기도함.

    - 즉, 약한 일관성 보장.

### 2.1 선형성

- 선형성을 뒷받침하는 아이디어 : DB 복제본이 하나만 있는 것처럼 구성해주면 훨씬 단순해지지 않을까?

  - 원자적 일관성 (atomic consistency)
  - 강한 일관성 (strong consistency)
  - 즉각 일관성 (immediate consistency)
  - 외부 일관성 (external consistency)

- 최신성 보장: 클라이언트가 쓰기를 성공적으로 완료하자마자 그 DB를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있어야 한다.

### 2.2 시스템에 선형성을 부여하는 것은?

- 분산 시스템 분야에서 동시에 같은 키 x는 레지스터라고 불린다

- 쓰기 연산과 시간이 겹치는 읽기 연산은 쓰기 전과 후 모두를 반환할 수 있다 -> 기대하는 바가 아니다

- 한 클라이언트의 읽기가 새로운 값을 반환하면 이후의 모든 읽기는 새로운 값을 반환해야 한다.

- 새로운 값이 쓰여지거나 읽히면 이후 실행되는 모든 읽기는 값이 다시 덮어쓰여질 때까지 새로운 값을 읽게 된다

### 2.3 선형성에 기대기

- 시스템이 올바르게 작동하기 위해 선형성이 필요한 영역들

  - 잠금과 리더 선출 : 시스템 리더가 여러 개가 아닌 한 개가 존재하도록 보장이 필요함.
  - 제약 조건과 유일성 보장 : DB에서 흔한 조건으로 사용자 한 명을 유일하게 식별할 수 있는 것.
  - 채널 간 타이밍 의존성 : 서로 다른 통신 채널에서 발생하는 데이터 불일치 이슈
    - 예: 파일 저장소 <-> 메세지 큐

- 선형성 시스템 구현하기
  - **선형성**의 정의 : 데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적.
  - 가장 쉬운 건 데이터 복사본 하나만 사용하는 거지만 결함에 취약
  - 5장의 복제 방법을 다시 보자
  - 단일 리더 복제 -> 선형적이 될 가능성이 있다.
  - 합의 알고리즘 -> 선형성 저장소를 안전하게 구현 가능
  - 다중 리더 복제 -> 비선형적
  - 리더 없는 복제 -> 아마 비선형적

### 2.4 선형성과 정족수

- 다이나모 스타일 모델에서 엄격한 정족수 -> 선형적인 것처럼 보이나, 하지만 네트워크 지연의 변동이 심하면 경쟁조건이 생긴다.

- 성능을 대가로 다이나모 스타일 정족수를 선형적으로 만들 수 있지만 선형성 compare-and-set 연산은 합의 알고리즘이 필요해 구현할 수 없다.

- 하지만 다이나모 스타일 복제를 하는, 리더없는 시스템은 선형적이지 않다고 보는 게 안전.

### 2.5 선형성의 비용

- 다중 데이터 센터에서 센터 사이 네트워크가 끊길 때 선형성과 가용성 사이에서 선택 필요함.

  - 각 센터의 내부 네트워크는 동작하고, 데이터센터끼리는 서로 연결이 안되는 상황을 가정.

- 다중 리더 DB -> 각 센터는 정상작동. 쓰기는 큐에 쌓였다 네트워크 복구 후 전달

- 단일 리더 -> 쓰기 & 선형성 읽기 모두 불가

- CAP 정리: 선형성이 필요없는 애플리케이션은 네트워크에 더 강인하다.

  - 일관성 (consistency)
  - 가용성 (availability)
  - 분단 내성 (partition tolerance)

- 근데 공식적인 CAP는 매우 범위가 좁아 시스템 설계할 때는 실용적 가치가 없다

- 선형성과 네트워크 지연

  - 현실에서 실제로 선형적인 시스템은 진짜 없다. 최신 다중코어 CPU의 램도 선형적이지 않음.

    - 하나의 cpu 코어에서 실행 중인 스레드가 메모리 주소 작성 후, 곧바로 다른 cpu 코어가 같은 주소를 읽으면 같은 값 읽을 것이라 보장 안됨.

  - 선형성을 제거한 이유는 내결함성이 아니라 성능 때문.
    - 선형성을 제공하는 것은 느리다.

## 3. 순서화 보장

- 선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작

- 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보이는 것이다

- 순서화는 되풀이된 주제이며 중요한 근본적인 아이디어일 수 있다.

- 5장의 단일 리더 복제에서 리더의 주 목적은 복제 로그에서의 쓰기의 순서를 결정하는 것

- 7장의 직렬성은 트랜잭션들이 마치 어떤 일련의 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것

- 8장에서 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서를 부여하려는 또 다른 시도

### 3.1 순서화와 인과성

- 순서화가 중요한 이유 중 하나: 순서화가 인과성을 보존하는데 도움을 주기 때문

- 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다

- 하지만 인과적 순서가 전체 순서는 아니다
  - 선형성: 연산의 전체 순서를 정할 수 있다
  - 인과성: 두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았으면 두 연산은 동시적이다. 전체 순서가 아닌 부분 순서만 정의한다
- 선형성은 인과적 일관성보다 강하다. 선형성은 일관성을 내포한다.
  - 또한 이 둘 사이를 절충할 수 있다
  - 대부분 필요한 건 선형성이 아니라 인과적 일관성
  - 인과적 의존성 담기 : 인과적 순서를 결정하기 위해 DB는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다

### 3.2 일련번호 순서화

- 인과성은 중요하지만 모든 인과적 의존성을 다 추적할 수는 없다. -> 일련번호나 타임스탬프를 써서 이벤트의 순서만 정하자
- 비인과적 일련번호 생성기
  - 각 노드가 미리 예약한 비트 내에서 자신만의 고유한 일련 번호 생성 -> 인과성에 일관적이지 않다
- 램포트 타임스탬프 : (카운터, 노드ID)의 쌍. 노드ID는 타임스탬프를 포함한다. 분산 시스템 분야 논문에서 가장 많이 인용됨.

  - 랜포트 타임스탬프는 인과성에 일관적이도록 보장하며 항상 전체 순서화를 강제한다
  - 타임스탬프 순서화는 유일성 보장을 만족하지 않는다

- 언제 전체 순서가 확정되는지 알아야 한다 -> 전체 순서 브로드캐스트의 주제

### 3.3 전체 순서 브로드캐스트

- 단일 리더가 처리하기 어어려운 수준을 넘어서면, 시스템을 어떻게 확장할 것인가 + 장애가 발생했을 때 어떻게 장애 복구할 것인가? -> 전체 순서 브로드 캐스트, 원자적 브로드캐스트

- 전체 순서 브로드캐스트: 보통 노드 사이에 메시지를 교환하는 프로토콜. 비공식적으로 두 가지 안전성 속성을 항상 만족해야 한다. 노드나 네트워크에 결함이 있더라도.

  - 신뢰성 있는 전달: 어떤 메시지도 손실되지 않는다. 메시지가 한 노드에 전달되면 모든 노드에도 전달된다

  - 전체 순서가 정해진 전달: 메시지는 모든 노드에 같은 순서로 전달된다

### 3.4 전체 순서 브로드캐스트

- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다
- 전체 순서 브로드캐스트는 DB 복제에 딱 필요한 것
- 직렬성 트랜잭션을 구현하는 데도 쓸 수 있다
- 메시지가 전달되는 시점에 그 순서가 고정 -> 타임스탬프 순서화보다 강하다
- 전체 순서 브로드캐스트는 로그를 만드는 방법 중 하나. 메시지 전달은 로그에 추가하는 것과 비슷
- 펜싱 토큰을 제공하는 잠금 서비스를 구현하는 데도 유용

### 3.5 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

- 체 순서 브로드캐스트는 비동기적이다

- 하지만 전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 구현할 수 있다

- 이는 선형성 쓰기를 보장하지만 선형성 읽기는 보장하지 않는다 (하려면 추가작업이 필요)

### 3.6 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

- 가장 쉬운 방법은 정수를 저장하고 원자적 increment-and-get 연상이 지원되는 선형성 레지스터가 있다고 가정

- 선형성 레지스터를 증가시켜 얻은 숫자들은 틈이 없는 순열을 형성한다는 점에서 램포트 타임스탬프와 다르다

- 선형성 compare-and-set 레지스터와 전체 순서 브로드캐스터는 둘 다 합의와 동등하다고 증명할 수 있다

## 4. 분산 트랜잭션 합의

- 비공식적으로 합의의 목적은 단지 여러 노드들이 뭔가에 동의하게 만드는 것. 하지만 대단히 미묘하고 선행지식이 많이 필요하다
- 노드가 동의하는 것이 중요한 상황은 무척 많다

  - 리더 선출 : 앞서 얘기한 스플릿 브레인으로 인해 데이터 비일관성 + 손실 발생 가능성 있음.
  - 원자적 커밋 : 모든 노드가 트랜잭션 결과에 동의하게 만들고, 뭔가 잘못되면 어보트/롤백하거나 모두 커밋됨.

- 합의 불가능성: 어떤 노드가 죽을 위험이 항상 있다면 합의에 이를 수 있는 알고리즘은 없다는 것을 증명한 것. 타임아웃을 쓸 수 있거나 노드의 죽음을 식별할 수 있다면 합의는 해결 가능해진다

- FLP 결과는 이론적으는 중요하지만 현실에서는 합의를 달성할 수 있다

  - FLP는 피셔, 린치, 패터슨이라는 사람 이름을 따서 지은 명칭임.

### 4.1 원자적 커밋과 2단계 커밋(2PC)

- 단일 노드에서 분산 원자적 커밋으로

  - 단일 DB노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현된다

  - 트랜잭션에 여러 노드가 관여할 경우, 단지 모든 노드에 커밋 요청을 보내고 각 노드에서 독립적으로 트랜잭션을 커밋하는 것으로는 충분치 않다

  - 일부만 어보트 될 수 있는데, 커밋된 트랜잭션은 다시 취소할 수 없다

- 2단계 커밋 소개

  - 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성: 모든 노드가 커밋or어보트되도록 보장
  - 2PC는 새로운 컴포넌트인 코디네이터를 사용
  - 애플리케이션이 커밋할 준비가 되면, 각 노드에 커밋할 수 있는지 묻고, 응답을 추적한다
  - 모든 참여자가 예쓰하면 2단계 커밋 요청을 보내고 실제 일어난다
  - 하나라도 노우하면 모든 노드에 어보트 요청을 보낸다

- 약속에 관한 시스템

  - 애플리케이션이 분산 트랜잭션 시작하려할 때 코디네이터에게 트랜잭션 ID를 요청하고, 이는 전역적으로 유일하다

  - 앱은 각 참여자에서 단일 노드 트랜잭션을 시작하고, 전역적으로 유일한 트랜잭션 ID를 붙인다 모든 읽기와 쓰기는 이런 단일 노드 트랜잭션 중 하나에서 실행된다.

  - 여기서 뭔가 잘못되면 코디네이터나 참여자 중 누군가 어보트할 수 있다

  - 애플리케이션이 커밋할 준비가 되면 코디네이터는 모든 참여자에게 전역 트랜잭션 ID로 태깅된 준비 요청을 보낸다 이런 요청 중 실패한 게 있으면 코디네이터는 모든 참여자에게 그 트랜잭션 ID로 어보트 요청을 보낸다

  - 참여자가 준비 요청을 받으면 커밋할 수 있는지 잘 확인하고 응답한다

  - 코디네이터가 모든 준비 요청에 대해 응답을 받았을 때 커밋할지 어보트할지 최종결정한다 - 결정 사항은 디스크의 트랜잭션 로그에 기록되어 커밋 포인트가 된다.

  - 코디네이터의 결정이 디스크에 쓰여지면 모든 참여자에게 결정이 전달된다. 이 요청이 실패하면 성공할 때까지 영원히 재시도한다

- 코디네이터 장애

  - 코디네이터가 죽거나 네트워크 장애 -> 참여자는 그저 기다릴 뿐(의심스럽다 혹은 불확실하다)
  - 2PC가 완료될 수 있는 유일한 방법은 코디네이터의 복구를 기다리는 것 뿐-> 이래서 코디네이터는 결정을 보내기 전에 디스크에 써놔야댐

- 3단계 커밋
  - 블로킹 원자적 커밋 프로토콜: 2PC는 코디네이터 복구 기다리느라 멈출 수 있다
  - 이론적으로 가능하지만, 논블로킹으로 만들기는 꽤 어렵다
  - 2PC에서 코디네이터 복구 기다리는 것에 대한 대안

### 4.2 현실의 분산 트랜잭션

- 2PC는 안전성을 보장하지만 성능이 무척 떨어짐.

  - 분산 트랜잭션은 종류 크게 2가지

    - DB 내부 분산 트랜잭션: 트랜잭션에 참여하는 모든 노드는 동일한 DB 소프트웨어를 실행한다
    - 이종 분산 트랜잭션: 참여자들은 둘 혹은 그 이상의 다른 기술-> 원자젓 커밋 보장이 훨어려움

- 정확히 한 번 메시지 처리

  - 메시지 전달이나 DB 트랜잭션 중 하나가 실패하면 둘 다 어보트 되고 메시지 브로커는 나중에 메시지를 안전하게 다시 전달

  - 메시지와 그 처리 과정의 부수 효과를 원자적으로 커밋함으로써 메시지가 결과적으로 정확히 한 번 처리되도록 보장

- XA 트랜잭션

  - eXtended Architecture의 약자로, 이종 기술에 걸친 2단계 커밋 구현 표준.

  - 애플리케이션 프로세스가 죽거나 장비가 죽으면 코디네이터도 죽는데, 이후 코디네이터는 로그 기반으로 각 트랜잭션 커밋/어보트 결과 복구하는데 XA 콜백을 써서 적절히 사용자에게 커밋 또는 어보트 요청 가능
  - 의심스러운 상태에 있는 동안 잠금을 유지하는 것

    - 트랜잭션이 의심스러운 상태에 빠지는 것에 많이 신경을 써야 한다
    - 한 번 잠겼는데 코디네이터 사망하면 그 로우는 누구도 못 건드리고 심하면 읽지도 못함

  - 코디네이터 장애에서 복구하기
    - 코디네이터가 부활하면 이론적으로는 다 잘 돼야 하지만, 현실에서는 고아 트랜잭션 발생
    - 관리자가 수동으로 트랜잭션의 커밋/롤백을 결정해야 하지만 여러 XA 구현에서는, 참여자들이 일방적으로 트랜잭션을 처분하는 ‘경험적 결정'이 있다
    - 경험적이라는 건 원자성을 깰 수 있다는 뜻을 완곡하게 표현한 것.

- 분산 트랜잭션의 제약
  - XA 트랜잭션도 중요한 운영상의 문제가 있다
  - 핵심 구현은 트랜잭션 코디네이터 자체가 일종의 DB여야 한다는 것
    - 코디네이터가 단일 장비에서 실행되면 전체 시슽메의 단일 장애점이 된다
    - 코디네이터가 애플리케이션 일부가 되면 배포 특성이 바귀는데, 이는 코디네이터 로그가 죽은 후에 의심스런 트랜잭션을 복구하기 위해 필요한 상황에서 DB만큼 중요한 역할을 수행하는데 영향 줄 수 있음.
      - 떠오르는 예시가 없어서 이해가 안됨.
    - XA는 광범위한 데이터 시스템과 호환을 필요로 하므로, 최소 공통 분모가 필요한데, 호환되지 않는 프로토콜과 충돌이 발생할 수 있음.
    - 2PC가 성공하려면 모든 참여자가 응답해야 하므로 장애를 증폭시킨다.

### 4.3 내결함성을 지닌 합의

- 합의의 형식화

  - 하나 또는 그 이상의 노드들이 값을 제안할 수 있고, 합의 알고리즘이 그 값 중 하나를 결정한다

  - 다음의 속성이 만족되어야 한다

    - 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다.
    - 무결성 : 어떤 노드도 두 번 결정하지 않는다.
    - 유효성 : 한 노드가 값을 결정하면 그 값은 어떤 노드에서 제안된 것이다.
    - 종료 : 죽지 않는 모든 노드는 결국 어떤 값을 결정한다.
      - 합의 알고리즘이 종료를 보장하려면 최소 과반 노드가 동작해야 한다 (증명됨)

  - 대부분 합의 알고리즘은 비잔틴 결함이 없다고 가정한다.

    - 즉, 노드가 프로토콜을 올바르게 따르지 않으면, 프로토콜 안전성 속성이 깨질지도 모른다.

- 합의 알고리즘과 전체 브로드캐스트
  - 알고리즘 중 대다수는 값의 순차열에 대해 결정해 전체 순서 브로드캐스트 알고리즘을 만든다
  - 전체순서 브로드캐스트는 합의를 여러 번 반복하는 것과 동일하다.
    - 합의의 동의 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전달하도록 결정한다.
    - 무결성 속성 때문에 메시지는 중복되지 않는다.
    - 유효성 속성 때문에 미시지는 오염되지 않고 난데없이 조작되지 않는다.
    - 종료 속성 때문에 메시지는 손실되지 않는다.
- 단일 리더 복제와 합의

  - 리더를 선출하려면 합의가 필요하다. 합의를 해결하려면 먼저 합의를 해결해야 한다 -> 이 자체로 난제

- 에포크 번호 붙이기와 정족수

  - 단일 리더 복제와 협의 난제에 대한 해결책
  - 리더가 죽은 거 같으면 노드 사이에서 투표가 시작되고 에포크 번호를 증가 시킨다
  - 리더는 결정할 때 에포크 높은 리더가 있는지 확인한다 (높은 노드가 이긴다)

- 합의의 제약

  - 합의에는 대가가 따른다
  - 노드가 제안에 투표하는 과정은 일종의 동기식 복제다(성능 필요하면 비동기 복제 사용)
  - 합의 시스템은 항상 엄격한 과반수 노드 동작을 요구한다. 노드 수가 바뀌는 건 더 어렵다
  - 장애를 감지하는 데 일반적으로 타임아웃에 의존한다. 실수로 멀쩡한 리더를 죽는 상황이 빈번하면 성능이 무척 나빠진다.

### 4.4 멤버십과 코디네이션 서비스

- 주키퍼나 etcd 같은 프로젝트는 분산 키-값 저장소 또는 코디네이션과 설정 서비스라고 설명됨

- 애플리케이션 개발자가 직접 주키퍼를 쓸 일은 잘 없다
- HBase, 하둡 얀, 오픈스택 노바, 카프카는 모두 배후에서 실행되는 주키퍼에 의존하므로 간접적으로 의존하게 된다
- 주키퍼는 전체 순서 브로드캐스트 말고 다른 기능 집합도 구현한다

  - 선형적 원자적 연산 : 원자적 compare-and-set 연산 사용해서 잠금 구현 가능
  - 연산의 전체 순서화 : 주키퍼는 모든 연산에 전체 순서를 정하고, 각 연산에 단조 증가하는 트랜잭션 ID와 버전번호를 할당해서 제공
  - 장애 감지: 세션 타임아웃보다 긴 기간 동안 하트비트가 멈추면 주키퍼는 세션이 죽었다고 판단한다.
  - 변경 알림: 클라이언트는 다른 클라이언트가 생성한 잠금과 값을 읽을 수 있을 뿐만 아니라 변경 있는지 감시 가능.

- 작업을 노드에 할당하기
  - 주키퍼/처비 모델 잘 작동하는 때는 여러 개 프로세스/서비스가 있고 그 중 하나가 리더로 선택돼야 할 때
    파티셔닝 된 자원에서 파티션-노드 할당을 결정해야 할 때 (재균형화 참고)
  - 주키퍼에서 원자적 연산, 단명 노드, 알림 등을 잘하면 사람 개입 없어도 결함으로 자동 복구가 될 수 있다
- 서비스 찾기

  - 주키퍼, etcd, 콘술은 특정서비스에 연결할 때 어떤 IP로 가야하는지 안내하는 용도로 사용된다
  - 이때는 합의보다는 신뢰성 있는 것과 네트워크 끊김에 견고한 게 중요하다

- 멤버십 서비스
  - 클러스터에서 어떤 노드가 현재 살아있는 멤버인지 결정한다
  - 장애감지와 연결하면 노드들은 어떤 노드의 생사를 결정할 수 있다
