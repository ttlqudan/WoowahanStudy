# Part 3. 파생 데이터

## 들어가기 전에...

- 1, 2부에서는 디스크에 저장된 데이터의 레이아웃부터 결함이 있는 상황에서의 분산된 일관성의 한계까지, 분산 DB로 가기 위한 모든 주요 사항을 밑바닥부터 다룸.

- 1, 2부에서는 단일 DB 사용을 전제로 설명

- 큰 애플리케이션에서는 데이터를 접근하고 처리하는데 다양한 방법이 필요

  - 데이터 스토어, 색인, 캐시, 분석 시스템 등...

- 그래서 3부부턴 데이터 모델도 다르고 최적화된 접근 양식도 다른 여러 데이터 시스템을, 일관성 있는 하나의 애플리케이션 아키텍처로 통합하는 문제를 검토함.

## 레코드 시스템과 파생 데이터 시스템

- 레코드 시스템

  - 믿을 수 있는 데이터 버전 저장. 진실의 근원(source of truth)라고도 부름.

  - 사용자 입력과 같은 새로운 데이터가 들어오면 먼저 레코드 시스템에 저장 후, 정규화를 거쳐 정확하게 한 번 표헌됨.

  - 따라서 레코드 시스템과 다른 시스템 간에 차이가 발생하면 정의에 따라 레코스 시스템이 옳다고 판단함.

- 파생 데이터 시스템

  - 다른 시스템의 데이터를 가져와 특정 방식으로 변환하고 처리한 결과.

  - 파생 데이터는 잃더라도 원본 데이터로부터 다시 데이터를 가져와 생성 가능함.

  - 캐시가 대표적인 예시.

- 엄밀히 말하면 파생 데이터는 기존 데이터를 복제한다는 의미에서 복제(Redundant)에 해당함.

- 파생 데이터는 비정규화를 통해 생성됨. 단일 원천 데이터로부터 여러 데이터셋을 추출해 데이터셋마다 서로 다른 관점으로 데이터를 본다.

# Chapter 10. 일괄 처리

## 1. 들어가기 전에...

- 1, 2부에서 언급한 현대의 데이터 시스템에서 가정하고 있는 데이터 처리 방식은 먼저 시스템에 요청을 하거나 지시를 보낸 후 (요청이 성공하면) 잠시 뒤에 해당 시스템으로부터 결과를 반환 받는 방식.

- 해당 내용의 전제는 **온라인 시스템**은 웹브라우저가 특정 페이지를 요청하는 서비스가 원격 API를 호출하든 일반적으로 사람이 사용자로서 요청을 보내고 응답을 기다리고 가정한다.

  - 이 과정에서 사용자가 오래 기다릴 수 없어서 응답 시간 단축 (latency 줄이기)에 많은 노력을 기울임.

  - 웹과 점점 늘어나는 HTTP/REST 기반의 API 요청/응답 방식이 흔해져서 당연한 것으로 여길 수 있으나, 이 방법이 유일한 방법은 아님.

- HTTP/REST API 방식 외의 데이터 처리 방식

  - 서비스 (온라인 시스템)

    - 클라이언트로부터 요청이나 지시가 올 때까지 기다리다가 ASAP 하게 요청을 처리해서 응답하려고함 -> 즉, 응답 속도는 서비스 성능 측정의 중요한 지표.

  - 일괄 처리 시스템

    - 큰 데이터를 입력 받아 작업 수행 후, 결과 데이터 생산.

    - 반복 주기로 실행

    - 작업 지표로 보는 주요 성능은 **처리량**

  - 스트림 처리 시스템

    - 온라인와 오프라인 처리 어딘가에 있기 때문에 준실시간 처리 (near-real-time processing or nearline processing)이라고 부름.

    - 이벤트 발생 직후에 처리가 실행됨.

    - 성능 지표는 입력 데이터 중 특정 크기만큼 처리할 때 걸리는 시간으로 봄.

- 일괄 처리 알고리즘 맵리듀스(MapReduce)는 구글에서 발표하고, MongoDB, CouchDB 등에 구현됨.

  - DW 용으로 개발된 병렬처리 시스템보다 상당히 저수준 프로그래밍 모델임.

- 10장의 목적 : 맵리듀스와 다른 일괄처리 할고리즘을 보고 현대 데이터 시스템에서 어떻게 사용하는지 알아보자.

## 2. 유닉스 도구로 일괄 처리하기

### 2.1 단순 로그 분석

- 수 기가 바이트의 로그 파일을 수 초 내로 처리 가능하고, 분석 방법 변경이 용이함.

- awk, sed, grep, sort, uniq, xargs 등

- 프로그래밍 언어로 스크립트 작성하는 것도 쉽지만, 둘 중 하나를 선택하는 것은 취향 이슈임.

- 하지만 실행 흐름이 크게 다른 것은 대용량 파일을 분석할 때 확연히 드러남.

- 대표적으로 `sort` 유틸리티는 메모리보다 큰 데이터셋을 읽을 때 자동으로 디스크로 보내서 여러 cpu 코어에 병렬로 정렬함.

  - 즉, 메모리 부족 없이 손쉽게 큰 데이터셋으로 확장 가능함.

### 2.2 유닉스 철학

- 큰 데이터 분석이 용이한 것은 유닉스 설계 철학 중 하나.

- 1987년에 기술된 유닉스 철학

  - 각 프로그램이 한 가지 일만 하도록하라. 기존 프로그램을 고쳐 새로운 기능을 추가해 복잡하게 만드는 것보다 새로운 프로그램 작성을 하자.

  - 모든 프로그램 출력은 아직 알려지지 않은 다른 프로그램 입력으로 쓰일 수 있다고 생각해라. 불필요한 정보 출력으로 너저분해서는 안된다.

  - 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라. 수 주 안에 끝내는 게 이상적이고 거슬리는 부분은 과감하게 버리고 새로 구축하라.

  - 프로그래밍 작업을 줄이려면 미숙한 도움보단 도구를 사용하라. 도구 빌드를 위해 한참을 둘러가야하고 게다가 사용 후 바로 버린다 할지라도 도구를 써라.

- 오늘날 Agile & DevOps 방법과 무척 흡사함.

### 2.3 동일 인터페이스

- 어떤 프로그램의 출력을 다른 프로그램의 입력으로 사용하려면 같은 데이터 형식을 사용해야함 -> 즉 같은 인터페이스 사용이 필요하다.

- 유닉스에서 인터페이스는 파일이다.

- 유닉스 커맨드에서 같은 레코드 분리자를 사용해 표준화했기 때문에 이 모든 프로그램이 상호 운영 가능하다. (awk, sort, uniq, head는 모두 `\n` 문자로 분리된 레코드 다룸)

- 깔끔하지 않은 경우도 있지만, 수십년이 지나도 유닉스의 동일 인터페이스는 여전히 대단함.

### 2.4 로직과 연결의 분리

- 표준 입력(stdin)과 표준 출력(stdout)

- 프로그램 실행 후 아무것도 하지 않으면 stdin은 키보드로부터 들어오고, stdout은 화면으로 출력됨.

- 셸 사용자는 유닉스 접근법으로 원하는대로 입력과 출력을 연결이 가능함. 사용가자 프로그램 입력이 어디서 들어오고 출력이 어디로 가는지 신경쓸 필요 없음 -> 느슨한 결합, 지연 바인딩, 또는 제어 반전이라고 함. (loosing coupling or late binding, inversion of control)

- 프로그램에서 입출력을 연결하는 부분을 분리하면 작은 도구로부터 큰 시스템을 구성하기 훨씬 수월하다.

- stdin & stdout 사용 시 제약사항

  - 프로그램 여러개 입력 & 출력이 필요할 때 불가능하진 않으나 까다로움.

  - 프로그램 출력을 파이프를 이용해 네트워크와 연결하지는 못한다 (netcat, curl은 예외)

### 2.5 투명성과 실험

- 유닉스 도구가 성공적인 이유 중 하나는 진행 사항 파악이 무척 쉬움.

  - 입력 파일은 일반적으로 불편 처리. 다양한 명령 옵션 사용해도 입력 파일에 손상이 전혀 없음.

  - 어느 시점이든 파이프라인 중단하고 less를 보내 원하는 형태 출력 나오는지 확인 가능. 디버깅할 때 유용하다.

  - 특정 파이프라인 단계 출력을 파일에 쓰고 그 파일을 다음 단계 입력으로 사용 가능.
    - 전체 파이프라인 다시 시작 안하고 다음 단계부터 시작 가능함.

## 3. 맵리듀스와 분산 파일 시스템

- 유닉스와 마찬가지로 불친절하고 무차별 대입 방법이지만 엄청나게 효율적인 도구.

- 입력 수정하지 않고 출력을 생산하는 것 외에 다른 부수 효과는 없음.

- 유닉스 도구는 stdin & stdout을 입출력으로 사용하는데, 맵리듀스는 분산 파일 시스템 상의 파일을 입출력으로 사용함.

  - 하둡에선 이 파일 시스템을 HDFS, 구글 파일 시스템 (GFS, Google File System)을 재구현한 오픈소스임.

  - HDFS는 비공유 원칙을 기반으로 하는데, NAS (Network Attached Storage)와 SAN(Storage Area Network) 아키텍처에서 사용하는 공유 디스크 방식과는 반대다.

    - 공유 디스크 저장소는 중앙 집중 저장 장치를 사용하는데 맞춤형 하드웨어를 사용하거나 파이버 채널과 같은 특별한 네트워크 인프라를 사용하기도함.

    - 비공유 방식은 특별한 하드웨어 필요 없고, 일반적인 데이터센터 네트워크에 연결된 컴퓨터면 충분함.

- HDFS는 각 장비에서 실행되는 데몬 프로세스로 구성.

  - 해당 프로세스가 다른 노드의 해당 장비에 저장된 파일에 접근할 수 있게끔 네트워크 서비스 제공.

  - 네임노드라고 부르는 중앙 서버가 특정 파일 블록이 어떤 장비에 저장됐는지 추적함.

  - 개념적으로 HDFS는 매우 큰 하나의 파일 시스템이고, 데몬이 실행 중인 모든 장비의 디스크 사용 가능함.

  - RAID와 유사함. 파일 블록을 여러 파일에 복제.

### 3.1 맵리듀스 작업 실행하기

- 맵리듀스 정의 : HDFS와 같은 분산 파일 시스템 위에서 대용량 데이터셋을 처리하는 코드를 작성하는 프레임워크.

- 맵리듀스 단계

  - 1단계 : 파일 나눠서 레코드 구성을 위한 입력 형식 파서 사용.

  - 2단계 : 맵 단계

  - 3단계 : 정렬 단계로 맵 리듀스에 내재하는 단계. 매퍼 출력은 리듀스로 들어가기 전에 이미 정렬되었음.

  - 4단계 : 리듀스 단계

- 매퍼와 리듀서, 2가지 콜백 함수

  - `매퍼` : 모든 입력 레코드마다 한 번씩만 호출. 키와 값을 추출하는 작업. 각 입력으로부터 생성하는 키-값은 빈 쌍을 포함해 원하는 만큼 생성 가능. 매퍼는 입력 레코드로부터 다음 레코드까지 상태를 유지하지 않기 때문에 각 레코드를 독립적으로 처리.

  - `리듀서` : 매퍼가 생산한 키-값 쌍을 받아 같은 키를 모으고 해당 값의 집합을 반복해 리듀서 함수 호출. 리듀서는 출력 레코드 생산.

### 3.2 맵리듀스의 분산 실행.

- 유닉스 명령 파이프라인과 가장 큰 차이는 코드 직접 작성 안하고도 여러 장비에서 동시에 처리 가능하다는 점.

- 맵리듀스의 각 입력 파일은 일반적으로 크기가 수백 MB 라서, 각 입력 파일의 복제본이 있는 서버의 RAM & CPU에 여유가 충분하다면 맵리듀스 스케줄러가 입력 파일이 있는 장비에서 작업을 수행하려함.

  - 이를 데이터 가까이서 연산하기라 부르는데, 네트워크 통해 입력 파일을 복사하는 부담과 부하가 감소하고 지역성이 증가함.

- 대부분의 경우 맵 태스크에서 실행될 애플리케이션 코드가 할당된 서버에 아직 없기 때문에 맵리듀스 프레임워크가 실행되기 적절한 서버에 코드를 복사함.

  - 복사가 마무리 되어야 매퍼 태스크 시작됨.

- 맵 태스크 수는 입력 파일의 블록 수로 결정되지만, 리듀스 태스크 수는 사용자가 결정함.

  - 즉, 맵 태스크 수와 리듀스 태크스 수는 다를 수 있음.

  - 맵리듀스 프레임워크는 같은 키를 가진 모든 키-값 쌍을 같은 리듀서에서 처리하는 것을 보장함.

- 키-값 쌍은 반드시 정렬되어야하나 대게 데이터셋 크기가 무척 크기 때문에 단계를 나눠 정렬 수행함.

  - 각 맵 태스크는 키의 해시값 기준으로 출력을 리듀서로 파티셔닝 진행.

  - 각 파티션을 매퍼의 로컬 디스크에 정렬된 파일로 기록함.

- 매퍼가 입력 파일 읽고 정렬된 출력 파일 기록을 완료하면 맵리듀스 스케줄러는 그 매퍼에서 출력 파일 가져올 수 있다고 리듀서에게 알려줌.

- 리듀서는 각 매퍼와 연결해서 리듀서가 담당하는 파티션에 해당하는 정렬된 키-값 쌍 파일 다운로드.

- 리듀서 기준 파티셔닝 후 매퍼에서 데이터 파티션 복사하는 과정을 셔플이라고 함.

  - 맵리듀스에서 셔플은 임의로 섞지 않음. (일반적인 단어 정의와는 다르다.)

- 리듀스 태스크는 매퍼로부터 파일을 로딩해서 정렬된 순서 유지하면서 병합한다.

  - 다른 매퍼가 동일한 키로 레코드 생성 시, 병합된 이후 리듀서의 입력으로 들어가면 서로 인접하게 됨.

- 리듀서는 키와 반복자를 인자로 호출하는데, 이 반복자로 전달된 키와 동일한 키를 가진 레코드를 모두 훑을 수 있음.

- 리듀서는 임의의 로직을 사용해서 이 레코드들을 처리하고 여러 출력 레코드 생성 가능. 이 출력 레코드가 분산 파일 시스템에 파일로 기록됨.

### 3.3 맵 리듀스 워크플로우

- 맵 리듀스 작업 하나의 출력을 다른 맵리듀스 작업의 입력으로 사용하는 식.

- 쉽게 말해, 첫번째 작업에서 생성한 결과 파일들의 디렉토리를 출력하면, 두번째 작업에서 해당 디렉토리를 입력으로 연결하는 방식.

- 맵리듀스 방식에서 보면 두 작업은 완전히 독립적임.

  - 스케줄러의 예로 Airflow 등이 있음.

### 3.4 리듀스 사이드 조인과 그룹화

- 여러 데이터셋에서 한 레코드가 다른 레코드와 연관이 있는 것은 일반적이고, RDB에선 외래키(Foreign key), Document DB에선 문서 참조 (document reference)라고하며, 그래프 모델에선 간선(edge)라고 부름.

- 연관된 레코드 양쪽 모두에 접근해야하는 코드가 있다면 조인은 필수임.

- 적은 수의 레코드 관련 질의 -> index를 쓰는게 빠름.

- 맵리듀스에는 index 개념이 없음.

- 맵리듀스 작업은 입력 파일 전체 내용을 읽음 (전체 테이블 스캔, full table scan)

  - 적은 수의 레코드를 읽을 때는, 터무니 없이 큰 비용이 듦.

- 그러나 분석 질의 수행할 땐, 대량의 레코드를 대상으로 집계 연산하는 게 일반적이고, 이 경우 입력 전체를 스캔하는 건 합리적임.

- 따라서 일괄 처리 맥락에서 조인은 데이터셋 내 모든 연관 관계를 다룬다는 뜻임.

- 특정 사용자만 찾는 거라면 index를 사용하는 게 합리적이다.

### 3.5 정렬 병합 조인

- 매퍼 출력이 키로 정렬된 후에 리듀서가 조인의 양측의 정렬된 레코드 목록을 병합하는 방식

### 3.6 같은 곳으로 연관된 데이터 가져오기

- 병합 정렬 조인 중 매퍼와 정렬 프로세스는 조인 연산을 할 때 필요한 모든 데이터를 한 곳으로 모은다.

- 맵리듀스는 모든 네트워크 통신을 직접 관리하기 때문에 특정 장비가 죽는 것과 같이 부분적으로 실패가 발생해도 애플리케이션 레벨에서 고민 필요 없음. 실패한 태스크는 재시도 (애플리케이션 로직 영향 X)

### 3.7 그룹화

- SQL에서 `group by` 절과 같음.

- 맵리듀스에서 그룹 연산 구현의 가장 간단한 방법은 키-값 쌍을 생성하는 시점에 그룹화할 대상을 키로 설정하는 것.

- 맵리듀스 위에서 그룹화와 조인은 상당히 비슷함.

- 특정 사용자의 일련의 활동을 찾기 위한 세션별 활동 이벤트 수집 분석에도 일반적으로 그룹화를 사용하는데, 이를 세션화라고 함.

## 4. 쏠림 다루기

- 키 하나에 너무 많은 데이터가 연관되면 "같은 키를 가진 모든 레코드를 같은 장소로 모으는" 패턴이 잘 동작 안함.

- 소셜 네트워크 : 소수의 유명인사에게 팔로워 수백만 쏠림.

  - 불균형 활성 DB 레코드를 린치핀 객체 (linchpin object) 또는 핫 키 (hot key)라 부름.

- 핫 키 완화 알고리즘

  - 쏠린 조인(skewed join) : 어떤 키가 핫 키인지 결정하기 위해 샘플링 작업 수행. 핫 키를 여러 리듀서에게 퍼뜨려서 처리하는 방법.

  - 공유 조인 : 샘플링 작업 대신 핫 키를 명시적으로 지정.

- 핫 키로 레코드를 그룹화하고 집계하는 작업은 두 단계로 수행

  - 첫번째 : 맵리듀스 단계에서 레코드를 임의의 리듀서로 보냄.

  - 두번째 : 맵리듀스 작업은 첫 단계 모든 리듀서에서 나온 값을 키별로 모두 결합해 하나의 값으로 만듦.

### 4.1 맵 사이드 조인

- 조인 로직을 리듀서에서 실행하면 리듀서 사이드 조인 (reduce-side join)

  - 입력 데이터에 대한 특정 가정이 필요 없음.

- 맵 사이드 조인 (map-side join): 입력 데이터에 대해 특정 가정이 가능하고, 더 빠른 조인 수행 가능.

  - 축소된 맵리듀스 작업이고 정렬 작업도 없음.

## 5. 브로드캐스트 해시 조인

- 브로드캐스트 해시 조인: 메모리에 올릴 정도로 데이터의 양이 충분히 작은 데이터 셋과 매우 큰 데이터 셋을 조인할 때 사용하는 방법

- 브로드캐스트 : 큰 입력의 파티션 하나를 담당하는 각 매퍼는 작은 입력 전체를 읽는다는 것을 의미.

  - 작은 입력을 큰 입력의 모든 파티션에 "브로드캐스트"

## 6. 파티션 해시 조인

- 파티션 해시 조인: 두 입력 모두를 같은 키와 같은 해시 함수 기반으로 동일한 개수로 파티셔닝하여 조인하는 방식

## 7. 맵 사이드 병합 조인

- 맵 사이드 병합 조인: 입력 데이터셋이 동일한 방식으로 파티셔닝되어 있고 같은 키를 기준으로 정렬되어 있는 경우 사용할 수 있는 맵-사이드 조인

### 7.1 맵 사이드 조인을 사용하는 맵리듀스 워크플로우

- 리듀스 사이드 조인은 join key로 파티셔닝해서 출력.

- 맵 사이드 조인은 큰 입력과 동일한 방법으로 파티셔닝하고 정렬.

  - 파티션 조인 or 브로드캐스트 조인 모두 큰 조인 입력의 파일 블록마다 맵 태스크가 실행되기 때문.

- 맵 사이드 조인은 크기, 정렬 입력 데이터의 파티셔닝 같은 제약 사항이 존재함.

## 8. 일괄 처리 워크플로우의 출력

- 모든 처리를 마친 결과가 어떻게 나오고 애초에 이 모든 작업을 수행하는 이유는 무엇인가?

- 일괄 처리 입력 데이터셋 대부분은 스캔하는 것이 일반적이라 분석에 더 가까움.

### 8.1 검색 색인 구축

- 검색 색인 구축에 구글이 과거에 사용했었음.

- 정해진 문서 집합을 대상으로 전문 검색이 필요하면 일괄 처리가 색인을 구축하는데 매우 효율적임.

- 키워드로 검색 색인에 질의하는 연산은 읽기 전용이라 색인 파일을 한 번 생성하면 불변이다.

- 색인된 문서가 변하면 전체 문서 집합 대상으로 주기적인 전체 색인 워크플로우 재수행하고 수행 끝나면 이전 색인 파일을 새로 생성된 색인으로 바꾸는 것이 한 방법.

- 색인에 문서를 편집하는 것을 원하면 루씬은 세그먼트 파일을 새로 기록하고 백그라운드에서 증분식으로 부분 파일을 병합하고 압축함.

### 8.2 일괄 처리 출력으로 키-값 저장

- 일괄 처리 워크플로 출력의 예시 : 검색 색인, 머신러닝 시스템, 추천 시스템

- 일괄 처리 작업의 출력은 일종의 DB.

  - 사용자 ID로 질의하는 DB 또는 관련 상품 목록을 가져오기 위해 상품 ID로 질의하는 DB 존재.

  - 예시로 사용자 ID로 질의하는 DB 또는 관련 상품 목록을 가져오기 위해 상품 ID로 질의하는 DB가 있음.

- 일괄 처리 워크 플로우를 위해 가장 좋은 해결책은 일괄 처리 작업 내부에 완전히 새로운 DB를 두는 것임.

### 8.3 일괄 처리 출력에 관한 철학

- 코드에 버그가 있으면 이전 버전으로 롤백해서 간단하게 재수행. 다른 디렉토리에 출력을 기록하면, 출력 위치 변경해서 복구 가능.

- 비가역성 최소하 : 쉽게 되돌릴 수 있는 속성의 결과로 기능 개발 더 빠르게 가능

- 맵 또는 리듀스 태스크가 실패하면 다시 스케줄링해서 동일 입력 재실행.

- 현재 실행과 이전 실행의 출력 비교 및 차이 측정 가능

- 다양한 작업에서 입력으로 동일한 파일 집합 사용할 수 있음.

- 유닉스 도구와 마찬가지로 맵리듀스 작업은 입출력 디렉터리를 설정하는 등의 연결 작업과 로직을 분리한다.

## 9. 저장소의 다양성

- DB는 모델에 따라 데이터를 구조화하는데, 극단적으로 하둡 등은 데이터가 어떤 포맷이라도 관계없이 HDFS로 덤프할 수 있는 가능성 열어둠.

  - 분산 파일시스템의 파일은 어떤 데이터 모델과 인코딩을 사용해서도 기록할 수 있는 연속된 바이트일 뿐이다.

- 현실에서는 이상적인 DB 모델 구성보다 데이터를 빨리 사용 가능하게 만드는 게 더 가치있음.

  - DW 개념과 유사.

  - 데이터를 먼저 수집하고, 설계는 나중에 고민하면 데이터 수집 속도가 늘어남.

## 10. 처리 모델의 다양성

- SQL & 맵리듀스 2개 모델만으로는 충분하지 않다.

  - SQL은 추천 시스템의 랭킹 모델이나 이미지 분석 등에는 더 범용 데이터 처리 모델 필요.

  - 맵리듀스도 제한적이고 어떤 경우에는 성능도 나쁜 것을 발견.

## 11. 빈번하게 발생하는 결함을 줄이는 설계

- 맵리듀스는 맵 또는 맵 태스크 자체가 실패를 견딜 수 있음. 전체 작업에 영향 없음.

- 대용량 작업에 적합하고, 태스크가 종료될 위험이 약 5%로 하드웨어 또는 장비 재시작 등 다른 이유로 실패할 이유보다 상당히 높지만, 이걸 견실 수 있음.

## 12. 맵리듀스를 넘어

- 맵리듀스를 직접 사용하는 일은 어렵기 때문에 맵리듀스 상에 추상화된 다양한 고수준 프로그래밍 모델이 등장함.

- 태스크가 자주 종료되서 신뢰할 수 없는 멀티 태넌시 시스템에서도 대규모 처리를 위해 맵리듀스를 사용할 수 잇고, 그 작업은 느려도 성공한다.

- 그렇다면 일괄 처리 방법의 대안은?

## 13. 중간 상태 구체화

- 분산 파일 시스템 상에 있는 파일들은 단순히 한 작업에서 다른 작업으로 데이터를 옮기는 수단, 즉 중간 상태에 있음.

- 중간 상태를 파일로 기록하는 과정을 구체화(materialization)이라함.

- 중간 상태를 완전히 구체화하는 맵리듀스 접근법은 유닉스 파이프에 비해 여러 단점 존재.

  - 입력을 생성하는 모든 선행 작업이 완료되어야 실행 가능.

  - 매퍼가 종종 중복됨.

  - 중간 상태 파일이 여러 장비에 걸쳐 복제되었다는 것은 임시 데이터에게는 과잉 조치임.

## 14. 데이터플로 엔진

- 전체 워크 플로우를 독립된 하위 작업으로 나누지 않고 작업 하나로서 다룬다는 점.

- 여러 처리 단계를 통해 데이터 흐름을 명시적으로 모델링해서, 데이터플로 엔진이라 부름

## 15. 내결함성

- 분산 파일 시스템에 중간 상태를 모두 구체화할 때 생기는 이점은 내구성.

- 결함을 복구할 때 데이터를 재연산하는 방식이 항상 정답은 아니다. 중간 데이터가 원천 데이터보다 훨씬 작거나 연산이 cpu 중심적이면 재연산보다 중간 데이터를 파일로 구체화하는 방식이 더 효과적이다.

## 16. 그래프와 반복 처리

- 그래프는 분산 파일 시스템에 정점과 간선 목록이 포함된 파일 형태로 저장 가능.

  - 하지만 "완료할 때까지 반복"이라는 개념은 일반적인 맵리듀스로 표현 불가.

  - 그래서 알고리즘을 반복적 스타일로 구현함. 하지만 상당히 비효율적

    - 프리글 처리 모델 : 일괄 처리 그래프 최적화 방법으로벌크 동기식 병렬 (bulk synchronous parallel) 모델 널리 사용.

    - 내결함성 : 네트워크 상에 문제로 메세지가 사라지거나 중복 또는 지연되도 프리글 구현상 다음 반복에서 메시지는 목적지 정점에서 정확히 한 번만 처리됨.

    - 병렬 실행 : 프리글 모델이 임의의 방법으로 그래프 파티셔닝해서 최적화 분할 진행.

## 17. 고수준 API와 언어

- 하이브, 피그, 캐스캐이딩과 크런치 같은 고수준 언어나 API가 인기 끌었음.

- 코드 적게 작성하는 명백한 이점 뿐 아니라 대화식 사용도 지원

### 17.1 선언형 질의 언어로 전환

- 모든 다양한 조인 알고리즘 이해하고 기억할 필요 없이 선언적 방법으로 조인 지정 가능.

- 애플리케이션에 단순히 어떤 조인이 필요한지 명시하면 질의 최적화기가 최적의 수행 방법을 결정함.

## 18. 다양한 분야를 지원하기 위한 전문화

- 일괄 처리가 중요해지는 다른 분야로 통계학과 수치 알고리즘 분야.

  - 분류, 추천 시스템과 같은 머신러닝 애플리케이션에 많이 사용됨.

  - k 최근접 이웃 알고리즘
