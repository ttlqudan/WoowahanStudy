# chapter 8. 분산 시스템의 골칫거리

## 결함과 부분장애
- 단일 노드: 정상동작 or 완전 실패, 결정적
- 분산 노드: 부분장애, 비결정적 => 내결함성 메커니즘을 추가해야 한다.

결함이 드물 것이라 가정하고 최선의 상황을 바라기만 하는 것은 현명하지 못하다. 발생 가능성이 상당히 낮을지라도 생길수 있는 결함을 광범위하게 고려하고 대비해야 한다.

## 신뢰성 없는 네트워크
대부분의 네트워크는 비동기 패킷 네트워크이다. 노드는 다른 노드로 메시지를 보낼 수 있지만 메시지가 언제 도착할지 혹은 메시지가 도착하기는 할지 보장하지 않는다.

여러가지 이유로 응답을 받을수 없을 수 있다. 이를 해결하는 가장 흔한 방법은 "타임아웃"

### 현실의 네트워크 결함
휴먼에러, 장비에러 등 여러가지 다양한 이유로 네트워크 결함은 발생할 수 있다. 
네트워크 결함에 대해서 소프트웨어에서 처리할 수 있도록 대비해야 한다.


### 결함 감지
많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.
보통, 타임아웃 and re-try를 통해 노드의 결함을 감지한다.

### 타임아웃과 기약 없는 지연
- 타임아웃이 길면, 노드가 죽었다고 선언될때까지 기다리는 시간이 길어진다 => 사용자들이 오래 기다려야 한다
- 타임아웃이 짧으면, 결함을 빨리 발견할수 있지만, 일시적인 지연에도 죽었다고 잘못 판단할 수 있다.
  - 성급하게 노드가 죽었다고 선언하면, 중복 실행 등의 문제가 발생할 수 있다.
  - 부하가 다른 노드로 전달되어서 다른노드에도 더 큰 부하를 일으키는 연쇄 장애를 유발할수 있다.
- 비동기 네트워크는 기약없는 지연(패킷을 가능한 빨리 보내려고 하지만, 걸리는 시간에 상한이 없음)이 있다.

#### 네트워크 혼잡과 큐 대기
- 컴퓨터 네트워크에서 패키 지연의 변동성은 큐 대기 때문인 경우가 많다.

타임아웃을 잘 설정해야 한다.
고정된 타임아웃보다 지속적으로 응답시간과 그들의 변동성(jitter)을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하는 게 좋다. 

##### TCP vs UDP
- TCP: 흐름 제어를 수행한다. 손실된 패킷이 있으면 재전송한다.
- UDP: 흐름 제어를 수행하지 않는다. 손실된 패킷이 있더라도 재전송하지 않는다.

### 동기 네트워크 vs 비동기 네트워크
circuit을 할당하는 방식의 동기식 네트워크는 일정한 대역폭을 end-to-end로 할당하고 주기적으로 전송하기 때문에 신뢰성이 아주 높다. (circuit-switch) 

하지만, 이러한 방법을 잘 사용하지 않는다. 데이터센터 네트워크와 인터넷은 packet-switch 프로토콜을 사용한다. 왜냐면, bursty traffic에 최적화되어있기 때문이다.



## 신뢰성 없는 시계
- 분산 시스템에서는 통신이 즉각적이지 않으므로 시간을 다루기 까다롭다. 메시지가 네트워크를 거쳐서 다른 장비로 전달되는 데 시간이 걸린다. 메시지를 받은 시간은 항상 보낸시간보다 나중이지만 네트워크 지연의 변동성 때문에 얼마나 나중인지 알수 없다.
- 각각의 장비는 자신의 시계를 가지고 있다. 그래서 장비마다 시간이 다를수 있는데, NTP(Network Time Protocol)를 이용하여 시간을 보정해서 동기화시킨다.

### 단조 시계 vs 일 기준 시계
#### 일기준 시계
- 우리가 생각하는 시계: wall-clock-time, epoch time
- NTP로 동기화
  - 로컬 시계가 NTP 서버보다 너무 앞서고 있었으면, 강제로 리셋되면서 시간이 과거로 뛰는것처럼 보일 수 있다.
- 해상도가 좋지 않다. 오래된 윈도우 시스템에서는 10ms 단위..
 
#### 단조 시계
- timeout, elapsed time 같은 duration을 측정하는데 적합
- ex) System.nanoTime()
- 절대적인 값은 의미가 없기 때문에, 두 값을 비교하는 곳에서 사용해야 한다.
- 해상도가 상당히 좋다. 대부분 micro second or 더 낮은 단위도 측정 가능
- 분산 시스템에서 시간 측정에서 사용할때 유용하다. 신뢰도도 높고, 부정확하더라도 크게 문제가 없기 때문.

### 시계 동기화와 정확도
- NTP 서버와의 네트워크 지연, 장비의 온도에 따른 drift 현상 등 여러가지 이슈로 일 기준 시계는 정확하지 않을 수 있다..
- 더 정확하게 하기 위한 프로토콜 등도 있으나, 상당한 노력과 전문 기술이 필요하다.
- NTP 데몬 설정이 잘못되거나 방화벽이 NTP 트래픽을 차단하면 드리프트에 따른 시계 오류는 빠르게 커질수 있다.

### 동기화된 시계에 의존하기
대부분의 시간에 아주 잘 동작하지만, 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다. 문제는 시계가 잘못되었다는 것을 알아채기가 어렵다는 것.

#### 이벤트 순서화용 타임스탬프
아주 잘 동기화되어있더라도 이벤트 타임스탬프를 통한 LWW 전략에서 문제가 발생할 수 있다..

#### 시계 읽기는 신뢰 구간이 있다
시계 읽기는 오차가 존재하기 때문에, 시계 읽기를 어떤 시점으로 생각하는 것보다 어떤 신뢰구간에 속하는 시간의 범위로 읽는 것이 좋다.

#### 전역 스냅숏용 동기화된 시계
스냅숏 격리를 구현하기 위해서는 트랜잭션 ID가 필요하다. 단일 노드에서는 문제가 없지만 분산 노드 환경에서는 코디네이션이 필요하다. 트랜잭션 ID는 인과성을 반영해야 하는데, 트랜잭션 ID 생성이 방어할수 없는 병목이 될 수 있다.

시계 정확도의 부정확성 대문에 일기준 시계의 타임스탬프를 트랜잭션 ID로 사용하는 것이 쉽지 않다.

그래서 스패너는 트랜잭션 타임스탬프가 인과성을 반영하는 것을 보장하기 위해서, 신뢰구간만큼 wait 하는 방법을 이용한다.

### 프로세스 중단
다음과 같은 데이터베이스가 있다고 가정하자
- 파티션 마다 리더가 하나
- 리더만 쓰기를 받도록 허용
노드가 여전히 리더인지, 그리고 안전하게 쓰기를 받을 수 있는지 어떻게 알 수 있을까?
- 리더가 다른 노드들로부터 임차권(lease)를 얻는 것
  - lease를 획득하면 lease가 만료될 때까지 leader로서 활동 하고, leader가 계속 leader로 남아있으려면 주기적으로 갱신해야 한다.
  - 노드에 장애가 발생하면 lease refresh가 멈추므로 lease가 만료될 때 다른 노드가 leader 역할을 넘겨 받을수 있어야 한다.
문제
1. 여기서 expire 판단할 때, lease expiry time이 다른 장비에서 설정 되었는데, local time과 비교를 해서 시간 불일치 발생할 수 있다.
2. 단조 시계를 사용하더라도 문제가 있을 수 있다. Thread stop으로 인해 lease가 만료되었음에도 만료되었는지를 모를 수 있다.

#### 응답시간 보장
많은 프로그래밍 언어와 운영체제에서 스레드와 프레소스는 기약 없는 시간동안 중단 될수 있다. 충분히 열심히 노력하면 중단의 원인을 **제거할 수 있다**

어떤 소프트웨어는 명시된 시간안에 응답하는데 실패하면 심각한 손상을 유발할 수 있는 환경에서 실행된다. 이런 소프트웨어에서는 응답에 deadline이 명시된다. deadline을 만족시키지 못하면 전체 시스템 장애를 유발할 수 있는 시스템을 **엄격한 실시간 시스템(hard real-time)**이라고 한다.

시스템에서 hard real-time을 보장하려면 소프트웨어 스택의 모든 수준에서 지원이 필요하다
- 프로세스가 명시된 간격의 CPU시간을 할당 받을수 있도록 보장하는 RTOS
- 라이브러리의 최악의 실행시간 명시화
- 동적 메모리 할당 제한 혹은 완전히 금지
- 보장을 만족시킨다는 것을 확신할 수 있는 막대한 테스트와 측정
이러한 이유로 인해, hard real-time 시스템 개발은 많은 비용이 들고, 안전이 필수적인 임베디드 장치에서 흔하게 사용된다. 

#### 가비지 컬렉션의 영향을 제한하기
- GC 중단을 노드가 잠시동안 계획적으로 중단되는 것으로 간주하고, 가비지 컬렉션중인 노드는 클라이언트로부터 요청을 받지 않도록 하는 것.
- 수명이 짧은 객체만 가비지 컬렉터를 사용하고, 수명이 긴 객체의 전체 GC가 필요할만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작.


## 지식, 진실 그리고 거짓말
네트워크에 있는 노드들은 어떤 것도 확실히 알지 못한다. 네트워크를 통해 받은 메시지를 기반으로 추측만 할 수 있을 뿐이다.

다른 노드와 메시지를 교환해서 그 노드가 어떤 상태에 있는지 알수 있지만, 원격 노드가 응답하지 않으면, 네트워크 문제인지 노드 문제인지 알 수가 없다.

이러한 분산시스템에서 무엇을 믿어야 하는가? 분산시스템에서 우리는 동작에 관해 정한 가정을 명시하고, 이런 가정을 만족시키는 방싱그로 실제 시스템을 설계 할수 있다.

### 진실은 다수결로 결정된다
비대칭적인 결함이 있는 네트워크가 있거나, 긴 stop-the-world 등으로 인해 노드가 정상적으로 동작하지만 다른 노드에서는 죽었다고 판단하는 경우가 생길 수 있다. 즉, 노드가 상황에 대한 자신의 판단은 믿을수 없다는 뜻.

분산 시스템에서는 **정족수(quorum)** 즉, 노드들 사이의 투표에 의존한다. 특정한 노드 하나에 대해서 의존을 줄이기 위해 여러 노드로부터 어떤 최소 개수의 투표를 받아야 한다.

노드 자신이 살아있다고 생각하더라도, 정족수를 이룬 노드들이 다른 노ㅗ드를 죽었다고 선언하면 그 노드는 죽은 것으로 간주되어야 한다.

노드의 과반수 이상을 정족수로 삼는게 가장 흔하다. (정족수 사용 합의 알고리즘은 9장에서)

#### 리더와 잠금
시스템이 오직 하나의 뭔가가 필요한 경우가 있다
- split brain을 피하기 위해 오직 한 노드만 데이터베이스의 파티션의 리더가 될 수 있다.
- 특정한 자원이나 객체에 동시 쓰기를 방지하기 우해 오직 하나의 트랜잭션이나 클라이언트만 자원이나 객체의 잠금을 획득 할수 있다.
- 사용자명으로 사용자를 유일하게 식별할 수 있어야 하므로 오직 한 명의 사용자만 특정한 사용자명으로 등록할 수 있다.

노드의 과반수가 어떤 노드가 죽었다고 선언했음에도 그 노드가 선택된 자인것처럼 계속 행동한다면 신중하게 설계되지 않은 시스템에서 문제가 발생할 수 있다.

- ex) lease를 가진 클라이언트가 stop-the-world로 인해 만료된 이후에 데이터를 쓰게 되면서, lease를 획득한 다른 클라이언트가 쓴 데이터를 오염시키는 문제 

#### 펜싱 토큰
공유 리소스에 접급을 보호하기 위해 자신이 잠금이나 임차권을 쓸 때, 자신이 선택된 자라고 잘못 믿는 노드가 나머지 시스템을 방해할 수 없도록 보장해야 한다.
이를 위한 단순한 기법으로 펜싱(fencing)이 있다.

1. 임차권 획득 시 fencing token을 반환
   - fencing token은 계속 증가하는 숫자
2. 데이터 쓰기 시 fencing token을 같이 넘겨주면서, 유효하지 않은 fencing token인 경우에 reject.
   - 이미 사용한 fencing token보다 낮은 숫자의 fencing token이 들어온 경우

- 잠금 서비스로 주키퍼를 사용하면 zxid, cversion을 fencing token으로 사용할 수 있다.


### 비잔틴 결함
fencing token은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있지만, 고의로 시스템의 보장을 무너뜨리려 하는 노드를 막을 수 없다.(ex. 가짜 fencing token 보내기)

분산시스템에서 노드가 프로토콜의 규칙을 어기고 거짓말을 하는 문제를 **비잔틴 결함(Byzantine fault)**라고 하고, 이렇게 신뢰할수 없는 환경에서 합의에 도달하는 문제를 **비잔틴 장군 문제(Byzantine Generals Problem)** 라고 한다.

이러한 비잔틴 결함이 존재하는 상황에서도 시스템이 정상적으로 동작한다면 이 시스템을 **비잔틴 내결함성을 지닌다(Byzantine fault-tolerant)** 라고 한다.

ex) 
- 항공우주 환경에서 방사선에 오염되는 데이터
- 서로 신뢰할수 없는 단체들이 중앙권한에 기대지 않고,트랜잭션이 발생했는지 아닌지 판단하는 방법으로 비트코인이나 다른 블록체인 같은 p2p 네트워크를 고려할수 있다

이 책에서 살펴보는 시스템들은 보통 비잔틴 결함이 없다고 가정할 수 있다. 비잔틴 내결함성을 보장하는 것은 매우 복잡하고, 비용이 크다.

웹앱에서는 웹브라우저같은 클라이언트가 임의적으로 악의적으로 예상하고 대비해야 한다. - sql injection, css 방지 등
- input validation
- 살균(sanitization)
- output escaping



#### 약한 형태의 거짓말
- 약한 형태의 "거짓말"은 애플리케이션에서 대비하는 것도 좋다.
  - 네트워크 패킷의 오염, TCP, UDP 레벨에서 검출되지 않는 것을 대비해서 애플리케이션에서 checksum 쓸수 있다.
  - public open 애플리케이션은 input에 대해서 잘 validatoin 해야 한다.
  - NTP 클라이언트가 동기화시 여러 NTP 서버로 보내서 이상한 NTP 서버를 동기화 대상에서 제외시킬수 있다. 
    
### 시스템 모델과 현실
시스템에서 발생할 것으로 예상되는 결함의 종류를 정형화 해야 한다. **시스템 모델(System Model)**을 정의해서 정형화 하는데, 시스템 모델은 알고리즘이 가정하는 것을 기술한 추상화

##### 타이밍 가정에 대한 세가지 시스템 모델
- 동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정 (기약 없는 지연과 중단이 발생할수 있기 때문에 현실적이지는 않음)
- 부분 동기식 모델: 대부분의 시간에는 동기식 시스템처럼 동작하지만 때때로 네트워크 지연, 프로세스 중단, 시계 드리프트의 한계치를 초과한다는 뜻 (가장 현실적인 모델)
- 비동기식 모델: 타이밍에 대한 어떤 가정도 할 수 없다.

#### 노드용 시스템 모델
- crash-stop 결함: 노드가 멈추면 계속 죽은 상태
- crash-recorty 결함: 어느 순간에 죽더라도 알려지지 않은 시간이 흐른후에 아마도 다시 응답하기 시작할것이라고 가정 
  - 노드는 메모리에 있는 상태는 손실되지만 죽어도 데이터가 남아있는 안정된 저장소가 있다고 가정한다.
- 비잔틴 결함: 노드는 다른 노드를 속이거나 기만하는 것을 포함해 전적으로 무슨 일이든 할 수 있다.

현실 시스템에서는 cresh-recovery 결함과 부분 동기식 모델이 일반적으로 가장 유용한 모델이다.

#### 알고리즘의 정확성
알고리즘이 정확하다는 게 어떤 의미인지 정의하기 위해 알고리즘의 속성을 기술할 수 있다.

##### fencing token의 속성
- 유일성
- 단조 일련번호
- 가용성

알고리즘은 시스템 모델에서 발생하리라고 가정한 모든 상황에서 그 속성들을 항상 만족시키면 해당 시스템 모델에서 정확하다. 그러나 이를 어떻게 이해할 수 있을까? 모든 노드가 죽거나 모든 네트워크 지연이 갑자기 무한히 길어진다면 어떤 알고리즘이라도 아무것도 할 수 없다.

#### 안정성과 활동성
상황을 분명히 하기 위해 두가지 다른 종류의 속성 **안정성(safety)**, **활동성(liveness)**를 구별할 필요가 있다.
어떻게 이 둘을 구별할까? 활동석 속성은 "Eventually" 라는 단어를 포함한다.

- 안정성 속성이 위반되면 그 속성이 꺠진 특정 시점을 가리킬 수 있다. 안정성 속성이 위반된 후에는 그 위반을 취소할 수 없다. 이미 손상된 상태다.
- 활동성 속성은 반대로 동작한다. 어떤 시점을 정하지 못할 수 있지만 항상 미래에 그 속성을 만족시킬 수 있다는 희망이 있다.

안정성 속성은 항상 만족되기를 요구하는게 일반적이고, 활동성 속성에는 경고를 하는 것이 허용된다.

