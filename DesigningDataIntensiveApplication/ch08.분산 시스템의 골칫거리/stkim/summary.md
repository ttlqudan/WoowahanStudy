# Chapter 8. 분산 시스템의 골칫거리

## 들어가기 전에

- 분산 시스템에서 발생하는 장애는 단일 노드에서 발생하는 장애와는 근본적으로 다르다.

- 결국 엔지니어로서의 우리 역할은 뭔가 잘못되더라도 제 역할을 수행하는 시스템을 구축하는 것이다.

## 1. 결함과 부분 장애

- 하드웨어가 올바르게 작동하면 같은 연산은 항상 같은 결과를 낸다.

- 하드웨어 결함이 있으면, 보통 시스템이 완전히 실패하는 결과를 낳는다.

  - 커널 패닉, 부팅 실패, 블루 스크린.

- 우린 컴퓨터 내부 결함이 있으면, 잘못된 결과 반환보다는 완전히 동작 안하기를 원한다.

- CPU Instruction은 메모리나 디스크에 데이터를 쓰면 온전히 남아 있고 제멋대로 오염되지 않는다.

- 부분 장애 (Partial Failure) : 분산 시스템에서 어떤 부분은 잘 동작하지만, 다른 부분은 예측할 수 없는 방식으로 고장나는 것.

## 2. 클라우드 컴퓨팅과 슈퍼 컴퓨팅

- 대규모 컴퓨팅의 한쪽 끝에는 고성능 컴퓨팅 분야가 있음 (HPC, High Performance Computing)

  - 최근 AI 분야에서 화두가 되는 Nvidia H100 서버, Samsung High Bandwidth Memory 등이 예시

  - 다른 극단에는 클라우드 컴퓨팅

  - 전통적인 기업들의 데이터 센터는 이들 중간 사이임.

- 슈퍼 컴퓨팅에서 노드 하나에 장애가 발생했을 때 흔한 해결책은 노드 전체 작업 중단하는 것이다. 그 후, 마지막 체크포인트에서부터 연산 재시작함.

  - 책에서는 인터넷 서비스를 구현하는 시스템을 중점적으로 다루며 이는 슈퍼 컴퓨터와 무척 다름.

    - 인터넷에서 제공하는 애플리케이션은 클러스터 전체 중단을 허용하지 않음

    - 슈퍼 컴퓨터는 전용 특화 하드웨어 사용하지만, 클라우드 컴퓨팅에서는 상용 컴퓨터를 사용함.

    - 슈퍼 컴퓨터는 통신 패턴이 정해진 HPC 작업 부하에서 높은 성능을 보여주는 다차원 메시(mesh)나 토러스(tours) 같은 특화된 네트워크 토폴로지 자주 사용.

    - 시스템이 커질 수록 고장의 이슈는 크고, 수천 개의 노드가 연결된 클러스터에서는 항상 무언가 고장이 있을 거라 보는 것이 합리적이다.

    - 시스템에 장애가 발생한 노드를 감내할 수 있고, 계속 운영할 수 있다면 이는 운영과 유지 보수에 매우 중요한 특성이 됨.

      - ex. 쿠버네티스?

    - 인터넷을 통해 전달하는 작업은 일반적으로 로컬 네트워크보다 느린데, 슈퍼 컴퓨터는 일반적으로 모든 노드가 가까이 있다고 가정함.

- 결국 분산 시스템이 동작하게 하려면 장애를 받아들이고, 소프트웨어에 내결함성 메커니즘을 넣어야함.

  - 즉, 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야함.

- 결함이 드물 것이라 생각하는 낙관적인 사고 방식은 좋지 못함.

  - 분산 시스템에서 의심, 비관주의, 편집증은 그 값어치를 한다.

- 신뢰성 없는 구성 요소를 이용해서 신뢰성 있는 시스템 구축하기란?

  - ECC (Error-Correcting Code) : 일부 비트가 잘못 되는 통신 채널을 통해 디지털 데이터를 정확히 전송할 수 있게 해줌.

  - IP에 TCP를 사용해 신뢰성 높은 전송 계층 제공

## 3. 신뢰성 없는 네트워크

- 인터넷과 IDC 대부분은 비동기 패킷 네트워크다.

- 다른 노드로 메세지는 보낼 수 있지만, 네트워크는 메세지가 언제 도착할지 혹은 메세지가 도착하기는 할 것인지 보장하지 않음.

  - 요청 자체가 손실되거나

  - 요청이 큐에서 대기하다 나중에 전송될 수도 있음.

  - 노드 장애

  - 노드가 일시적으로 응답 중단했지만, 나중에 응답할 수 있음.

  - 원격 노드가 응답을 처리했지만, 응답 자체에 손실이 있을 경우

  - 원격 노드가 응답을 처리했지만, 지연되다 나중에 처리되는 경우

- 보통 이런 경우, 타임아웃을 사용함.

## 4. 현실의 네트워크 결함

- 네트워크 중단의 주요 원인인 인적 오류 (ex. 스위치 설정 오류)

- 스위치 소프트웨어 업그레이드로 인한 네트워크 토폴로지 재구성 유발

- 상어가 해저 케이블 물어뜯는 경우

- 수신 패킷은 누락하는데, 송신 패킷은 잘 보내는 인터페이스

## 5. 결함 감지

- 요청이 성공했음을 확인하고 싶다면, 애플리케이션 자체로부터 긍정 응답을 받아야한다.

- 역으로 뭔가 잘못됐을 때는 아무 것도 못받는 상황도 가정해야한다.

  - 몇 번 재시도해보고, 타임아웃 발생 시 마침내 노드가 죽었다고 판단할 수 있음.

## 6. 타임아웃과 기약없는 지연

- **적절한** 타임아웃 시간이라는 것은 상대적이다.

- 비동기 네트워크는 기약없는 지연이 있고, 서버 구현에서는 대부분 어떤 최대 시간 내에 요청을 처리한다고 볼 수 없음.

## 7. 네트워크 혼잡과 큐 대기

- 컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.

  - 네트워크가 잘 동작하더라도 들어오는 데이터가 많아서 스위치 큐를 꽉 채울 정도가 되면 패킷이 유실되어 재전송이 필요하다.

  - CPU 코어가 바쁜 상태면, 들어온 요청은 애플리케이션이 처리할 때까지 운영체제가 큐에 넣어놓음.

  - 가상환경에서 사용하는 운영체제는 다른 가상 장비가 cpu 코어를 사용하는 동안 수십 밀리 초가 지연되는 이슈 흔함.

  - TCP 흐름제어 : 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것.

- TCP vs UDP

  - UDP는 손실된 패킷을 재전송하지 않으므로 네트워크 지연이 크게 변하는 원인 중 일부를 제거함.

  - 화상회의나 인터넷 전화에 적합하다.

- 지연 시간 변동성을 측정하려면 여러 장비에 걸쳐 네트워크 왕복 시간의 분포를 측정하는 방법도 있지만, 동적으로 타임아웃을 조절하는 파이 증가 장애 감지기를 쓰는 방법도 있다.

## 8. 동기 네트워크 대 비동기 네트워크

- 동기 네트워크 : 전화할 때 회선을 사용하는 방식. 데이터가 여러 라우터를 거치더라도 큐 대기 문제를 겪지 않음. 네트워크 종단 지연 시간의 최대치가 정해져 있음. 제한 있는 지연

- QoS, Admission Control 등을 잘 사용하면 패킷 네트워크에서 회선 교환을 흉내내거나 통계적으로 제한 있는 지연 보내는 것도 가능.

- 하지만 결과적으로 실험을 통해 올바른 타임 아웃을 알아내는 것이 좋음.

## 9. 신뢰성 없는 시계

- 단조 시계 대 일 기준 시계

  - 일 기준 시계 : 직관적으로 시계에 기대하는 일. 어떤 달력에 따라 현재 날짜와 시간을 반환

  - 단조 시계 : 타임아웃이나 서비스 응답 시간과 같은 지속 시간을 측정하는데 적합하다.

- 시계 동기화와 정확도

  - 시계가 정확한 시간을 알려주는 방법은 기대만큼 신뢰성이 있거나 정확하지 않음

  - 시계 정확도를 높이려면 상당한 자원을 투입해서 향상 시키는 것도 가능함 -> 고빈도 트레이딩 전략 (HFS)

- 동기화된 시계에 의존하기

  - 극단적인 고장보다는 조용하고 미묘한 데이터 손실이 발생할 가능성이 큼.

- 이벤트 순서화용 타임스탬프

  - 이벤트 순서용 타임스탬프는 이벤트가 발생한 시점을 나타내는 값으로, 이벤트 스트림을 처리할 때 중요한 역할을 합니다.
  - 이벤트 순서용 타임스탬프는 일반적으로 이벤트가 발생한 시간을 나타내는 시계를 따르지만, 이 시계는 정확하지 않을 수 있습니다. 예를 들어, 서로 다른 노드에서 발생한 이벤트의 타임스탬프는 실제 순서와 다를 수 있습니다.

- 시계 읽기는 신뢰 구간에 있다.

  - 시계 읽기를 어떤 시점으로 생각하는 것은 타당하지 않고, 어떤 신뢰할 수 있는 구간에 있는 것으로 시간 범위를 읽는 게 낫다.

- 전역 스냅숏용 동기화 된 시계

  - 전역 스냅숏용 동기화된 시계란 분산 시스템에서 모든 노드의 시계가 정확하고 일관된 시간을 가지도록 하는 기술.
  - 이를 위해 구글은 트루타임(TrueTime)이라는 API를 개발했고, 트루타임은 GPS와 원자시계를 사용하여 네트워크에 있는 각 노드의 시계를 동기화.
  - 트루타임은 시간의 범위를 반환하므로, 시간의 정확도와 신뢰성을 보장할 수 있음.
  - 전역 스냅숏은 분산 시스템의 모든 노드가 동일한 데이터를 보고 있는 순간을 의미하는데, 전역 스냅숏을 통해 데이터의 일관성과 가용성을 동시에 보장할 수 있음.

- 프로세스 중단

  - 프로세스 중단은 프로세스가 장애가 발생하면 즉시 중단되고 다른 프로세스에게 알리는 것으로 부분 장애를 처리하기 쉽고, 장애 복구를 위한 프로토콜을 단순화할 수 있다.
  - 예를 들어, 분산 데이터베이스에서 리더가 죽으면 팔로워 중 하나가 리더로 승격되고, 죽은 리더는 더 이상 요청을 받지 않는 구조.

- 응답 시간 보장

  - 응답 시간 보장(real-time guarantee)은 소프트웨어가 응답해야 하는 데드라인이 명시되고, 데드라인을 만족시키지 못하면 전체 시스템의 장애를 유발할 수 있는 시스템을 엄격한 실시간 시스템(hard real-time system)임.
  - 이런 시스템에서는 네트워크 지연, 프로세스 스케줄링, 가비지 컬렉션 등의 변동성을 최소화하거나 예측 가능하게 만들어야 하는데 예를 들어, 항공기 제어 시스템이나 자동차 제어 시스템은 엄격한 실시간 시스템이라 할 수 있음.

- 가비지 컬렉션 영향 제한하기

  - 가비지 컬렉션 영향을 제한하기는 가비지 컬렉션을 수행하는 프로그래밍 언어에서 응답 시간을 향상시키기 위한 방법임.
  - 가비지 컬렉션은 메모리에서 더 이상 사용되지 않는 객체를 회수하는 작업으로, 시스템의 성능에 영향을 줄 수 있음.
  - 가비지 컬렉션 영향을 제한하기 위한 방법으로는 가비지 컬렉션 알고리즘을 최적화하거나, 가비지 컬렉션을 수행하는 스레드를 분리하거나, 가비지 컬렉션을 수행하는 시점을 제어하거나, 객체 할당을 줄이거나, 메모리 풀을 사용하는 등이 있음.

## 10. 지식, 진실, 그리고 거짓말

- 진실은 다수결로 결정된다.

  - 노드가 상황에 대한 자신의 판단을 반드시 믿을 수 있는 것이 아니므로, 정족 수 (quorum) - 노드 사이의 투표에 의존함.

- 리더와 잠금

  - 저장 서비스에 있는 어떤 파일을 한 번에 클라이언트 하나씩만 접근하도록 보장하고 싶다. 여러 클라이언트가 사용하면 파일이 오염되기 때문.

  - 클라이언트가 접근 전에 잠금 서비스로부터 임차권을 얻게 유도하고자함.

- 펜싱 토큰

  - 잠금이나 임차권을 사용할 때, 노드가 "선택된 자"라고 잘못 믿고 있을 경우 해당 노드가 나머지 시스템을 방해하지 않도록 사용하는 기법

  - 잠금 서버가 임차권이나 승인할 때 펜싱 토큰 반환

- 비잔틴 결함

  - 노드들이 신뢰성은 없지만 정직할 때 뒤처지는 한이 있더라도 노드들이 응답하면 그 노드는 진실을 말한다고 가정

  - 일부 노드가 오작동하거나 프로토콜을 준수하지 않을 때, 그리고 악의적인 공격자가 네트워크를 공격하더라도 시스템이 동작하면, 비잔틴 내결함성을 지닌다고 할 수 있음.

- 약한 형태의 거짓말

  - 노드가 일반적으로 정직하다고 가정하지만 약한 형태의 거짓말로부터 보호해주는 메커니즘

## 11. 시스템 모델과 현실

- 동기식 모델

  - 프로세스 중단 / 네트워크 지연 / 시계드리프트의 한계치를 초과하지 않을 것임을 알고 있음

- 부분 동기식 모델

  - 대부분은 동기식으로 움직이나, 프로세스 중단 / 네트워크 지연 / 시계드리프트의 한계치를 초과하는 경우

- 비동기식 모델

  - 타이밍에 대한 어떤 가정도 할 수 없음.

- 알고리즘 정확성

  - 유일성 : 펜싱 토큰이 같은 값을 반환하지 않음

  - 단조 일련번호

  - 가용성 : 펜싱 토큰 요청 후 죽지 않는 노드는 응답 받음

- 안전성과 활동성
