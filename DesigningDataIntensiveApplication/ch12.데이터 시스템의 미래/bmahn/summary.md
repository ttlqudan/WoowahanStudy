# chapter 12. 데이터 시스템의 미래
- 요약: 미래에 신뢰할 수 있고 확장 가능하며 유지보수 쉬운 application 구축을 위해 앞선 도구를 어떻게 사용할지

## 데이터 통합
- 제품과 환경을 고려하기
- 표현하는 수가 늘수록 통합하기 어려움 -> 숲을 보기 위해 노력 (줌아웃)
- 데이터 플로에 대한 추론
    - 입력과 출력을 분명히 하기
- 파생 데이터 vs 분산 트랜잭션
    - 파생 데이터 (CDC, 이벤트 소싱): 로그를 사용 -> 결정적 재시도와 멱등성 기반 (비동기, "자신이 쓴내용 읽기")
    - 분산 트랜잭션: 상호 베타잠금 사용 -> 원자적 커밋 기반 (결함 대응에 취약하고 성능 나쁨)
- 이벤트 순서화
    - 예시: 친구 삭제 후 모든 친구에게 메시지 보내기
    - 문제해결 예시: 논리적 타임 스탬프, 이벤트 식별자, 충동해소 알고리즘
- 일괄처리와 스트림 처리
    - 데이터 통합의 목표: 데이터를 올바른 장소에 올바른 형태로 두기
- 람다 아키텍쳐: 실시간 스트리밍 데이터와 배치 데이터 처리를 결합 (배치, 실시간, 서빙 계층)
    - 카파 아키텍처: 단일 스트리밍 처리 계층만을 사용 (람다 아키텍처의 배치 및 실시간 계층을 하나로 통합한 형태)
## 데이터베이스 언번들링
- 모든 것의 메타 데이터베이스
    - 읽기를 통합 vs 쓰기를 통합 -> 쓰기를 통합(unbundling)
    - 언번들링 동작하게: 분산 트랜잭션 및 멱등성 + 비동기 이벤트 로그 -> 느슨한 결합 (장애, 유지보수 강점)
        - 성급한 최적화는 낭비
- 데이터플로 주변 application 설계: 함수형 반응형 프로그래밍
- application 코드와 상태의 분리: 하나를 잘하는 관점, "데이터 저장 전문"과 "코드 실행" 나누기
- 스트림 처리자와 서비스: msa 는 동기식 요청/응답 vs 스트림 연산자는 단방향 비동기 메시지 스트림
- 파생 상태 관찰
    - 읽기 경로 vs 쓰기 경로 (eager vs lazy)
- 구체화 뷰와 캐싱: 공통 부분은 미리 계산 (캐시)
- 오프라인 대응 가능한 상태 저장 클라이언트
    - 클라에서 서버상태 캐시
    - eventsource, websocket 으로 클라이언트 푸시 -> 쓰기 경로가 최종 사용자까지 확대
- 읽기도 이벤트
    - 스트림 처리자도 단순 DB가 됨 (같은 키로 파티셔닝)
        - 복잡해지면 단순 DB가 좋음
    - 읽기 이벤트 기록 시 인과적 의존성 추적 가능
## 정확성을 목표로
- 정확성 -> 트랜잭션 -> 비용
- 정확히 한번 실행: 멱등성, 연산 ID (연산 식별자, request_id)
- 제약 조건 강제
    - 합의
    - 단일 노드를 리더로
    - 유일성이 필요한 값으로 파티셔닝
- 다중 파티션 요청 처리 예시
    - 고유 요청 ID 기준으로 파티셔닝
    - 출금 ID, 입금 ID 별로 파티셔닝 (두 가지 스트림 방출)
- 적시성(timeliness)과 무결성(integrity)
    - 적시성 위반: 최종적 일관성 vs 무결성 위반 : 영구적 불일치 -> 무결성이 위반되면 파국
- 데이터플로 시스템의 정확성
    - 정확히 한번 -> 결과적 한번
- 느슨한 제약 조건
    - 보상 트랜잭션
    - 사과
    - 초과 예약
    - 결과적: "무결성" 반드시 요구 -> 최적의 트레이드 오프를 목표로
- 믿어라 하지만 확인하라 -> 버그가 있어도 무결성 유지 -> 약속 맹신 안하기 + 검증 하는 문화 (감사기능, 작업 증명)
## 옳은 일 하기
- 편견은 늘어만 감, 영향력 -> 책임과 의무 가지기