# Chapter 12. 데이터 시스템의 미래

## 1. 들어가기 전에...

- 미래에 견고하고, 정확하며, 발전 가능한, 궁극적으로 인류의 미래에 도움이 되는 애플리케이션 설계에 대해 논의한다.

## 2. 데이터 통합

- 이벤트 로그를 기반으로 한 파생 데이터 시스템을 업데이트하는 것은 종종 결정론적이고 아이덴포턴트하게 만들 수 있습니다.

- 분산 트랜잭션은 상호 배제를 위해 락을 사용하여 쓰기의 순서를 결정하며, CDC와 이벤트 소싱은 순서를 결정하기 위해 로그를 사용합니다. 분산 트랜잭션은 정확히 한 번만 보장하기 위해 원자적 커밋을 사용하며, 로그 기반 시스템은 결정론적인 재시도와 아이덴포턴스에 기반합니다.

- 트랜잭션 시스템은 선형화를 제공하여 자신의 쓰기를 읽는 경우 유용한 보장을 제공합니다. 그러나 파생 시스템은 일반적으로 비동기적으로 업데이트되므로 기본적으로 동일한 타이밍 보장을 제공하지 않습니다.

- 좋은 분산 트랜잭션 프로토콜에 대한 널리 퍼진 지원이 없는 경우, 로그 기반 파생 데이터는 서로 다른 데이터 시스템을 통합하기 위한 가장 유망한 접근 방식입니다.

- 그러나 시스템이 더 크고 복잡한 워크로드로 확장됨에 따라 제한 사항이 나타납니다:

  - 전적으로 정렬된 로그를 구성하려면 모든 이벤트가 순서를 결정하는 단일 리더 노드를 통과해야 합니다.

  - 여러 데이터 센터에서 시작된 이벤트의 정의되지 않은 순서.

  - 두 이벤트가 서로 다른 서비스에서 시작된 경우 이러한 이벤트에 대한 정의된 순서가 없습니다.

  - 일부 애플리케이션은 클라이언트 측 상태를 유지합니다. 클라이언트와 서버는 이벤트를 서로 다른 순서로 볼 가능성이 높습니다.

- 이벤트의 총 순서를 결정하는 것은 총 순서 브로드캐스트라고하며 이는 합의와 동등합니다. 단일 노드의 처리량을 넘어서 확장 가능한 합의 알고리즘을 설계하는 것은 여전히 연구 중인 문제입니다.

### 2.1 일괄 처리와 스트림 처리

- 일괄 처리 프로세서와 일괄 처리 프로세스의 근본적인 차이점은 스트림 프로세서가 무한한 데이터 집합에서 작동하는 반면, 일괄 처리 프로세스의 입력은 알려진 유한한 크기를 가지고 있다는 것입니다.

- Spark는 일괄 처리의 위에 스트림 처리를 수행합니다. Apache Flink는 스트림 처리의 위에 일괄 처리를 수행합니다.

- 일괄 처리는 상당히 강한 기능적 특성을 가지고 있습니다. 출력은 입력에만 의존하며 부작용이 없습니다. 스트림 처리는 유지 및 내결함성 있는 상태를 허용하면서 유사하지만 부작용이 가능합니다.

- 파생 데이터 시스템은 동기적으로 유지될 수 있습니다. 그러나 비동기성은 이벤트 로그를 기반으로 한 시스템을 견고하게 만드는 요소입니다. 이것은 시스템의 한 부분에서의 오류를 지역적으로 격리시킬 수 있습니다.

- 스트림 처리는 입력의 변경 사항을 낮은 지연 시간으로 파생된 뷰에 반영할 수 있게 하며, 일괄 처리는 누적된 역사적 데이터를 다시 처리하여 기존 데이터 집합에 새로운 뷰를 유도할 수 있습니다.

- 파생된 뷰는 점진적인 진화를 허용합니다. 데이터 집합을 재구조화하려면 급격한 전환으로 마이그레이션을 수행할 필요가 없습니다. 대신, 이전 스키마와 새로운 스키마를 기존 데이터의 두 독립적인 파생된 뷰로 나란히 유지할 수 있으며, 결국 이전 뷰를 삭제할 수 있습니다.

### 2.2 람다 아키텍처

- 람다 아키텍처의 핵심 아이디어는 들어오는 데이터를 항상 커지는 데이터 집합에 불변한 이벤트를 추가하여 기록해야 한다는 것입니다. 이는 이벤트 소싱과 유사한 방식입니다. 이러한 이벤트에서는 읽기 최적화된 뷰가 파생됩니다. 람다 아키텍처는 Hadoop MapReduce와 같은 일괄 처리 시스템 및 Storm과 같은 스트림 처리 시스템과 같이 두 가지 다른 시스템을 병렬로 실행하는 것을 제안합니다.

- 스트림 프로세서는 뷰에 대한 근사 업데이트를 생성하며, 일괄 프로세서는 파생된 뷰의 수정된 버전을 생성합니다.

- 스트림 프로세스는 빠른 근사 알고리즘을 사용할 수 있으며, 일괄 프로세스는 더 느린 정확한 알고리즘을 사용합니다.

## 3. 데이터베이스 언번들링

### 3.1 색인 생성하기

- 일괄 처리 및 스트림 프로세서는 트리거, 저장 프로시저 및 머터리얼라이즈된 뷰 유지 루틴의 정교한 구현과 같다고 볼 수 있습니다. 그들이 유지하는 파생 데이터 시스템은 서로 다른 인덱스 유형과 유사합니다.

- 다양한 저장 및 처리 도구를 일치시키기 위해 두 가지 접근 방식이 있습니다.

  - 연합된 데이터베이스: 읽기 통합. 다양한 기본 저장 엔진과 처리 방법에 대한 통합된 쿼리 인터페이스를 제공하는 것이 가능하며, 이를 연합된 데이터베이스 또는 다중 스토어로 알려집니다. 예를 들어 PostgreSQL의 외부 데이터 래퍼가 있습니다.

  - 분리된 데이터베이스: 쓰기 통합. 여러 저장 시스템을 조합할 때 모든 데이터 변경 사항이 모든 올바른 위치에 도달하도록 보장해야 합니다. 이는 데이터베이스의 인덱스 유지 기능을 분리하여 다양한 기술 간에 쓰기를 동기화할 수 있는 방식으로 이루어집니다.

- 여러 저장 시스템 간에 쓰기를 동기화하는 것은 더 어려운 엔지니어링 문제입니다.

- 쓰기 동기화는 다양한 저장 시스템 간의 분산 트랜잭션이 필요할 수 있으며, 이것은 올바른 해결책이 아닐 수 있습니다. 아이덴포턴트한 쓰기를 사용하는 비동기 이벤트 로그는 훨씬 더 견고하고 실용적인 접근 방식입니다.

- 큰 장점은 다양한 구성 요소 간의 느슨한 결합입니다:

  - 비동기 이벤트 스트림은 전체 시스템이 개별 구성 요소의 다운타임 또는 성능 저하에 대해 더 견고하게 만듭니다.

  - 데이터 시스템의 분리는 다른 팀에 의해 독립적으로 개발, 개선 및 유지 관리될 수 있도록 합니다.

- 하나의 소프트웨어가 모든 요구 사항을 충족하는 경우, 낮은 수준의 구성 요소에서 자체적으로 다시 구현하기보다 해당 제품을 사용하는 것이 가장 좋을 확률이 높습니다. 분리 및 구성의 장점은 모든 요구 사항을 충족하는 단일 소프트웨어가 없을 때만 그림에 나타납니다.

### 3.2 응용 프로그램 코드와 상태의 분리

- 시스템의 일부는 내구성 있는 데이터 저장을 전문으로 하고, 다른 일부는 응용 프로그램 코드 실행을 전문으로 합니다. 두 부분은 독립적인 상태로 유지하면서 상호 작용할 수 있습니다.

- 최근 동향은 상태 관리(데이터베이스)에서 상태가 없는 응용 프로그램 로직을 분리하는 것입니다. 즉, 데이터베이스에 응용 프로그램 로직을 넣지 않고 응용 프로그램에 영속적인 상태를 두지 않는 것입니다.

- 데이터 흐름, 상태 변경과 응용 프로그램 코드의 상호 작용
  데이터베이스를 응용 프로그램에 의해 조작되는 수동 변수로 취급하는 대신, 응용 프로그램 코드는 한 곳에서 상태 변경에 응답하여 다른 곳에서 상태 변경을 트리거합니다.

### 3.3 스트림 프로세서 및 서비스

- 고객이 한 화폐로 가격이 책정된 상품을 구매하지만 다른 화폐로 지불할 때, 환율 변환을 수행해야 합니다. 이를 구현하는 두 가지 방법이 있습니다.

  - 마이크로서비스 접근 방식: 구매를 처리하는 코드는 특정 화폐의 현재 환율을 얻기 위해 환율 서비스나 데이터베이스를 쿼리할 것입니다.

  - 데이터 흐름 접근 방식: 구매를 처리하는 코드는 미리 환율 업데이트 스트림을 구독하고, 환율이 변경될 때마다 현재 환율을 로컬 데이터베이스에 기록합니다. 구매를 처리할 때 로컬 데이터베이스만 쿼리하면 됩니다.

- 데이터 흐름 접근 방식은 뿐만 아니라 더 빠르며, 다른 서비스의 장애에 대해 더 견고합니다.

### 3.4 파생 상태 관찰하기

#### 3.4.1 구체화 뷰와 캐싱

- 전체 텍스트 검색 인덱스는 좋은 예입니다. 쓰기 경로는 인덱스를 업데이트하고, 읽기 경로는 키워드를 검색하기 위해 인덱스를 검색합니다.

- 인덱스가 없으면 검색 쿼리는 모든 문서를 스캔해야 하므로 매우 비용이 많이 듭니다. 인덱스가 없으면 쓰기 경로에서 작업이 덜 발생합니다(업데이트할 인덱스가 없음)만 읽기 경로에서는 훨씬 더 많은 작업이 필요합니다.

- 또 다른 옵션은 가장 일반적인 쿼리 집합에 대한 검색 결과를 미리 계산하는 것입니다. 드물게 발생하는 쿼리는 여전히 인덱스에서 제공될 수 있습니다. 이것을 캐시라고 부르지만 머터리얼라이즈드 뷰라고도 할 수 있습니다.

#### 3.4.2 읽기도 이벤트다.

- 읽기 요청을 이벤트 스트림으로 나타내고, 읽기 이벤트와 쓰기 이벤트를 스트림 프로세서를 통해 보내는 것도 가능합니다. 프로세서는 읽기 이벤트에 응답하여 읽기 결과를 출력 스트림에 방출합니다.

- 이것은 사용자가 특정 결정을 내리기 전에 사용자가 보았던 것을 재구성할 수 있게 합니다.

- 일반적인 종속성을 더 잘 추적할 수 있게 해줍니다.

### 3.5 정확성을 목표로

- 만약 여러분의 애플리케이션이 가끔 예측할 수 없는 방식으로 데이터를 손상하거나 잃어버려도 괜찮다면, 삶은 훨씬 간단합니다. 더 강력한 정확성 보증이 필요하다면 직렬화(serializability)와 원자 커밋(atomic commit)은 확립된 접근 방식입니다.

- 전통적인 트랜잭션 접근 방식은 계속해서 사용되지만, 데이터플로우 아키텍처의 맥락에서 정확성을 고려하는 방법도 있습니다.

#### 3.5.1 데이터베이스에 관한 종단간 논증

- 버그가 발생하고 사람들은 실수를 합니다. 이러한 실수로부터 복구하기 쉬운 이유로 불변하고 추가 전용 데이터를 선호합니다.

- 우리는 정확히 한 번 실행(semantics) (또는 효과적으로 한 번 실행) 아이디어를 보았습니다. 메시지 처리 중에 문제가 발생하면 포기하거나 다시 시도할 수 있습니다. 다시 시도하면 실제로 처음에 성공했을 수도 있으며, 결과적으로 메시지가 두 번 처리될 수 있습니다.

- 정확히 한 번 실행은 계산을 정렬하여 결함이 발생하지 않았을 때와 동일한 최종 효과를 내도록하는 것을 의미합니다.

- 가장 효과적인 접근 중 하나는 작업을 멱등성(idempotent)을 갖도록 만드는 것으로, 한 번 또는 여러 번 실행되더라도 동일한 효과를 가져야 합니다. 멱등성을 유지하려면 일부 추가 메타데이터(작업 ID)를 유지하고, 노드 간 장애 복구 시 펜싱(fencing)을 보장해야 할 수 있습니다.

- 두 단계 커밋(2PC)은 불행히도 트랜잭션이 한 번만 실행되도록 보장하는 데 충분하지 않습니다.

- 요청의 end-to-end 흐름을 고려해야 합니다.

- 작업을 위한 고유한 식별자(예: UUID)를 생성하고 클라이언트 응용 프로그램의 숨겨진 폼 필드로 포함하거나 관련 폼 필드의 해시를 계산하여 작업 ID를 유도할 수 있습니다. 웹 브라우저가 POST 요청을 두 번 제출하면 두 요청이 동일한 작업 ID를 가지게 됩니다. 그런 다음 해당 작업 ID를 데이터베이스까지 모두 전달하고 특정 ID로 실행하는 작업이 하나만 있는지 확인할 수 있습니다. 그런 다음 작업 ID로 고유하게 식별된 상태로 요청을 처리하도록 저장할 수 있습니다.

- 첫 번째 요청이 시간 초과되어 사용자가 중복 요청을 제출하는 것을 방지하려면 충분하지 않습니다. 문제를 해결하려면 end-to-end 솔루션이 필요하며, 이는 최종 사용자 클라이언트에서 데이터베이스까지 전달되는 트랜잭션 식별자를 필요로 합니다.

- TCP와 같은 저수준 신뢰성 메커니즘은 잘 작동하므로 나머지 고수준 오류는 상대적으로 드물게 발생합니다.

- 트랜잭션은 오랫동안 좋은 추상화로 간주되었지만 유용하지만 충분하지는 않습니다.

- 응용 프로그램별 end-to-end 정확성 속성을 제공하기 쉽게 만들어주는 F(fault-tolerance) 추상화를 탐구하는 것은 가치가 있으며, 동시에 좋은 성능과 운영 특성을 유지하는 것도 중요합니다.

#### 3.5.2 제약 조건 강제하기

##### 3.5.2.1 유일한 제약조건은 합의가 필요하다.

- 합의를 달성하는 가장 일반적인 방법 중 하나는 단일 노드를 리더로 만들고 모든 결정을 내릴 책임을 부여하는 것입니다. 리더의 장애를 허용해야 하는 경우, 다시 합의 문제에 직면하게 됩니다.

- 고유성 검사는 고유해야 하는 값을 기준으로 파티션을 나눔으로써 확장할 수 있습니다. 예를 들어, 사용자 이름을 고유해야 하는 경우 해시나 사용자 이름을 기준으로 파티션을 나눌 수 있습니다.

- 비동기 다중 마스터 복제는 다른 마스터가 동시에 충돌하는 쓰기를 허용할 수 있기 때문에 고유한 값을 더 이상 보장할 수 없으므로 제외됩니다. 제약 조건을 위반하는 쓰기를 즉시 거부하려면 동기화된 조정이 불가피합니다.

##### 3.5.2.2 로그 기반의 메세징의 유일성

- 스트림 프로세서는 로그 파티션 내의 모든 메시지를 단일 스레드에서 순차적으로 소비합니다. 스트림 프로세서는 여러 충돌 작업 중 어떤 것이 먼저 발생했는지 명확하고 결정적으로 판단할 수 있습니다.

  - 사용자 이름에 대한 모든 요청은 메시지로 인코딩됩니다.

  - 스트림 프로세서는 로그에서 요청을 순차적으로 읽습니다. 사용 가능한 사용자 이름에 대한 각 요청에 대해 이름을 사용했다고 기록하고 성공 메시지를 출력 스트림에 내보냅니다. 이미 사용 중인 사용자 이름에 대한 각 요청에 대해 거부 메시지를 출력 스트림에 내보냅니다.

  - 클라이언트는 자신의 요청에 해당하는 성공 또는 거부 메시지를 기다립니다.

- 이 접근 방식은 고유성 제약 조건뿐만 아니라 다른 종류의 제약 조건에 대해서도 작동합니다.

##### 3.5.2.3 디중 파티션 요청 처리

- 잠재적으로 세 개의 파티션이 있을 수 있습니다: 요청 ID를 포함한 파티션, 수취인 계정을 포함한 파티션 및 송금인 계정을 포함한 파티션.

- 전통적인 데이터베이스 접근 방식으로는 이 트랜잭션을 모든 세 파티션에 걸쳐 원자 커밋이 필요합니다.

- 파티션된 로그를 사용하고 원자 커밋 없이도 동등한 정확성을 달성할 수 있습니다.

  - 계정 A에서 계정 B로 돈을 이체하는 요청은 클라이언트에서 고유한 요청 ID가 부여되고, 해당 요청 ID를 기반으로 한 로그 파티션에 추가됩니다.

  - 스트림 프로세서는 요청 로그를 읽습니다. 각 요청 메시지에 대해 두 개의 메시지를 출력 스트림으로 내보냅니다. 송금인 계정 A에 대한 차감 지시사항(계정 A에 따라 파티션화)과 수취인 계정 B에 대한 입금 지시사항(계정 B에 따라 파티션화)입니다. 원본 요청 ID가 해당 출력 메시지에 포함됩니다.

  - 추가 프로세서가 입금 및 차감 지시사항의 스트림을 사용하고 요청 ID에 따라 중복을 제거하고 계정 잔액에 변경 사항을 적용합니다.

##### 3.5.2.4 타임라인과 무결성

- 로그의 소비자는 비동기적으로 설계되어 있으므로 발신자는 메시지가 소비자에 의해 처리될 때까지 기다릴 필요가 없습니다. 그러나 클라이언트가 출력 스트림에 메시지가 나타날 때까지 기다리도록 할 수 있습니다.

- 일관성은 두 가지 다른 요구 사항을 혼합합니다.

  - 타이밍: 사용자가 시스템을 최신 상태로 관찰합니다.

  - 무결성: 데이터 손실이 없으며 모순되거나 잘못된 데이터가 없음을 의미합니다. 파생은 정확해야 합니다.

- 타이밍의 위반은 "최종 일관성(eventual consistency)"이며, 무결성의 위반은 "영원한 불일치(perpetual inconsistency)"입니다.

### 3.5.3 데이터 플로우 시스템의 정확성

- 이벤트 스트림을 비동기적으로 처리할 때 메시지가 도착하기 전까지 타이밍이 보장되지 않습니다. 메시지가 도착하기를 기다리는 소비자를 명시적으로 구축하지 않는 한 타이밍은 보장되지 않습니다. 그러나 무결성은 스트리밍 시스템에서 중요한 역할을 합니다.

- 정확히 한 번 실행 또는 효과적으로 한 번 실행 세맨틱스는 무결성을 보존하기 위한 메커니즘입니다. 고장 허용 메시지 전달 및 중복 제거는 결함에 대비하여 데이터 시스템의 무결성을 유지하는 데 중요합니다.

- 스트림 처리 시스템은 분산 트랜잭션과 원자 커밋 프로토콜을 요구하지 않고도 무결성을 보존할 수 있으므로, 훨씬 더 우수한 성능과 운영적인 견고성을 가진 동등한 정확성을 달성할 수 있습니다. 무결성은 다음과 같은 메커니즘의 조합으로 달성될 수 있습니다.

      - 쓰기 작업의 내용을 단일 메시지로 표현하며, 이것은 이벤트 소싱과 잘 어울립니다.

      - 결정론적 파생 함수를 사용하여 해당 단일 메시지를 통해 모든 다른 상태 업데이트를 도출합니다.

      - 클라이언트가 생성한 요청 ID를 전달하여 end-to-end 중복 제거와 멱등성을 가능하게 합니다.

      - 메시지를 불변으로 유지하고 파생 데이터를 시간이 흐른 후에 다시 처리할 수 있게 합니다.

- 많은 비즈니스 상황에서는 제약 조건을 일시적으로 위반하고 나중에 수정하는 것이 수용 가능하며, 사과하기 위한 비용(금전 또는 평판)은 종종 상당히 낮습니다.

### 3.5.4 코디네이션 회피 데이터 시스템

- 데이터플로우 시스템은 원자 커밋, 선형화, 또는 동기화된 교차 파티션 조정 없이 파생 데이터에 대한 무결성 보증을 유지할 수 있습니다.

- 엄격한 고유성 제약 조건은 타이밍과 조정이 필요하지만, 많은 응용 프로그램은 일시적으로 위반되고 나중에 수정될 수 있는 느슨한 제약 조건을 허용하는 것이 실제로 적합합니다.

- 데이터플로우 시스템은 동기화를 필요로 하지 않으면서도 강력한 무결성 보증을 제공하면서도 많은 응용 프로그램에 대한 데이터 관리 서비스를 제공할 수 있습니다. 동기화된 조정이 필요한 시스템보다 동기화를 피하는 데이터 시스템은 더 나은 성능과 오류 허용성을 달성할 수 있습니다.

### 3.5.5 믿어라, 하지만 확인해라

- 데이터의 무결성을 확인하는 것을 감사(auditing)라고 합니다.

- 데이터가 여전히 존재하는지 확신하려면 실제로 데이터를 읽고 확인해야 합니다. 백업에서 복원을 시도하는 것은 시간마다 중요합니다. 무작정 작동한다고 믿지 말아야 합니다.

- 자가 유효성 검사 또는 자가 감사 시스템은 자체 무결성을 계속 확인합니다.

- ACID 데이터베이스는 기술을 무조건 신뢰하고 감사 가능성을 무시한 기반으로 응용 프로그램을 개발하도록 이끌었습니다.

- 반면 이벤트 기반 시스템은 더 나은 감사 기능을 제공할 수 있습니다(이벤트 소싱과 같은).

- 암호학적 감사 및 무결성 검사는 종종 Merkle 트리에 의존합니다. 암호 화폐에 대한 혹독한 홍보와 별개로, 인증서 투명성은 TLS/SSL 인증서의 유효성을 검사하기 위해 Merkle 트리를 활용하는 보안 기술입니다.

## 4. 옳은 일 하기

- 많은 데이터셋은 사람들에 관한 것입니다: 그들의 행동, 관심사, 신원 등. 이러한 데이터를 인간다운 마음가짐과 존중으로 다뤄야 합니다. 사용자도 인간이며, 인간의 존엄성이 최우선입니다.

- ACM의 소프트웨어 공학 윤리와 전문 실천 강령과 같이 이러한 문제를 해결하기 위한 지침이 있습니다.

- 소프트웨어 엔지니어들은 기술에만 집중하고 그 결과를 무시하는 것만으로는 충분하지 않습니다. 윤리적 책임은 우리들이 지는 것이기도 합니다.

- 인권을 존중하는 국가에서는 형사 사법 체계가 유죄가 증명될 때까지 무죄를 가정합니다. 그러나 자동화된 시스템은 유죄의 증거 없이 사회 참여에서 사람을 일반적으로 배제하고 항소 기회가 거의 없을 수 있습니다.

- 알고리즘의 입력에 체계적인 편향이 있는 경우, 시스템은 그 출력에서 편향을 학습하고 확대할 가능성이 가장 높습니다.

- 편향된 데이터를 입력으로 사용하여 알고리즘이 공정하고 공평한 출력을 생성할 수 있다는 믿음은 어리석은 것으로 보입니다. 그러나 데이터 기반 의사 결정을 옹호하는 사람들이 종종 암시하는 것처럼 보입니다.

- 미래를 과거보다 나아지게 하려면 도덕적 상상력이 필요하며, 이것은 오직 인간만이 제공할 수 있는 것입니다. 데이터와 모델은 우리의 도구여야 하며, 우리의 주인이 아니어야 합니다.

- 인간이 실수하면 그들은 책임을 질 수 있습니다. 알고리즘도 실수를 저지를 수 있지만, 그들이 잘못을 저지를 경우 누가 책임을 질까요?

- 신용 점수는 "과거에 어떻게 행동했는가?"를 요약하지만 예측 분석은 보통 "당신과 유사한 사람은 누구이며, 당신과 유사한 사람들은 과거에 어떻게 행동했는가?"를 기반으로 작동합니다. 다른 사람의 행동과 유사한 행동을 비교하는 것은 사람들을 스테레오타입화하는 것을 의미합니다.

- 데이터가 사람들에게 해를 끼치는 것을 방지하고 긍정적인 잠재력을 실현하는 방법을 찾아야 할 것입니다. 이러한 권력은 가장 필요한 사람들을 돕기 위해 지원을 집중시키는 데 사용될 수 있습니다.

- 서비스가 사용자가 보고 싶어하는 콘텐츠를 예측하는 데 뛰어나게 되면, 사람들에게 이미 동의하는 의견만을 보여주게 되어 스테레오타입, 잘못된 정보 및 극단화가 발생할 수 있는 반향의 방으로 이어질 수 있습니다.

- 많은 결과는 전체 시스템을 고려하여 예측할 수 있습니다(컴퓨터화된 부분뿐만 아니라). 이러한 접근 방식은 시스템스 씽킹(systems thinking)으로 알려져 있습니다.

### 4.1 사생활과 추적

- 시스템이 사용자가 명시적으로 입력한 데이터만 저장하는 경우, 사용자가 시스템이 데이터를 특정한 방식으로 저장하고 처리하기를 원하기 때문에 시스템은 사용자를 위해 서비스를 수행하고 있으며 사용자가 고객입니다.

- 그러나 사용자의 활동이 다른 작업의 부작용으로 추적되고 로그로 기록될 때, 관계는 덜 명확합니다. 서비스는 더 이상 사용자가 시스템에게 말한대로만 하는 것이 아니라 자체적인 이해관계를 가지게 되어 사용자의 이해관계와 충돌할 수 있습니다.

- 서비스가 광고를 통해 자금을 지원하는 경우 광고주가 실제 고객이되며, 사용자의 이해관계는 뒷전에 놓이게 됩니다.

- 사용자는 무료 서비스를 받으며 최대한 그 서비스와 상호작용하도록 유도됩니다. 사용자의 추적은 서비스를 자금 지원하는 광고주의 필요를 충족합니다. 이것은 본질적으로 감시입니다.

- 생각실험으로서, "데이터"라는 단어를 "감시"로 대체해 보십시오.

- 심지어 가장 국가주의적이고 억압적인 정권조차도 모든 방에서 마이크를 설치하고 모든 사람에게 위치와 이동을 추적할 수 있는 장치를 지속적으로 휴대하도록 강제할 수 있는 것은 꿈에도 그리지 못할 것입니다. 그러나 우리는 보통 자발적으로, 심지어 열렬하게 전체 감시의 세계로 던져 들어가는 것 같습니다. 차이는 데이터가 정부 기관이 아닌 기업에 의해 수집된다는 것 뿐입니다.

- 아마도 당신은 숨길 것이 없다고 생각하고 이미 기존의 권력 구조와 완전히 일치하며, 억압을 두려워하지 않아도 된다고 생각할 수 있습니다. 그러나 모든 사람이 그렇게 행운한 것은 아닙니다.

- 사용자가 그들의 데이터에 대해 무슨 일이 일어나는지 이해하지 못하면 의미 있는 동의를 할 수 없습니다. 종종 하나의 사용자 데이터도 서비스의 사용자가 아닌 다른 사람들에 대한 정보를 제공하는 경우가 있으며, 그들은 어떠한 조건에 동의하지 않았습니다.

- 감시에 동의하지 않는 사용자에게는 해당 서비스를 사용하지 않는 것이 유일한 진짜 대안입니다. 그러나 이 선택 또한 무료가 아닙니다. 서비스가 "대부분의 사람들에게 기본 사회 참여에 필수적으로 간주되는" 정도로 인기가 있으면, 사람들이 이 서비스를 사용하지 않기를 기대하는 것은 합리적이지 않습니다. 특히 서비스에 네트워크 효과가 있을 때는 사용하지 않는 사람들에게 사회적 비용이 따릅니다.

- 사용자 추적으로 인해 서비스를 사용하지 않는 것은 개인 정보 정책을 이해하고 그 서비스에 참여했을 경우 놓치게 될 수 있는 사회 참여 또는 직업 기회를 놓칠 수 있을 정도로 시간과 지식이 충분한 소수의 사람들에게만 가능한 선택입니다. 덜 특권적인 위치에 있는 사람들에게는 의미 있는 선택의 자유가 없습니다. 감시는 피할 수 없게 됩니다.

- 개인 정보 보호란 모든 것을 비밀로 유지하는 것이 아니라, 어떤 것을 누구에게 공개할 것인지, 무엇을 공개할 것인지, 무엇을 비밀로 유지할 것인지를 선택할 자유를 가지는 것을 의미합니다.

- 데이터를 획득하는 회사들은 본질적으로 "당신의 데이터를 올바르게 처리하기 위해 우리를 신뢰하십시오"라고 말합니다. 이는 개인이 무엇을 공개하고 무엇을 비밀로 유지할 것인지를 결정하는 권리를 개인에서 회사로 이전하는 것을 의미합니다.

- 서비스가 데이터를 제3자에게 판매하지 않기로 약속하더라도, 보통은 데이터를 내부적으로 처리하고 분석하는 데 무제한 권한을 부여하며, 종종 사용자에게 명백히 보이는 것보다 더 많은 처리를 수행합니다.

- 타겟팅 광고가 서비스를 지원하는 주요 자산이라면, 사람들에 대한 행동 데이터가 서비스의 핵심 자산입니다.

- 데이터 수집 시, 오늘날의 정치적 환경뿐만 아니라 미래 정부도 고려해야 합니다. 미래에 당선된 모든 정부가 인권과 시민 자유를 존중하지 않을 보장이 없으므로 "언젠가 경찰 국가를 용이하게 할 수 있는 기술을 설치하는 것은 고요한 시민 위생이다"라고 할 수 있습니다.

- 다른 사람을 검토하면서 스스로 검토를 피하는 것은 가장 중요한 권력 형태 중 하나입니다.

- 산업 혁명 시대에는 환경 보호 규정, 작업장 안전 규정, 어린이 노동 금지 및 식품 검사와 같은 안전장치가 수립되기까지 상당한 시간이 걸렸습니다. 공장이 더 이상 폐기물을 강에 버릴 수 없거나 오염된 식품을 판매하거나 노동자를 착취할 수 없게 된 것은 비즈니스 비용이 증가했음을 의심할 여지가 없습니다. 그러나 사회 전체가 크게 이익을 보았으며, 이러한 규정이 없던 시대로 돌아가길 원하는 사람은 매우 적을 것입니다.

- 우리는 사용자를 최적화할 메트릭으로 여기는 것을 그만 두고, 그들이 존중, 존엄성 및 자기 결정 권리를 가진 인간임을 기억해야 합니다. 우리는 소프트웨어를 필요로 하는 사람들의 신뢰를 확립하고 유지하기 위해 데이터 수집 및 처리 관행을 스스로 규제해야 하며, 그들에게 데이터 사용 방법에 대한 교육을 제공해야 합니다. 그들을 어둠 속에 두지 말아야 합니다.

- 각 개인이 개인 정보, 자신의 데이터에 대한 통제를 유지할 수 있도록 해야하며 감시를 통해 그 통제를 빼앗아서는 안됩니다.

- 데이터를 영원히 보유하지 말고 더 이상 필요하지 않은 경우 즉시 삭제해야 합니다.
