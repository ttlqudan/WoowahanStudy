# Chapter 1. 사용자 수에 따른 규모 확장성

## 들어가기 전에...

- 천릿길도 한 걸음부터 : 복잡한 시스템도 모든 컴포넌트가 단 한 대의 서버에서 실행되는 간단한 시스템부터 설계됨

## 1. 단일 서버

![Single Node](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/c758fc56-51d2-43e5-8b81-f6a894d4adbd)

- 사용자는 DNS를 사용해서 접속 시도함. 접속을 위해서는 DNS -> IP 로 변환하는 과정 필요함.

- DNS에서 IP 주소 반환됨.

- IP 주소로 HTTP 요청 전달됨.

- 요청 받은 웹 서버는 JSON or HTML 페이지로 응답이 반환됨.

## 2. 데이터베이스

![Database](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/976bd233-0669-44e9-ae89-897b79ba1084)

- RDBMS : MySQL, Postgresql, Oracle ...

- NoSQL : 키-값 저장소 (key-value store), 그래프 저장소 (graph store), 칼럼 저장소 (column store), 그리고 문서 저장소 (document store)

  - 예시 소프트웨어: MongoDB, DynamoDB, HBase...

- 비관계형 DB를 사용해 볼 것을 고려해 볼 만한 상황

  - 아주 낮은 응답 지연시간 (low latency)

  - 다루는 데이터가 비정형 데이터일 때

  - 데이터(JSON, XML, YAML 등)를 직렬화하거나 역직렬화만 하면 되는 경우

  - 아주 많은 양의 데이터를 저장할 필요가 있을 때

## 3. 수직적 규모 확장 vs 수평적 규모 확장

- 수직적 규모 확장 (Scale Up): 고사양 자원을 추가하는 행위

  - 단점

    - 한 대의 서버에 CPU나 메모리를 무한대 추가 불가

    - Failover 상황에 대한 자동 복구나 다중화 방안 제시 못함. 서버 장애 발생 시, 웹/앱은 바로 중단됨.

- 수평적 규모 확장 (Scale Out): 더 많은 서버를 추가해서 성능을 개선하는 행위

- 웹 서버가 다운되면 접속이 안되기 때문에 부하 분산기 또는 로드 밸런서 (Load Balancer)를 사용함.

## 4. 로드 밸런서

![Load Balancer](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/c3a86925-e93f-465a-8851-e754715f7ad0)

- 사용자는 로드밸런서의 public ip로 접속하고, 서버 간 통신에는 private ip를 사용함.

## 5. 데이터베이스 다중화

![multi-database](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/8ac8fa98-d3dc-4179-a9b0-93bbc6aa32b5)

- 보통은 DB 서버 사이에 주(master)-부(slave) 관계 설정해서 원본은 주 서버에, 사본은 부 서버에 저장하는 방식 채용.

- 보통 이 구조는 2가지 장점을 가져감

  - 쓰기 작업은 주 DB에서, 읽기 작업은 부 DB에서 수행하기에 성능이 좋아짐.

  - 자연 재해 등으로 일부 서버가 고장나거나 데이터 유실 되어도 데이터 보존 가능함.

  - 데이터를 여러 지역에 복제해둠으로써 장애 발생해도 서비스 계속 유지 가능

![Load Balancer & DB](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/94c649dd-57ed-441a-a65c-ce3cf6512e77)

- 일부 DB가 다운되서 나머지 DB에 부하가 몰릴 때, 그리고 주 DB가 다운되어 부 DB 중 하나가 새로운 주 DB가 되서 데이터가 최신화 되지 않았을 때, 예전에는 복구 스크립트를 돌렸음.

  - 다중 마스터 또는 원형 다중화 방식도 있으나 이 책에서는 다루지 않음.

- 그래서 위의 로드밸런서와 DB 다중화를 고려한 설계를 제안함.

## 6. 캐시

![cache](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/78756bdf-2f86-430f-885b-be8e5c404c6f)

- 값비싼 연산 결과 또는 자주 참조되는 데이터를 넣고, 빠른 요청을 처리하는 저장소

- 캐시 계층을 두면 DB 부하도 줄고, DB 응답보다 훨씬 빠름.

- 요청을 받은 웹 서버가 캐시 계층에 데이터가 없으면 캐시로 저장하고, 있으면 캐시 데이터 읽음. -> 읽기 주도형 캐시 전략

- 캐시 사용 시, 다음 사항들을 고려해야함.

  - 데이터 갱신은 자주 발생하지 않으나 참조는 빈번하게 일어날 때

  - 휘발성 데이터 -> 캐시 서버가 재시작되면 데이터 날아감.

  - 일관성 유지 이슈

  - 캐시 서버에 장애 발생시

  - 캐시 메모리 용량

  - 데이터 방출 정책 -> LRU, FIFO

## 7. 콘텐츠 전송 네트워크 (CDN)

![CDN](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/b9fb6350-391f-47a6-bf9d-75d51a09babf)

- 정적 콘텐츠 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크

  - Image, Video, CSS, JS 파일 등 캐싱 가능

![CDN Workflow](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/2eb7166f-cb10-49f5-92b4-7c34ed0a8a76)

- 사용자가 웹사이트 방문하면, 지리적으로 가장 가까운 CDN 서버가 콘텐츠 전달.

- 응답 헤더에는 파일이 얼마나 오래 캐시될 수 있는지 TTL(Time-To-Live) 값 있음.

- CDN 사용시 고려할 사항들

  - 비용 : 자주 사용하지 않는 콘텐츠를 캐싱하는 것은 이득이 없음.

  - 적절한 만료 시한 설정 : 만료 시한이 너무 길지도 않고 짧지도 않아야 콘텐츠 신선도 관리 및 빈번한 원본 페이지 접속을 제한할 수 있음.

  - CDN 장애 대처 : 원본 서버에서 직접 콘텐츠 가져오게 하는 것도 방법임.

  - 콘텐츠 무효화 : CDN 사업자가 사용하는 API로 무효화하거나 버전 관리 이용.

## 8. 무상태 웹 계층 (Stateless)

### 8.1 상태 의존적 웹 계층

![Stateful Web Layer](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/588e9195-1c32-457d-960f-ce183da527c5)

- 서로 상태 값을 들고 있어서, 장애 대응 및 로드 밸런서 부담 이슈 존재

### 8.2 무상태 아키텍처

![Stateless Architecture](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/afe64205-10ee-491c-b442-9f50fe388222)

- 웹 서버가 상태 정보 필요하면, 공유 스토리지 통해 가져옴.

## 9. 데이터 센터 (IDC)

- 장애가 없는 상태에서 가장 가까운 데이터 센터로 라우팅 받는데, 이를 지리적 라우팅이라고 부름

- 다중 데이터 센터 아키텍처 구축하려면 몇 가지 기술적 난제 극복 필요함.

  - 트래픽 우회 : 사용자에게 가장 가까운 데이터 센터로 트래픽을 보내야함.

  - 데이터 동기화 : IDC마다 DB가 있으면 동기화 필요.

  - 테스트와 배포: 웹 사이트 또는 애플리케이션을 여러 데이터센터에서 테스트 해보는 것도 필요함. 자동화된 배포 도구는 동일한 환경 세팅을 해줄 수 있게 지원

## 10. 메세지 큐

![message queue](https://github.com/ttlqudan/WoowahanStudy/assets/40455392/56e56f21-2014-4ce7-9d51-f344140c22ec)

- 메세지의 무손실 (즉, 메시지 큐에 일단 보관되는 메시지는 소비자가 꺼낼 때까지 안전하게 보관되는 특성)을 보장하는 비동기 통신을 지원하는 컴포넌트

- 서버 또는 서비스 간 결합이 느슨해져, 규모 확장성이 보장되는 안정적 애플리케이션 구축에 용이.

- 생산자는 소비자 프로세스가 죽어도 메시지 발행 가능하고, 소비자는 생산자 서비스가 가용 상태가 아니어도 메시지 수신 가능

## 11. 로그, 메트릭 그리고 자동화

- 로그 : 에러 로그 모니터링 중요.

- 메트릭 : 시스템 현재 상태 및 사업 현황에 대한 유용한 정보 획득 가능.

  - 호스트 단위 메트릭: cpu, ram, disk i/o 등

  - 종합 메트릭: DB 캐시 성능, 캐시 계층 성능

  - 핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문

- 자동화 : CI 툴 등을 사용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어 문제 쉽게 감지 가능

## 12. 데이터베이스의 규모 확장

- 수직적 확장 : 고성능 자원을 단일 서버에 늘리는 방식

  - 자원 증가에 제한이 존재함.

  - 장애 위험성이 크다.

  - 비용이 큼

- 수평적 확장 : 샤딩이라고도 함.

  - 샤딩이란 대규모 DB를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫음.

  - 샤딩 키는 파티션 키라고도 부르는데, 어떻게 데이터가 분산될지는 하나 이상의 칼럼으로 구성.

  - 샤딩 키 지정 시, 가장 크게 고려할 요소는 데이터를 고르게 저장할 수 있게 하는 것.

  - 샤딩할 때 문제점

    - 데이터의 재샤딩

      - 데이터가 너무 많아져 하나의 샤드로 감당 못할 때
      - 데이터 불균등에 의한 특정 샤드의 공간 소모가 다른 샤드보다 클 때

    - 유명인사: 핫스팟 키 문제로 특정 샤드에 쿼리가 집중되는 이슈

    - 조인과 비정규화: 일단 한 번 여러 샤드로 쪼개면, 여러 샤드에 걸친 데이터 조인이 어려움.

## 13. 백만 사용자, 그리고 그 이상

- 시스템 규모를 확장하는 것은 지속적이고 반복적인 과정임.
